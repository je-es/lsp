{"version":3,"sources":["../lib/lsp.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/components/Module.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/components/Program.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/node.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-4/CommonNodes/IdentNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/StmtNodes/BlockStmtNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/StmtNodes/LetStmtNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/StmtNodes/FuncStmtNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/StmtNodes/UseStmtNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/StmtNodes/DefStmtNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/StmtNodes/LoopStmtNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/StmtNodes/ControlFlowStmtNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/StmtNodes/TestStmtNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-1/StmtNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-4/ExprNodes/LiteralNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-4/ExprNodes/ObjectNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-4/ExprNodes/ParenNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/PrimitiveTypeNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/OptionalTypeNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/PointerTypeNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/ArrayTypeNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/TupleTypeNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/FunctionTypeNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/StructTypeNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/EnumTypeNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/UnionTypeNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/ErrsetTypeNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/ParenTypeNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-2/TypeNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/PrimaryNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-5/ExprNodes/MemberAccessNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-5/ExprNodes/ArrayAccessNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-5/ExprNodes/CallNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/PostfixNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/PrefixNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/BinaryNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/ConditionalNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/IfNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/SwitchNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/CatchNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/TryNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/RangeNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/OrelseNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/AsNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-5/ExprNodes/PropNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-5/ExprNodes/CaseNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-5/ExprNodes/DefaultNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/TypeofNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/SizeofNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-2/ExprNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-4/ExprNodes/ExprTupleNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-5/ExprNodes/EnumVariantNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-5/common/FieldNode.ts","../../ast-analyzer/node_modules/@je-es/ast/lib/nodes/level-5/ExprNodes/StructMemberNode.ts","../../ast-analyzer/lib/components/DiagnosticManager.ts","../../ast-analyzer/lib/components/ContextTracker.ts","../../ast-analyzer/lib/components/DebugManager.ts","../../ast-analyzer/lib/components/ScopeManager.ts","../../ast-analyzer/lib/components/IdGenerator.ts","../../ast-analyzer/lib/phases/SymbolCollector.ts","../../ast-analyzer/lib/utils/PathUtils.ts","../../ast-analyzer/lib/interfaces/PhaseBase.ts","../../ast-analyzer/lib/phases/SymbolResolver.ts","../../ast-analyzer/lib/phases/TypeValidator.ts","../../ast-analyzer/lib/components/ExpressionEvaluator.ts","../../ast-analyzer/lib/phases/SemanticValidator.ts","../../ast-analyzer/lib/ast-analyzer.ts","../../project/node_modules/@je-es/ast/lib/components/Module.ts","../../project/node_modules/@je-es/ast/lib/components/Program.ts","../../project/node_modules/@je-es/ast/lib/nodes/node.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-4/CommonNodes/IdentNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/StmtNodes/BlockStmtNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/StmtNodes/LetStmtNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/StmtNodes/FuncStmtNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/StmtNodes/UseStmtNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/StmtNodes/DefStmtNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/StmtNodes/LoopStmtNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/StmtNodes/ControlFlowStmtNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/StmtNodes/TestStmtNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-1/StmtNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-4/ExprNodes/LiteralNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-4/ExprNodes/ObjectNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-4/ExprNodes/ParenNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/PrimitiveTypeNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/OptionalTypeNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/PointerTypeNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/ArrayTypeNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/TupleTypeNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/FunctionTypeNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/StructTypeNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/EnumTypeNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/UnionTypeNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/ErrsetTypeNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/TypeNodes/ParenTypeNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-2/TypeNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/PrimaryNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-5/ExprNodes/MemberAccessNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-5/ExprNodes/ArrayAccessNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-5/ExprNodes/CallNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/PostfixNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/PrefixNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/BinaryNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/ConditionalNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/IfNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/SwitchNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/CatchNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/TryNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/RangeNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/OrelseNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/AsNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-5/ExprNodes/PropNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-5/ExprNodes/CaseNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-5/ExprNodes/DefaultNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/TypeofNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-3/ExprNodes/SizeofNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-2/ExprNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-4/ExprNodes/ExprTupleNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-5/ExprNodes/EnumVariantNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-5/common/FieldNode.ts","../../project/node_modules/@je-es/ast/lib/nodes/level-5/ExprNodes/StructMemberNode.ts","../../project/lib/project.ts","../lib/utils/diagnostics.ts","../lib/utils/completion.ts","../lib/utils/hover.ts","../lib/utils/settings.ts","../lib/utils/metrics.ts"],"sourcesContent":["// lsp.ts — A customizable language server protocol.\r\n//\r\n// Developed with ❤️ by Maysara.\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\r\n\r\n    import {\r\n        Connection,\r\n        TextDocuments,\r\n        InitializeParams,\r\n        InitializeResult,\r\n        DidChangeConfigurationNotification,\r\n        TextDocumentSyncKind,\r\n    } from 'vscode-languageserver';\r\n    import { TextDocument } from 'vscode-languageserver-textdocument';\r\n    import * as ProjectLib from '@je-es/project';\r\n    import { DiagnosticsHandler } from './utils/diagnostics';\r\n    import { CompletionHandler } from './utils/completion';\r\n    import { HoverHandler } from './utils/hover';\r\n    import { SettingsManager } from './utils/settings';\r\n    import { MetricsHandler } from './utils/metrics';\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\r\n\r\n    export interface LSPConfig {\r\n        syntax: unknown;\r\n        rootPath: string;\r\n    }\r\n\r\n    export interface ServerMetrics {\r\n        totalValidations: number;\r\n        totalErrors: number;\r\n        averageValidationTime: number;\r\n        cacheHitRate: number;\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\r\n\r\n    export class KemetLSP {\r\n        private connection: Connection;\r\n        private documents: TextDocuments<TextDocument>;\r\n        private config: LSPConfig;\r\n\r\n        // Projects\r\n        private projects: { main: ProjectLib.Project; anonymous: ProjectLib.Project } | null = null;\r\n\r\n        // Feature handlers\r\n        private diagnosticsHandler!: DiagnosticsHandler;\r\n        private completionHandler!: CompletionHandler;\r\n        private hoverHandler!: HoverHandler;\r\n        private settingsManager!: SettingsManager;\r\n        private metricsHandler!: MetricsHandler;\r\n\r\n        // Capabilities\r\n        private hasConfigurationCapability = true;\r\n        private hasWorkspaceFolderCapability = false;\r\n\r\n        // Server metrics\r\n        private serverMetrics: ServerMetrics = {\r\n            totalValidations: 0,\r\n            totalErrors: 0,\r\n            averageValidationTime: 0,\r\n            cacheHitRate: 0\r\n        };\r\n\r\n        constructor(connection: Connection, documents: TextDocuments<TextDocument>, config: LSPConfig) {\r\n            this.connection = connection;\r\n            this.documents = documents;\r\n            this.config = config;\r\n\r\n            this.initializeProjects();\r\n            this.initializeHandlers();\r\n        }\r\n\r\n        private initializeProjects(): void {\r\n            try {\r\n                console.log('[LSP] Initializing projects...');\r\n\r\n                // Load main project config\r\n                const mainProjectConfig = ProjectLib.Project.loadConfigFromPath(this.config.rootPath);\r\n                console.log('[LSP] Config loaded:', mainProjectConfig.name || 'anonymous');\r\n\r\n                // Create main project\r\n                const mainProject = ProjectLib.Project.create(\r\n                    this.config.rootPath,\r\n                    {\r\n                        config: mainProjectConfig,\r\n                        syntax: this.config.syntax,\r\n                        isAnonymous: false,\r\n                    }\r\n                );\r\n                console.log('[LSP] Main project created');\r\n\r\n                // Create anonymous project for untitled/external files\r\n                const anonProject = ProjectLib.Project.createAnonymous(this.config.syntax);\r\n                console.log('[LSP] Anonymous project created');\r\n\r\n                this.projects = { main: mainProject, anonymous: anonProject };\r\n\r\n                // Initialize the main project's program\r\n                this.projects.main.initializeProgram();\r\n                console.log('[LSP] Program initialized');\r\n\r\n            } catch (error) {\r\n                console.error('[LSP] Failed to initialize projects:', error);\r\n                throw error;\r\n            }\r\n        }\r\n\r\n        private initializeHandlers(): void {\r\n            if (!this.projects) {\r\n                throw new Error('Projects must be initialized before handlers');\r\n            }\r\n\r\n            console.log('[LSP] Initializing feature handlers...');\r\n\r\n            // Settings manager\r\n            this.settingsManager = new SettingsManager(this.connection);\r\n\r\n            // Diagnostics handler\r\n            this.diagnosticsHandler = new DiagnosticsHandler(\r\n                this.connection,\r\n                this.documents,\r\n                this.projects,\r\n                this.settingsManager,\r\n                this.serverMetrics\r\n            );\r\n\r\n            // Completion handler\r\n            this.completionHandler = new CompletionHandler(\r\n                this.connection,\r\n                this.documents,\r\n                this.projects\r\n            );\r\n\r\n            // Hover handler\r\n            this.hoverHandler = new HoverHandler(\r\n                this.connection,\r\n                this.documents,\r\n                this.projects\r\n            );\r\n\r\n            // Metrics handler\r\n            this.metricsHandler = new MetricsHandler(\r\n                this.connection,\r\n                this.projects,\r\n                this.serverMetrics\r\n            );\r\n\r\n            console.log('[LSP] Feature handlers initialized');\r\n        }\r\n\r\n        public start(): void {\r\n            this.setupConnectionHandlers();\r\n            this.setupDocumentHandlers();\r\n\r\n            // Start listening\r\n            this.documents.listen(this.connection);\r\n            this.connection.listen();\r\n\r\n            console.log('[LSP] Server is now listening for requests');\r\n        }\r\n\r\n        private setupConnectionHandlers(): void {\r\n            // Initialize\r\n            this.connection.onInitialize((params: InitializeParams) => {\r\n                return this.handleInitialize(params);\r\n            });\r\n\r\n            this.connection.onInitialized(() => {\r\n                this.handleInitialized();\r\n            });\r\n\r\n            // Configuration\r\n            this.connection.onDidChangeConfiguration(change => {\r\n                this.settingsManager.handleConfigurationChange(change);\r\n                this.connection.languages.diagnostics.refresh();\r\n            });\r\n\r\n            // Watched files\r\n            this.connection.onDidChangeWatchedFiles(_change => {\r\n                console.log('[LSP] Watched file change detected');\r\n                this.connection.languages.diagnostics.refresh();\r\n            });\r\n\r\n            // Shutdown\r\n            this.connection.onShutdown(() => {\r\n                this.handleShutdown();\r\n            });\r\n\r\n            this.connection.onExit(() => {\r\n                console.log('[LSP] Server exiting');\r\n                process.exit(0);\r\n            });\r\n        }\r\n\r\n        private setupDocumentHandlers(): void {\r\n            // Document lifecycle\r\n            this.documents.onDidOpen(async e => {\r\n                console.log(`[LSP] Document opened: ${e.document.uri}`);\r\n                this.connection.languages.diagnostics.refresh();\r\n            });\r\n\r\n            this.documents.onDidClose(e => {\r\n                this.settingsManager.clearDocumentSettings(e.document.uri);\r\n                this.diagnosticsHandler.clearInflightValidation(e.document.uri);\r\n            });\r\n\r\n            this.documents.onDidChangeContent(async change => {\r\n                if (this.projects) {\r\n                    this.connection.languages.diagnostics.refresh();\r\n                }\r\n            });\r\n        }\r\n\r\n        private handleInitialize(params: InitializeParams): InitializeResult {\r\n            try {\r\n                console.log('[LSP] Handling initialization...');\r\n\r\n                const capabilities = params.capabilities;\r\n                this.hasConfigurationCapability = !!(capabilities.workspace?.configuration);\r\n                this.hasWorkspaceFolderCapability = !!(capabilities.workspace?.workspaceFolders);\r\n\r\n                // Update settings manager\r\n                this.settingsManager.setConfigurationCapability(this.hasConfigurationCapability);\r\n\r\n                const result: InitializeResult = {\r\n                    capabilities: {\r\n                        textDocumentSync: TextDocumentSyncKind.Incremental,\r\n                        completionProvider: {\r\n                            resolveProvider: true,\r\n                            triggerCharacters: ['.', ':', '@', ' ']\r\n                        },\r\n                        diagnosticProvider: {\r\n                            interFileDependencies: false,\r\n                            workspaceDiagnostics: false\r\n                        },\r\n                        hoverProvider: true\r\n                    }\r\n                };\r\n\r\n                if (this.hasWorkspaceFolderCapability) {\r\n                    result.capabilities.workspace = {\r\n                        workspaceFolders: {\r\n                            supported: true\r\n                        }\r\n                    };\r\n                }\r\n\r\n                console.log('[LSP] Initialization complete');\r\n                return result;\r\n            } catch (e) {\r\n                console.error('[LSP] Error during initialization:', e);\r\n                throw e;\r\n            }\r\n        }\r\n\r\n        private handleInitialized(): void {\r\n            try {\r\n                if (this.hasConfigurationCapability) {\r\n                    this.connection.client.register(DidChangeConfigurationNotification.type, undefined);\r\n                }\r\n\r\n                if (this.hasWorkspaceFolderCapability) {\r\n                    this.connection.workspace.onDidChangeWorkspaceFolders(_event => {\r\n                        console.log('[LSP] Workspace folder change event received');\r\n                    });\r\n                }\r\n\r\n                this.connection.window.showInformationMessage('Kemet Language Server initialized successfully!');\r\n            } catch (e) {\r\n                console.error('[LSP] Error in onInitialized:', e);\r\n            }\r\n        }\r\n\r\n        private handleShutdown(): void {\r\n            try {\r\n                console.log('[LSP] Shutdown requested');\r\n\r\n                if (this.projects) {\r\n                    console.log('[LSP] Final metrics:', {\r\n                        server: this.serverMetrics,\r\n                        mainProject: this.projects.main.getMetrics(),\r\n                        anonymousProject: this.projects.anonymous.getMetrics()\r\n                    });\r\n\r\n                    this.projects.main.destroy();\r\n                    this.projects.anonymous.destroy();\r\n                }\r\n\r\n                console.log('[LSP] Cleanup complete');\r\n            } catch (e) {\r\n                console.error('[LSP] Shutdown error:', e);\r\n            }\r\n        }\r\n\r\n        public getProjects() {\r\n            return this.projects;\r\n        }\r\n\r\n        public getServerMetrics() {\r\n            return this.serverMetrics;\r\n        }\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// Module.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { StmtNode, StmtKind }   from '../nodes/level-1/StmtNode';\n    import { FuncStmtNode }             from '../nodes/level-3/StmtNodes/FuncStmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class Module {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            constructor(\n                public name         : string,\n                public statements   : StmtNode[],\n                public exports      : string[],\n                public imports      : string[],\n                public metadata     : Record<string, unknown>,\n            ) { }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(name: string, stmts?: StmtNode[], metadata?: Record<string, unknown>): Module {\n                return new Module(name, stmts || [], [], [], metadata || {});\n            }\n\n            validate(): boolean {\n                try {\n                    // Validate module name\n                    if (!this.name.trim()) {return false;}\n\n                    // Validate all statements\n                    return this.statements.every(stmt => stmt.validate());\n                } catch {\n                    return false;\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── FIND ──────────────────────────────┐\n\n            findStatements(predicate: (stmt: StmtNode) => boolean): StmtNode[] {\n                return this.statements.filter(predicate);\n            }\n\n            findStatement(predicate: (stmt: StmtNode) => boolean): StmtNode | undefined {\n                return this.statements.find(predicate);\n            }\n\n            findStatementsByKind(kind: StmtKind): StmtNode[] {\n                return this.statements.filter(stmt => stmt.kind === kind);\n            }\n\n            findFunction(name: string): FuncStmtNode | undefined {\n                for (const stmt of this.statements) {\n                    if (stmt.is('Func') && stmt.getFunc()!.ident.name === name) {\n                        return stmt.getFunc();\n                    }\n                }\n                return undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── CTRL ──────────────────────────────┐\n\n            removeStatement(index: number): Module {\n                if (index < 0 || index >= this.statements.length) {\n                    throw new Error(`Statement index ${index} out of bounds (0-${this.statements.length - 1})`);\n                }\n\n                const newStatements = [...this.statements];\n                newStatements.splice(index, 1);\n                return new Module(\n                    this.name,\n                    newStatements,\n                    [...this.exports],\n                    [...this.imports],\n                    { ...this.metadata }\n                );\n            }\n\n            insertStatement(index: number, statement: StmtNode): Module {\n                if (index < 0 || index > this.statements.length) {\n                    throw new Error(`Statement index ${index} out of bounds (0-${this.statements.length})`);\n                }\n\n                const newStatements = [...this.statements];\n                newStatements.splice(index, 0, statement);\n                return new Module(\n                    this.name,\n                    newStatements,\n                    [...this.exports],\n                    [...this.imports],\n                    { ...this.metadata }\n                );\n            }\n\n            replaceStatement(index: number, statement: StmtNode): Module {\n                if (index < 0 || index >= this.statements.length) {\n                    throw new Error(`Statement index ${index} out of bounds (0-${this.statements.length - 1})`);\n                }\n\n                const newStatements = [...this.statements];\n                newStatements[index] = statement;\n                return new Module(\n                    this.name,\n                    newStatements,\n                    [...this.exports],\n                    [...this.imports],\n                    { ...this.metadata }\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ──────────────────────────────┐\n\n            isEmpty(): boolean {\n                return this.statements.length === 0;\n            }\n\n            hasStatement(statement: StmtNode): boolean {\n                return this.statements.includes(statement);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ──────────────────────────────┐\n\n            getStatementCount(): number {\n                return this.statements.length;\n            }\n\n            getTotalNodes(): number {\n                let count = 1; // Count self\n                for (const statement of this.statements) {\n                    const countt = 0;\n                    statement.traverse(() => void (count++));\n                    count += countt;\n                }\n                return count;\n            }\n\n            getStatementAt(index: number): StmtNode | undefined {\n                if (index < 0 || index >= this.statements.length) {\n                    return undefined;\n                }\n                return this.statements[index];\n            }\n\n            getStatementIndex(statement: StmtNode): number {\n                return this.statements.indexOf(statement);\n            }\n\n            getPublicStatements(): StmtNode[] {\n                const arr : StmtNode[] = [];\n\n                for (const stmt of this.statements) {\n                    if(\n                        (stmt.is('Let')     && stmt.getLet()!.field.visibility.kind !== 'Private') ||\n                        (stmt.is('Def')     && stmt.getDef()!.visibility.kind  !== 'Private') ||\n                        (stmt.is('Func')    && stmt.getFunc()!.visibility.kind !== 'Private')\n                    ) { arr.push(stmt); }\n                }\n\n                return arr;\n            }\n\n            getPath(): string {\n                return this.metadata?.path as string || '';\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// Program.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Module }               from './Module';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class Program {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            constructor(\n                public modules      : Map<string, Module>,\n                public metadata?    : Record<string, unknown>,\n            ) { }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(modules?: Module[], metadata?: Record<string, unknown>): Program {\n                // create module map from modules\n                const modulesMap = new Map<string, Module>();\n                for (const module of modules || []) {\n                    modulesMap.set(module.name, module);\n                }\n\n                return new Program(modulesMap, metadata);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── FIND ──────────────────────────────┐\n\n            findModules(predicate: (module: Module, name: string) => boolean): [string, Module][] {\n                const results: [string, Module][] = [];\n                for (const [name, module] of this.modules) {\n                    if (predicate(module, name)) {\n                        results.push([name, module]);\n                    }\n                }\n                return results;\n            }\n\n            findModule(predicate: (module: Module, name: string) => boolean): [string, Module] | undefined {\n                for (const [name, module] of this.modules) {\n                    if (predicate(module, name)) {\n                        return [name, module];\n                    }\n                }\n                return undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── CTRL ──────────────────────────────┐\n\n            removeModule(name: string): Program {\n                if (!this.modules.has(name)) {return this;}\n\n                const newModules = new Map(this.modules);\n                newModules.delete(name);\n                return new Program(newModules, this.metadata);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ──────────────────────────────┐\n\n            isEmpty(): boolean {\n                return this.modules.size === 0 ||\n                    Array.from(this.modules.values()).every(m => m.statements.length === 0);\n            }\n\n            hasModule(name: string): boolean {\n                return this.modules.has(name);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ──────────────────────────────┐\n\n            getModule(name: string): Module | undefined {\n                return this.modules.get(name);\n            }\n\n            getModuleNames(): string[] {\n                return Array.from(this.modules.keys());\n            }\n\n            getTotalModules(): number {\n                return this.modules.size;\n            }\n\n            getTotalStatements(): number {\n                return Array.from(this.modules.values())\n                    .reduce((total, module) => total + module.statements.length, 0);\n            }\n\n            getTotalNodes(): number {\n                let count = this.modules.size; // Count modules themselves\n                for (const module of this.modules.values()) {\n                    count += module.getTotalNodes();\n                }\n                return count;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export interface Span {\n        start           : number;\n        end             : number;\n    }\n\n    export type VisibilityKind = 'Unset' | 'Private' | 'Public' | 'Static';\n    export interface VisibilityInfo {\n        kind            : VisibilityKind;\n        span?           : Span;\n    }\n\n    export type MutabilityKind = 'Unset' | 'Mutable' | 'Immutable';\n    export interface MutabilityInfo {\n        kind            : MutabilityKind;\n        span?           : Span;\n    }\n\n    export type ComptimeKind = 'Unset' | 'Comptime' | 'Runtime';\n    export interface ComptimeInfo {\n        kind            : ComptimeKind;\n        span?           : Span;\n    }\n\n    export interface NameInfo {\n        name            : string;\n        span            : Span;\n    }\n\n    export const DEF_SPAN : Span = { start: -1, end: -1 };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export abstract class Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            abstract readonly level     : number;\n            abstract readonly kind      : string;\n            abstract readonly span      : Span;\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── FIND ──────────────────────────────┐\n\n            // Find descendants matching predicate with proper type guard support\n            findAll<U extends Node>(predicate: (node: Node) => node is U): U[];\n            findAll(predicate: (node: Node) => boolean): Node[];\n            findAll(predicate: (node: Node) => boolean): Node[] {\n                const results: Node[] = [];\n                this.traverse(node => {\n                    if (predicate(node)) {results.push(node);}\n                });\n                return results;\n            }\n\n            // Find first descendant matching predicate with proper type guard support\n            find<U extends Node>(predicate: (node: Node) => node is U): U | null;\n            find(predicate: (node: Node) => boolean): Node | null;\n            find(predicate: (node: Node) => boolean): Node | null {\n                let result: Node | null = null;\n                this.traverse(node => {\n                    if (!result && predicate(node)) {\n                        result = node;\n                        return 'stop';\n                    }\n                });\n                return result;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌────────────────────────────── TRAVERSE ────────────────────────────┐\n\n            // Depth-first traversal with early termination support and enhanced error handling\n            traverse(visitor: (node: Node) => void | 'stop'): void {\n                try {\n                    const result = visitor(this);\n                    if (result === 'stop') {return;}\n\n                    // Get children with proper error handling\n                    let children: readonly Node[];\n                    try {\n                        children = this.getChildrenNodes();\n                    } catch (error) {\n                        throw new Error(`Failed to get children from ${this.kind} node: ${error}`);\n                    }\n\n                    // Validate children array\n                    if (!Array.isArray(children)) {\n                        throw new Error(`getChildrenNodes() returned non-array from ${this.kind} node: ${typeof children}`);\n                    }\n\n                    // Traverse each child with individual error handling\n                    for (let i = 0; i < children.length; i++) {\n                        const child = children[i];\n\n                        // Validate child\n                        if (!child) {\n                            console.warn(`Child ${i} is null/undefined in ${this.kind} node`);\n                            continue;\n                        }\n\n                        if (typeof child !== 'object') {\n                            console.warn(`Child ${i} is not an object in ${this.kind} node: ${typeof child}`);\n                            continue;\n                        }\n\n                        // Check if child is a proper Node\n                        if (!('traverse' in child) || typeof child.traverse !== 'function') {\n                            console.error(`Child ${i} (${child.constructor?.name || 'unknown'}) of ${this.kind} node is missing traverse method`);\n                            console.error('Child object keys:', Object.keys(child));\n                            console.error('Child prototype:', Object.getPrototypeOf(child));\n                            throw new Error(`Child node ${child.constructor?.name || 'unknown'} missing traverse method`);\n                        }\n\n                        // Check if child is actually a Node instance\n                        if (!(child instanceof Node)) {\n                            console.error(`Child ${i} of ${this.kind} node is not a Node instance:`, child.constructor?.name);\n                            throw new Error(`Child ${child.constructor?.name || 'unknown'} is not a Node instance`);\n                        }\n\n                        try {\n                            child.traverse(visitor);\n                        } catch (error) {\n                            throw new Error(`Traversal failed at child ${i} (${child.constructor?.name || 'unknown'}) of ${this.kind} node: ${error}`);\n                        }\n                    }\n                } catch (error) {\n                    // Re-throw with context for better debugging\n                    if (error instanceof Error && error.message.includes('Traversal failed')) {\n                        throw error; // Already has context\n                    }\n                    throw new Error(`Traversal failed at ${this.kind} node: ${error}`);\n                }\n            }\n\n            // Pre-order traversal (visit parent before children)\n            traversePreOrder(visitor: (node: Node) => void | 'stop'): void {\n                this.traverse(visitor);\n            }\n\n            // Post-order traversal (visit children before parent)\n            traversePostOrder(visitor: (node: Node) => void | 'stop'): void {\n                const visitPostOrder = (node: Node): void | 'stop' => {\n                    // First traverse children\n                    for (const child of node.getChildrenNodes()) {\n                        const result = visitPostOrder(child);\n                        if (result === 'stop') {return 'stop';}\n                    }\n\n                    // Then visit current node\n                    return visitor(node);\n                };\n\n                visitPostOrder(this);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            // Check if this node has any children\n            hasChildren(): boolean {\n                try {\n                    return this.getChildrenNodes().length > 0;\n                } catch {\n                    return false;\n                }\n            }\n\n            // Check if this node is a leaf (no children)\n            isLeaf(): boolean {\n                return !this.hasChildren();\n            }\n\n            // Get the depth of this node (maximum distance to any leaf)\n            getDepth(): number {\n                if (this.isLeaf()) {return 0;}\n\n                let maxDepth = 0;\n                try {\n                    for (const child of this.getChildrenNodes()) {\n                        maxDepth = Math.max(maxDepth, child.getDepth());\n                    }\n                } catch (error) {\n                    console.warn(`Error getting depth for ${this.kind} node:`, error);\n                    return 0;\n                }\n\n                return maxDepth + 1;\n            }\n\n            // Count total number of descendant nodes (including self)\n            getNodeCount(): number {\n                let count = 1; // Count self\n                try {\n                    this.traverse(node => {\n                        if (node !== this) {count++;}\n                    });\n                } catch (error) {\n                    console.warn(`Error counting nodes for ${this.kind} node:`, error);\n                }\n                return count;\n            }\n\n            // Get all ancestor kind's in the tree\n            getNodeKinds(): Set<string> {\n                const types = new Set<string>();\n                try {\n                    this.traverse(node => {\n                        types.add(node.kind);\n                    });\n                } catch (error) {\n                    console.warn(`Error getting node types for ${this.kind} node:`, error);\n                    types.add(this.kind); // At least add this node's type\n                }\n                return types;\n            }\n\n            // Create a deep clone of the entire subtree\n            deepClone(newSpan?: Span): Node {\n                // This is a default implementation that subclasses can override for optimization\n                const cloned = this.clone(newSpan);\n\n                // Note: Subclasses should override this method to handle their specific child cloning\n                // This is a fallback that just returns a shallow clone\n                return cloned;\n            }\n\n            // Validation method that subclasses can override\n            validate(): boolean {\n                try {\n                    // Basic validation: ensure all children are valid\n                    const children = this.getChildrenNodes();\n                    for (const child of children) {\n                        if (!child || !child.validate()) {\n                            return false;\n                        }\n                    }\n                    return true;\n                } catch (error) {\n                    console.warn(`Validation error for ${this.kind} node:`, error);\n                    return false;\n                }\n            }\n\n            // Pretty print the AST structure with better error handling\n            printTree(indent = 0): string {\n                const spaces = '  '.repeat(indent);\n                const nodeInfo = `${spaces}${this.kind} (${this.span.start}-${this.span.end})`;\n\n                try {\n                    if (this.isLeaf()) {\n                        return nodeInfo;\n                    }\n\n                    const children = this.getChildrenNodes()\n                        .map(child => {\n                            try {\n                                return child.printTree(indent + 1);\n                            } catch (error) {\n                                return `${spaces}  ERROR: ${child?.constructor?.name || 'unknown'} - ${error}`;\n                            }\n                        })\n                        .join('\\n');\n\n                    return `${nodeInfo}\\n${children}`;\n                } catch (error) {\n                    return `${nodeInfo} [ERROR: ${error}]`;\n                }\n            }\n\n            // Check structural equality with another node (ignoring spans)\n            structurallyEquals(other: Node): boolean {\n                if (this.kind !== other.kind) {return false;}\n\n                try {\n                    const thisChildren = this.getChildrenNodes();\n                    const otherChildren = other.getChildrenNodes();\n\n                    if (thisChildren.length !== otherChildren.length) {return false;}\n\n                    return thisChildren.every((child, index) =>\n                        child.structurallyEquals(otherChildren[index])\n                    );\n                } catch {\n                    return false;\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌────────────────────────────── ABSTRACT ────────────────────────────┐\n\n            // Get direct children (must be implemented by subclasses)\n            abstract getChildrenNodes(): Node[];\n\n            // Clone node (shallow copy with new span)\n            abstract clone(newSpan?: Span): Node;\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class IdentNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Ident' as const;\n            public level = 4;\n\n            constructor(\n                public span         : Span,\n                public name         : string,\n                public builtin      : boolean,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n                return children;\n            }\n\n            clone(newSpan?: Span): IdentNode {\n                const cloned = new IdentNode(newSpan ?? this.span, this.name, this.builtin);\n                return cloned;\n            }\n\n            validate(): boolean {\n                return this.name.trim().length > 0;\n            }\n\n            toString(): string {\n                return `${this.builtin ? '@' : ''}${this.name}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, name: string, builtin = false): IdentNode {\n                return new IdentNode(span, name, builtin);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// BlockStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { StmtNode }     from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class BlockStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Block' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public stmts        : StmtNode[],\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return this.stmts ? this.stmts : [];\n            }\n\n            clone(newSpan?: Span): BlockStmtNode {\n                return new BlockStmtNode(\n                    newSpan ?? this.span,\n                    this.stmts\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, stmts?: StmtNode[]): BlockStmtNode {\n                return new BlockStmtNode(span, stmts ?? []);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// LetStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, VisibilityInfo, MutabilityInfo, ComptimeInfo } from '../../node';\n    import { ExprNode }                 from '../../level-2/ExprNode';\n    import { TypeNode }                 from '../../level-2/TypeNode';\n    import { IdentNode }                from '../../level-4/CommonNodes/IdentNode';\n    import { FieldNode }                from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class LetStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Let' as const;\n            public level = 3;\n\n            constructor(\n                public span             : Span,\n                public field            : FieldNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return this.field.getChildrenNodes();\n            }\n\n            clone(newSpan?: Span): LetStmtNode {\n                return new LetStmtNode(\n                    newSpan ?? this.span,\n                    this.field.clone(newSpan),\n                );\n            }\n\n            // for factory\n            getField(): FieldNode {\n                return this.field;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, visibility: VisibilityInfo, comptime: ComptimeInfo, mutability: MutabilityInfo, ident: IdentNode, type?: TypeNode, initializer?: ExprNode): LetStmtNode {\n                const field = FieldNode.create(span, visibility, comptime, mutability, ident, type, initializer);\n                return new LetStmtNode(span, field);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// FuncStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, VisibilityInfo, ComptimeInfo } from '../../node';\n    import { TypeNode }                 from '../../level-2/TypeNode';\n    import { FieldNode }                from '../../level-5/common/FieldNode';\n    import { IdentNode }                from '../../level-4/CommonNodes/IdentNode';\n    import { StmtNode }                 from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class FuncStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Function' as const;\n            public level = 3;\n\n            constructor(\n                public span             : Span,\n                public visibility       : VisibilityInfo,\n                public comptime         : ComptimeInfo,\n                public isInline         : boolean,\n                public ident            : IdentNode,\n                public parameters       : FieldNode[],\n                public body             : StmtNode,\n                public errorType?       : TypeNode,\n                public returnType?      : TypeNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                // Add parameters\n                for (const param of this.parameters) {\n                    children.push(param);\n                }\n\n                if (this.errorType) {children.push(this.errorType);}\n                if (this.returnType) {children.push(this.returnType);}\n                if (this.body) {children.push(this.body);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): FuncStmtNode {\n                return new FuncStmtNode(\n                    newSpan ?? this.span,\n                    this.visibility,\n                    this.comptime,\n                    this.isInline,\n                    this.ident,\n                    this.parameters,\n                    this.body,\n                    this.errorType,\n                    this.returnType,\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, visibility: VisibilityInfo, comptime: ComptimeInfo, isInline: boolean, ident: IdentNode, parameters: FieldNode[], body: StmtNode, errorType?: TypeNode, returnType?: TypeNode): FuncStmtNode {\n                return new FuncStmtNode(span, visibility, comptime, isInline, ident, parameters, body, errorType, returnType);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// UseStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, VisibilityInfo } from '../../node';\n    import { IdentNode } from '../../level-4/CommonNodes/IdentNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class UseStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Use' as const;\n            public level = 3;\n\n            constructor(\n                public span             : Span,\n                public visibility       : VisibilityInfo,\n                public targetArr        : IdentNode[] | undefined,\n                public alias?           : IdentNode,\n                public path?            : string,\n                public pathSpan?        : Span,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return []; // No child nodes for UseNode\n            }\n\n            clone(newSpan?: Span): UseStmtNode {\n                return new UseStmtNode(\n                    newSpan ?? this.span,\n                    this.visibility,\n                    this.targetArr,\n                    this.alias,\n                    this.path,\n                    this.pathSpan\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, visibility: VisibilityInfo, targetArr: IdentNode[] | undefined, alias?: IdentNode, path?: string, pathSpan?: Span): UseStmtNode {\n                return new UseStmtNode(span, visibility, targetArr, alias, path, pathSpan);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            isAllModule(): boolean {\n                return this.targetArr === undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// DefStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, VisibilityInfo } from '../../node';\n    import { TypeNode }         from '../../level-2/TypeNode';\n    import { IdentNode }        from '../../level-4/CommonNodes/IdentNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class DefStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Def' as const;\n            public level = 3;\n\n            constructor(\n                public span             : Span,\n                public visibility       : VisibilityInfo,\n                public ident            : IdentNode,\n                public type             : TypeNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.type];\n            }\n\n            clone(newSpan?: Span): DefStmtNode {\n                return new DefStmtNode(\n                    newSpan ?? this.span,\n                    this.visibility,\n                    this.ident,\n                    this.type\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, visibility: VisibilityInfo, ident: IdentNode, type: TypeNode): DefStmtNode {\n                return new DefStmtNode(span, visibility, ident, type);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// LoopStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { StmtNode }     from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type LoopKind = 'For' | 'While' | 'Do';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class LoopStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public span : Span,\n                public kind : LoopKind,\n                public expr : ExprNode,\n                public stmt : StmtNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.expr, this.stmt];\n            }\n\n            clone(newSpan?: Span): LoopStmtNode {\n                return new LoopStmtNode(\n                    newSpan ?? this.span,\n                    this.kind,\n                    this.expr,\n                    this.stmt\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── IS_X ──────────────────────────────┐\n\n            isFor(): boolean {\n                return this.kind === 'For';\n            }\n\n            isWhile(): boolean {\n                return this.kind === 'While';\n            }\n\n            isDo(): boolean {\n                return this.kind === 'While';\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static createFor(span: Span, expr: ExprNode, stmt: StmtNode): LoopStmtNode {\n                return new LoopStmtNode(span, 'For', expr, stmt);\n            }\n\n            static createWhile(span: Span, expr: ExprNode, stmt: StmtNode): LoopStmtNode {\n                return new LoopStmtNode(span, 'While', expr, stmt);\n            }\n\n            static createDo(span: Span, expr: ExprNode, stmt: StmtNode): LoopStmtNode {\n                return new LoopStmtNode(span, 'Do', expr, stmt);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ControlFlowStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type ControlFlowKind = 'return' | 'break' | 'continue' | 'defer' | 'throw';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ControlFlowStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public kind         : ControlFlowKind,\n                public value?       : ExprNode, // Only for Return\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return this.value ? [this.value] : [];\n            }\n\n            clone(newSpan?: Span): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(\n                    newSpan ?? this.span,\n                    this.kind,\n                    this.value\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── IS_X ──────────────────────────────┐\n\n            isReturn(): boolean {\n                return this.kind === 'return';\n            }\n\n            isDefer(): boolean {\n                return this.kind === 'defer';\n            }\n\n            isThrow(): boolean {\n                return this.kind === 'throw';\n            }\n\n            isBreak(): boolean {\n                return this.kind === 'break';\n            }\n\n            isContinue(): boolean {\n                return this.kind === 'continue';\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static asReturn(span: Span, value?: ExprNode): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(span, 'return', value);\n            }\n\n            static asDefer(span: Span, value?: ExprNode): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(span, 'defer', value);\n            }\n\n            static asThrow(span: Span, value?: ExprNode): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(span, 'throw', value);\n            }\n\n            static asBreak(span: Span): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(span, 'break');\n            }\n\n            static asContinue(span: Span): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(span, 'continue');\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// TestStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, NameInfo } from '../../node';\n    import { BlockStmtNode }        from './BlockStmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class TestStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Test' as const;\n            public level = 3;\n\n            constructor(\n                public span             : Span,\n                public name             : NameInfo | undefined,\n                public block            : BlockStmtNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.block];\n            }\n\n            clone(newSpan?: Span): TestStmtNode {\n                return new TestStmtNode(\n                    newSpan ?? this.span,\n                    this.name,\n                    this.block\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, name: NameInfo | undefined, block: BlockStmtNode): TestStmtNode {\n                return new TestStmtNode(span, name, block);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, MutabilityInfo, VisibilityInfo, ComptimeInfo, NameInfo }\n                                        from '../node';\n    import { ExprNode }                 from '../level-2/ExprNode';\n    import { BlockStmtNode }            from '../level-3/StmtNodes/BlockStmtNode';\n    import { LetStmtNode }              from '../level-3/StmtNodes/LetStmtNode';\n    import { FuncStmtNode }             from '../level-3/StmtNodes/FuncStmtNode';\n    import { UseStmtNode }              from '../level-3/StmtNodes/UseStmtNode';\n    import { DefStmtNode }              from '../level-3/StmtNodes/DefStmtNode';\n    import { LoopStmtNode }             from '../level-3/StmtNodes/LoopStmtNode';\n    import { ControlFlowStmtNode }      from '../level-3/StmtNodes/ControlFlowStmtNode';\n    import { TypeNode }                 from '../level-2/TypeNode';\n    import { FieldNode }                from '../level-5/common/FieldNode';\n    import { IdentNode }                from '../level-4/CommonNodes/IdentNode';\n    import { TestStmtNode }             from '../level-3/StmtNodes/TestStmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type StmtKind =\n    | 'Unset'       | 'Expression'  | 'Block'       | 'Use'         | 'Def'\n    | 'Let'         | 'Func'        | 'For'         | 'While'       | 'Return'\n    | 'Break'       | 'Continue'    | 'Defer'       | 'Throw'       | 'Do'\n    | 'Test';\n\n    export type StmtTypes =\n    | ExprNode      | BlockStmtNode | TestStmtNode  | LetStmtNode   | FuncStmtNode\n    | UseStmtNode   | DefStmtNode   | LoopStmtNode  | ControlFlowStmtNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class StmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 1;\n\n            constructor(\n                public kind         : StmtKind,\n                public span         : Span,\n                public source       : StmtTypes,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                if (this.is('Block')) {\n                    children.push(...this.getBlock()!.getChildrenNodes());\n                } else if (this.source instanceof Node) {\n                    children.push(this.source);\n                }\n\n                return children;\n            }\n\n            clone(newSpan?: Span): StmtNode {\n                return new StmtNode(this.kind, newSpan ?? this.span, this.source);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            getExpr(): ExprNode | undefined {\n                if (this.is('Expression')) {\n                    return this.source as ExprNode;\n                }\n                return undefined;\n            }\n\n            getBlock(): BlockStmtNode | undefined {\n                if (this.is('Block')) {\n                    return this.source as BlockStmtNode;\n                }\n                return undefined;\n            }\n\n            getTest(): TestStmtNode | undefined {\n                if (this.is('Test')) {\n                    return this.source as TestStmtNode;\n                }\n                return undefined;\n            }\n\n            getUse(): UseStmtNode | undefined {\n                if (this.is('Use')) {\n                    return this.source as UseStmtNode;\n                }\n                return undefined;\n            }\n\n            getDef(): DefStmtNode | undefined {\n                if (this.is('Def')) {\n                    return this.source as DefStmtNode;\n                }\n                return undefined;\n            }\n\n            getLet(): LetStmtNode | undefined {\n                if (this.is('Let')) {\n                    return this.source as LetStmtNode;\n                }\n                return undefined;\n            }\n\n            getFunc(): FuncStmtNode | undefined {\n                if (this.is('Func')) {\n                    return this.source as FuncStmtNode;\n                }\n                return undefined;\n            }\n\n            getLoop(): LoopStmtNode | undefined {\n                if (this.is('For') || this.is('While') || this.is('Do')) {\n                    return this.source as LoopStmtNode;\n                }\n                return undefined;\n            }\n\n            getFor(): LoopStmtNode | undefined {\n                if (this.is('For')) {\n                    return this.source as LoopStmtNode;\n                }\n                return undefined;\n            }\n\n            getWhile(): LoopStmtNode | undefined {\n                if (this.is('While')) {\n                    return this.source as LoopStmtNode;\n                }\n                return undefined;\n            }\n\n\n            getDo(): LoopStmtNode | undefined {\n                if (this.is('Do')) {\n                    return this.source as LoopStmtNode;\n                }\n                return undefined;\n            }\n\n            getCtrlflow(): ControlFlowStmtNode | undefined {\n                if (this.is('Return') || this.is('Defer') || this.is('Throw') || this.is('Break') || this.is('Continue')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getReturn(): ControlFlowStmtNode | undefined {\n                if (this.is('Return')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getDefer(): ControlFlowStmtNode | undefined {\n                if (this.is('Defer')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getThrow(): ControlFlowStmtNode | undefined {\n                if (this.is('Throw')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getBreak(): ControlFlowStmtNode | undefined {\n                if (this.is('Break')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getContinue(): ControlFlowStmtNode | undefined {\n                if (this.is('Continue')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getStmtName(): string | undefined {\n                if (this.is('Use')) {\n                    return (this.source as UseStmtNode).alias?.name ?? (this.source as UseStmtNode).path ?? 'unknown-use';\n                } else if (this.is('Def')) {\n                    return (this.source as DefStmtNode).ident.name;\n                } else if (this.is('Let')) {\n                    return (this.source as LetStmtNode).field.ident.name;\n                } else if (this.is('Func')) {\n                    return (this.source as FuncStmtNode).ident.name;\n                }\n                return undefined;\n            }\n\n            getStmtNameSpan(): Span | undefined {\n                if (this.is('Use')) {\n                    return (this.source as UseStmtNode).span;\n                } else if (this.is('Def')) {\n                    return (this.source as DefStmtNode).ident.span;\n                } else if (this.is('Let')) {\n                    return (this.source as LetStmtNode).field.ident.span;\n                } else if (this.is('Func')) {\n                    return (this.source as FuncStmtNode).ident.span;\n                }\n                return undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: StmtKind, span: Span, data: StmtTypes): StmtNode {\n                return new StmtNode(kind, span, data);\n            }\n\n            static asExpr(span: Span, expr: ExprNode): StmtNode {\n                return StmtNode.create('Expression', span, expr);\n            }\n\n            static asBlock(span: Span, stmts: StmtNode[]): StmtNode {\n                return StmtNode.create('Block', span, BlockStmtNode.create(span, stmts));\n            }\n\n            static asUse(span: Span, visibility: VisibilityInfo, targetArr: IdentNode[] | undefined, alias?: IdentNode, path?: string, pathSpan?: Span): StmtNode {\n                return StmtNode.create('Use', span, UseStmtNode.create(span, visibility, targetArr, alias, path, pathSpan));\n            }\n\n            static asDefine(span: Span, visibility: VisibilityInfo, ident: IdentNode, type: TypeNode): StmtNode {\n                return StmtNode.create('Def', span, DefStmtNode.create(span, visibility, ident, type));\n            }\n\n            static asLet(span: Span, visibility: VisibilityInfo, comptime: ComptimeInfo, mutability: MutabilityInfo, ident: IdentNode, type?: TypeNode, initializer?: ExprNode): StmtNode {\n                return StmtNode.create('Let', span, LetStmtNode.create(span, visibility, comptime, mutability, ident, type, initializer));\n            }\n\n            static asFunc(span: Span, visibility: VisibilityInfo, comptime: ComptimeInfo, isInline: boolean, ident: IdentNode, parameters: FieldNode[], errorType: TypeNode | undefined, returnType: TypeNode | undefined, body: StmtNode): StmtNode {\n                return StmtNode.create('Func', span, FuncStmtNode.create(span, visibility, comptime, isInline, ident, parameters, body, errorType, returnType));\n            }\n\n            static asFor(span: Span, expr: ExprNode, stmt: StmtNode): StmtNode {\n                return StmtNode.create('For', span, LoopStmtNode.createFor(span, expr, stmt));\n            }\n\n            static asWhile(span: Span, expr: ExprNode, stmt: StmtNode): StmtNode {\n                return StmtNode.create('While', span, LoopStmtNode.createWhile(span, expr, stmt));\n            }\n\n            static asDo(span: Span, expr: ExprNode, stmt: StmtNode): StmtNode {\n                return StmtNode.create('Do', span, LoopStmtNode.createDo(span, expr, stmt));\n            }\n\n            static asReturn(span: Span, value?: ExprNode): StmtNode {\n                return StmtNode.create('Return', span, ControlFlowStmtNode.asReturn(span, value));\n            }\n\n            static asDefer(span: Span, value?: ExprNode): StmtNode {\n                return StmtNode.create('Defer', span, ControlFlowStmtNode.asDefer(span, value));\n            }\n\n            static asThrow(span: Span, value?: ExprNode): StmtNode {\n                return StmtNode.create('Throw', span, ControlFlowStmtNode.asThrow(span, value));\n            }\n\n            static asBreak(span: Span): StmtNode {\n                return StmtNode.create('Break', span, ControlFlowStmtNode.asBreak(span));\n            }\n\n            static asContinue(span: Span): StmtNode {\n                return StmtNode.create('Continue', span, ControlFlowStmtNode.asContinue(span));\n            }\n\n            static asTest(span: Span, nameInfo: NameInfo | undefined, block: BlockStmtNode): StmtNode {\n                return StmtNode.create('Test', span, TestStmtNode.create(span, nameInfo, block));\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── IS_X ──────────────────────────────┐\n\n            is(kind: StmtKind): boolean {\n                return this.kind === kind;\n            }\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type LiteralKind =\n    | 'Unset'         | 'Array'           | 'String'        | 'Character'\n    | 'Integer'       | 'Float'           | 'Bool'          | 'Null'\n    | 'Undefined';\n\n    export type LiteralValue =\n    | number          | string            | boolean       | null\n    | undefined       | ExprNode[];\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class LiteralNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 4;\n\n            constructor(\n                public kind         : LiteralKind,\n                public span         : Span,\n                public value        : LiteralValue,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n                if (this.kind === 'Array' && Array.isArray(this.value)) {\n                    children.push(...(this.value as ExprNode[]));\n                }\n                return children;\n            }\n\n            clone(newSpan?: Span): LiteralNode {\n                const cloned = new LiteralNode(this.kind, newSpan ?? this.span, this.value);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HHLP ──────────────────────────────┐\n\n            is(kind: LiteralKind): boolean {\n                return this.kind === kind;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: LiteralKind, span: Span, value: LiteralValue): LiteralNode {\n                return new LiteralNode(kind, span, value);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { PropNode } from '../../level-5/ExprNodes/PropNode';\nimport { IdentNode } from '../CommonNodes/IdentNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ObjectNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Object' as const;\n            public level = 4;\n\n            constructor(\n                public span         : Span,\n                public props        : PropNode[],\n                public ident        : IdentNode | undefined\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.props);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ObjectNode {\n                const cloned = new ObjectNode(newSpan || this.span, this.props, this.ident);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, props: PropNode[], ident: IdentNode | undefined): ObjectNode {\n                return new ObjectNode(span, props, ident);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ParenNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Paren' as const;\n            public level = 4;\n\n            constructor(\n                public span         : Span,\n                public source       : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.source);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ParenNode {\n                const cloned = new ParenNode(newSpan || this.span, this.source);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, source: ExprNode): ParenNode {\n                return new ParenNode(span, source);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, DEF_SPAN }     from '../../node';\n    import { IdentNode }                from '../../level-4/CommonNodes/IdentNode';\n    import { LiteralNode }              from '../../level-4/ExprNodes/LiteralNode';\n    import { ObjectNode }               from '../../level-4/ExprNodes/ObjectNode';\n    import { ParenNode }                from '../../level-4/ExprNodes/ParenNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export type PrimitiveKind =\n        | 'type'        | 'void'            | 'bool'        | 'signed'\n        | 'unsigned'    | 'float'           | 'und'         | 'null'\n        | 'cint'        | 'cflt'            | 'any'         | 'err';\n\n    export type PrimitiveTypes = IdentNode | LiteralNode | ParenNode | ObjectNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PrimitiveTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public kind         : PrimitiveKind,\n                public span         : Span,\n                public text         ?: string,\n                public width        ?: number,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [];\n            }\n\n            clone(newSpan?: Span): PrimitiveTypeNode {\n                const cloned = new PrimitiveTypeNode(this.kind, newSpan || this.span, this.text, this.width);\n                return cloned;\n            }\n\n            toString(): string {\n                switch(this.kind) {\n                    case 'void':            return 'void';\n                    case 'type':            return 'type';\n                    case 'bool':            return 'bool';\n                    case 'signed':          return 'i'+this.width;\n                    case 'unsigned':        return 'u'+this.width;\n                    case 'float':           return 'f'+this.width;\n                    case 'und':             return 'undefined';\n                    case 'null':            return 'null';\n                    case 'cint':            return 'cint';\n                    case 'cflt':            return 'cflt';\n                    case 'any':             return 'any';\n                    case 'err':             return 'err';\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: PrimitiveKind): boolean {\n                return this.kind === kind;\n            }\n\n            isVoid()          { return this.is('void'); }\n            isType()          { return this.is('type'); }\n            isNull()          { return this.is('null'); }\n            isUndefined()     { return this.is('und'); }\n            isBool()          { return this.is('bool'); }\n            isSigned()        { return this.is('signed'); }\n            isUnsigned()      { return this.is('unsigned'); }\n            isFloat()         { return this.is('float'); }\n            isInteger()       { return this.is('signed') || this.is('unsigned') || this.is('cint'); }\n            isComptimeInt()   { return this.is('cint'); }\n            isComptimeFloat() { return this.is('cflt'); }\n            isNumeric()       { return this.is('signed') || this.is('unsigned') || this.is('float') || this.is('cint') || this.is('cflt'); }\n            isAny()           { return this.is('any'); }\n            isErr()           { return this.is('err'); }\n\n            static calcWidth(prefix: string, text: string): number {\n                // Check if text starts with the prefix\n                if (!text.startsWith(prefix)) {return 0;}\n\n                // Extract the numeric part after the prefix\n                const numericPart = text.slice(prefix.length);\n\n                // Convert to number\n                const width = parseInt(numericPart, 10);\n\n                // Check if the conversion was successful\n                if (isNaN(width)) {return 0;}\n\n                return width;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: PrimitiveKind, span: Span, text?: string, width?: number): PrimitiveTypeNode {\n                return new PrimitiveTypeNode(kind, span, text, width);\n            }\n\n            static asVoid(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('void', span || DEF_SPAN);\n            }\n\n            static asType(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('type', span || DEF_SPAN);\n            }\n\n            static asNull(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('null', span || DEF_SPAN);\n            }\n\n            static asUndefined(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('und', span || DEF_SPAN);\n            }\n\n            static asAny(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('any', span || DEF_SPAN);\n            }\n\n            static asErr(span?: Span, text?: string): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('err', span || DEF_SPAN, text);\n            }\n\n            static asBool(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('bool', span || DEF_SPAN);\n            }\n\n            static asSigned(span?: Span, text?: string, width?: number): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('signed', span || DEF_SPAN, text, width);\n            }\n\n            static asUnsigned(span?: Span, text?: string, width?: number): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('unsigned', span || DEF_SPAN, text, width);\n            }\n\n            static asFloat(span?: Span, text?: string, width?: number): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('float', span || DEF_SPAN, text, width);\n            }\n\n            static asComptimeInt(span?: Span, text?: string): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('cint', span || DEF_SPAN, text, 64);\n            }\n\n            static asComptimeFloat(span?: Span, text?: string): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('cflt', span || DEF_SPAN, text, 64);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class OptionalTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Optional' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public target       : TypeNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.target];\n            }\n\n            clone(newSpan?: Span): OptionalTypeNode {\n                const cloned = new OptionalTypeNode(newSpan || this.span, this.target);\n                return cloned;\n            }\n\n            toString(): string {\n                return `?${this.target.toString()}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, target: TypeNode): OptionalTypeNode {\n                return new OptionalTypeNode(span, target);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PointerTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Pointer' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public target       : TypeNode,\n                public mutable      : boolean\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.target];\n            }\n\n            clone(newSpan?: Span): PointerTypeNode {\n                const cloned = new PointerTypeNode(newSpan || this.span, this.target, this.mutable);\n                return cloned;\n            }\n\n            toString(): string {\n                return `*${this.mutable ? 'mut ' : ''}${this.target.toString()}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, target: TypeNode, mutable = false): PointerTypeNode {\n                return new PointerTypeNode(span, target, mutable);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n    import { ExprNode }     from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ArrayTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Array' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public target       : TypeNode,\n                public size         : ExprNode | undefined,\n                public mutable      : boolean\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.target);\n                if (this.size) {children.push(this.size);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ArrayTypeNode {\n                const cloned = new ArrayTypeNode(newSpan || this.span, this.target, this.size, this.mutable);\n                return cloned;\n            }\n\n            toString(): string {\n                return `[]${this.target.toString()}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            isU8Array(): boolean {\n                return (this.target.getPrimitive() && this.target.getPrimitive()!.kind === 'unsigned' && this.target.getPrimitive()!.width === 8) ?? false;\n            }\n\n            isU16Array(): boolean {\n                return (this.target.getPrimitive() && this.target.getPrimitive()!.kind === 'unsigned' && this.target.getPrimitive()!.width === 16) ?? false;\n            }\n\n            isU32Array(): boolean {\n                return (this.target.getPrimitive() && this.target.getPrimitive()!.kind === 'unsigned' && this.target.getPrimitive()!.width === 32) ?? false;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, target: TypeNode, size?: ExprNode, mutable = false): ArrayTypeNode {\n                return new ArrayTypeNode(span, target, size, mutable);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class TupleTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Tuple' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public fields       : TypeNode[],\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [...this.fields];\n            }\n\n            clone(newSpan?: Span): TupleTypeNode {\n                const cloned = new TupleTypeNode(newSpan || this.span, this.fields);\n                return cloned;\n            }\n\n            toString(): string {\n                return `(${this.fields.join(', ')})`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, fields: TypeNode[]): TupleTypeNode {\n                return new TupleTypeNode(span, fields);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class FunctionTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Function' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public params       : TypeNode[],\n                public returnType   : TypeNode | undefined,\n                public errorType    : TypeNode | undefined,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.params);\n                if (this.returnType) {children.push(this.returnType);}\n                if (this.errorType) {children.push(this.errorType);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): FunctionTypeNode {\n                const cloned = new FunctionTypeNode(newSpan || this.span, this.params, this.returnType, this.errorType);\n                return cloned;\n            }\n\n            toString(): string {\n                return `function`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, params: TypeNode[], returnType?: TypeNode, errorType?: TypeNode): FunctionTypeNode {\n                return new FunctionTypeNode(span, params, returnType, errorType);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }       from '../../node';\n    import { StructMemberNode } from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class StructTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Struct' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public members      : StructMemberNode[],\n                public name         : string = 'Anonymous',\n                public metadata     : Record<string, unknown>,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.members);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): StructTypeNode {\n                const cloned = new StructTypeNode(newSpan || this.span, this.members, this.name, this.metadata);\n                return cloned;\n            }\n\n            toString(): string {\n                return `struct`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, members: StructMemberNode[], name: string = 'Anonymous', metadata: Record<string, unknown> = {}): StructTypeNode {\n                return new StructTypeNode(span, members, name, metadata);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }       from '../../node';\n    import { EnumVariantNode } from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class EnumTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Enum' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public variants     : EnumVariantNode[],\n                public name         : string = 'Anonymous',\n                public metadata     : Record<string, unknown>,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.variants);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): EnumTypeNode {\n                const cloned = new EnumTypeNode(newSpan || this.span, this.variants, this.name, this.metadata);\n                return cloned;\n            }\n\n            toString(): string {\n                return `enum`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, variants: EnumVariantNode[], name: string = 'Anonymous', metadata: Record<string, unknown> = {}): EnumTypeNode {\n                return new EnumTypeNode(span, variants, name, metadata);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class UnionTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Union' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public types        : TypeNode[],\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.types);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): UnionTypeNode {\n                const cloned = new UnionTypeNode(newSpan || this.span, this.types);\n                return cloned;\n            }\n\n            toString(): string {\n                return `union`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, types: TypeNode[]): UnionTypeNode {\n                return new UnionTypeNode(span, types);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { IdentNode }        from '../../../ast';\n    import { Span, Node }       from '../../node';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ErrsetTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'errset' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public members      : IdentNode[],\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.members);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ErrsetTypeNode {\n                const cloned = new ErrsetTypeNode(newSpan || this.span, this.members);\n                return cloned;\n            }\n\n            toString(): string {\n                return `error`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, members: IdentNode[]): ErrsetTypeNode {\n                return new ErrsetTypeNode(span, members);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ParenTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Paren' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public type         : TypeNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.type];\n            }\n\n            clone(newSpan?: Span): ParenTypeNode {\n                const cloned = new ParenTypeNode(newSpan || this.span, this.type);\n                return cloned;\n            }\n\n            toString(): string {\n                return `paren`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, type: TypeNode): ParenTypeNode {\n                return new ParenTypeNode(span, type);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { DEF_SPAN, Node, Span }                     from '../node';\n    import { ExprNode }                                 from './ExprNode';\n\n    import { PrimitiveKind, PrimitiveTypeNode }         from '../level-3/TypeNodes/PrimitiveTypeNode';\n    import { OptionalTypeNode }                         from '../level-3/TypeNodes/OptionalTypeNode';\n    import { PointerTypeNode }                          from '../level-3/TypeNodes/PointerTypeNode';\n    import { ArrayTypeNode }                            from '../level-3/TypeNodes/ArrayTypeNode';\n    import { TupleTypeNode }                            from '../level-3/TypeNodes/TupleTypeNode';\n    import { FunctionTypeNode }                         from '../level-3/TypeNodes/FunctionTypeNode';\n    import { StructTypeNode }                           from '../level-3/TypeNodes/StructTypeNode';\n    import { EnumTypeNode }                             from '../level-3/TypeNodes/EnumTypeNode';\n    import { UnionTypeNode }                            from '../level-3/TypeNodes/UnionTypeNode';\n\n    import { IdentNode }                                from '../level-4/CommonNodes/IdentNode';\n\n    import { StructMemberNode }                         from '../level-5/ExprNodes/StructMemberNode';\n    import { EnumVariantNode }                          from '../level-5/ExprNodes/EnumVariantNode';\n    import { ErrsetTypeNode }                           from '../level-3/TypeNodes/ErrsetTypeNode';\nimport { ParenTypeNode } from '../level-3/TypeNodes/ParenTypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type TypeKind =\n        | 'unset'       | 'primitive'   | 'ident'       | 'pointer'\n        | 'array'       | 'tuple'       | 'function'    | 'optional'\n        | 'struct'      | 'enum'        | 'union'       | 'errset'\n        | 'paren';\n\n    export type UnsetSource = null;\n\n    export type TypeTypes =\n    | UnsetSource           | PrimitiveTypeNode | IdentNode         | OptionalTypeNode\n    | PointerTypeNode       | ArrayTypeNode     | TupleTypeNode     | FunctionTypeNode\n    | StructTypeNode        | EnumTypeNode      | UnionTypeNode     | ErrsetTypeNode\n    | ParenTypeNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class TypeNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 2;\n\n            constructor(\n                public span         : Span,\n                public kind         : TypeKind,\n                public source       : TypeTypes,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            getChildrenNodes(): Node[] {\n                return this.source ? this.source.getChildrenNodes() : []; }\n\n            clone(newSpan?: Span): TypeNode {\n                return new TypeNode(newSpan ?? this.span, this.kind, this.source); }\n\n            toString(): string {\n                return this.source?.toString() || `Type(${this.kind})`; }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: TypeKind)  { return this.kind === kind; }\n            isPrimitive()       { return this.is('primitive'); }\n            isVoid()            { return this.isPrimitive() && this.getPrimitive()!.isVoid(); }\n            isType()            { return this.isPrimitive() && this.getPrimitive()!.isType(); }\n            isNull()            { return this.isPrimitive() && this.getPrimitive()!.isNull(); }\n            isUndefined()       { return this.isPrimitive() && this.getPrimitive()!.isUndefined(); }\n            isAny()             { return this.isPrimitive() && this.getPrimitive()!.isAny(); }\n            isErr()             { return this.isPrimitive() && this.getPrimitive()!.isErr(); }\n            isSigned()          { return this.isPrimitive() && this.getPrimitive()!.isSigned(); }\n            isUnsigned()        { return this.isPrimitive() && this.getPrimitive()!.isUnsigned(); }\n            isComptimeInt()     { return this.isPrimitive() && this.getPrimitive()!.isComptimeInt(); }\n            isInteger()         { return this.isPrimitive() && this.getPrimitive()!.isInteger(); }\n            isComptimeFloat()   { return this.isPrimitive() && this.getPrimitive()!.isComptimeFloat(); }\n            isFloat()           { return this.isPrimitive() && this.getPrimitive()!.isFloat(); }\n            isNumeric()         { return this.isPrimitive() && this.getPrimitive()!.isNumeric(); }\n            isBool()            { return this.isPrimitive() && this.getPrimitive()!.isBool(); }\n            isIdent()           { return this.is('ident'); }\n\n            isPointer()         { return this.kind === 'pointer'; }\n            isOptional()        { return this.kind === 'optional'; }\n            isArray()           { return this.kind === 'array'; }\n            isU8Array()         { return this.isArray() && this.getArray()!.isU8Array(); }\n            isU16Array()        { return this.isArray() && this.getArray()!.isU16Array(); }\n            isU32Array()        { return this.isArray() && this.getArray()!.isU32Array(); }\n            isTuple()           { return this.kind === 'tuple'; }\n            isFunction()        { return this.kind === 'function'; }\n            isStruct()          { return this.kind === 'struct'; }\n            isErrset()          { return this.kind === 'errset'; }\n            isEnum()            { return this.kind === 'enum'; }\n            isUnion()           { return this.kind === 'union'; }\n            isParen()           { return this.kind === 'paren'; }\n\n            getPrimitive()      : PrimitiveTypeNode | undefined { return this.is('primitive')   ? this.source as PrimitiveTypeNode  : undefined; }\n            getOptional()       : OptionalTypeNode  | undefined { return this.is('optional')    ? this.source as OptionalTypeNode   : undefined; }\n            getPointer()        : PointerTypeNode   | undefined { return this.is('pointer')     ? this.source as PointerTypeNode    : undefined; }\n            getArray()          : ArrayTypeNode     | undefined { return this.is('array')       ? this.source as ArrayTypeNode      : undefined; }\n            getTuple()          : TupleTypeNode     | undefined { return this.is('tuple')       ? this.source as TupleTypeNode      : undefined; }\n            getFunction()       : FunctionTypeNode  | undefined { return this.is('function')    ? this.source as FunctionTypeNode   : undefined; }\n            getStruct()         : StructTypeNode    | undefined { return this.is('struct')      ? this.source as StructTypeNode     : undefined; }\n            getError()          : ErrsetTypeNode    | undefined { return this.is('errset')      ? this.source as ErrsetTypeNode      : undefined; }\n            getEnum()           : EnumTypeNode      | undefined { return this.is('enum')        ? this.source as EnumTypeNode       : undefined; }\n            getUnion()          : UnionTypeNode     | undefined { return this.is('union')       ? this.source as UnionTypeNode      : undefined; }\n            getParen()          : ParenTypeNode     | undefined { return this.is('paren')       ? this.source as ParenTypeNode      : undefined; }\n            getIdent ()         : IdentNode         | undefined { return this.is('ident')       ? this.source as IdentNode          : undefined; }\n            getWidth()          : number            | undefined { return this.is('primitive')   ? this.getPrimitive()!.width        : undefined; }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static asUnset(span?: Span): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'unset', null);\n            }\n\n            static asPrimitive(span: Span | undefined, kind: PrimitiveKind, text?: string, width?: number): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'primitive', PrimitiveTypeNode.create(kind, span || DEF_SPAN, text, width));\n            }\n\n            static asVoid(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'void');\n            }\n\n            static asBool(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'bool');\n            }\n\n            static asSigned(span: Span | undefined, text: string, width?: number): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'signed', text, width ?? PrimitiveTypeNode.calcWidth('i', text));\n            }\n\n            static asUnsigned(span: Span | undefined, text: string, width?: number): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'unsigned', text, width ?? PrimitiveTypeNode.calcWidth('u', text));\n            }\n\n            static asFloat(span: Span | undefined, text: string, width?: number): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'float', text, width ?? PrimitiveTypeNode.calcWidth('f', text));\n            }\n\n            static asNull(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'null');\n            }\n\n            static asUndefined(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'und');\n            }\n\n            static asAny(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'any');\n            }\n\n            static asErr(span?: Span, text?: string): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'err', text);\n            }\n\n            static asType(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'type');\n            }\n\n            static asComptimeInt(span: Span | undefined, text: string): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'cint', text, 64);\n            }\n\n            static asComptimeFloat(span: Span | undefined, text: string): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'cflt', text, 64);\n            }\n\n            static asIdentifier(span: Span | undefined, name: string): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'ident', IdentNode.create(span || DEF_SPAN, name));\n            }\n\n            static asPointer(span: Span | undefined, target: TypeNode, mutable= false): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'pointer', PointerTypeNode.create(span || DEF_SPAN, target, mutable));\n            }\n\n            static asOptional(span: Span | undefined, target: TypeNode): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'optional', OptionalTypeNode.create(span || DEF_SPAN, target));\n            }\n\n            static asArray(span: Span | undefined, target: TypeNode, size?: ExprNode, mutable= false): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'array', ArrayTypeNode.create(span || DEF_SPAN, target, size, mutable));\n            }\n\n            static asU8Array(span: Span | undefined, mutable= false): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'array', ArrayTypeNode.create(span || DEF_SPAN, TypeNode.asUnsigned(span, 'u8', 8), undefined, mutable));\n            }\n\n            static asU16Array(span: Span | undefined, mutable= false): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'array', ArrayTypeNode.create(span || DEF_SPAN, TypeNode.asUnsigned(span, 'u16', 16), undefined, mutable));\n            }\n\n            static asU32Array(span: Span | undefined, mutable= false): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'array', ArrayTypeNode.create(span || DEF_SPAN, TypeNode.asUnsigned(span, 'u32', 32), undefined, mutable));\n            }\n\n            static asTuple(span: Span | undefined, fields: TypeNode[]): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'tuple', TupleTypeNode.create(span || DEF_SPAN, fields));\n            }\n\n            static asFunction(span: Span | undefined, params: TypeNode[], returnType?: TypeNode, errorType?: TypeNode): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'function', FunctionTypeNode.create(span || DEF_SPAN, params, returnType, errorType));\n            }\n\n            static asErrset(span: Span | undefined, members: IdentNode[]): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'errset', ErrsetTypeNode.create(span || DEF_SPAN, members));\n            }\n\n            static asStruct(span: Span | undefined, members: StructMemberNode[], name: string = 'Anonymous'): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'struct', StructTypeNode.create(span || DEF_SPAN, members, name));\n            }\n\n            static asEnum(span: Span | undefined, variants: EnumVariantNode[], name: string = 'Anonymous'): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'enum', EnumTypeNode.create(span || DEF_SPAN, variants, name));\n            }\n\n            static asUnion(span: Span | undefined, types: TypeNode[]): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'union', UnionTypeNode.create(span || DEF_SPAN, types));\n            }\n\n            static asParen(span: Span | undefined, type: TypeNode): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'paren', ParenTypeNode.create(span || DEF_SPAN, type));\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }           from '../../node';\n    import { IdentNode }            from '../../level-4/CommonNodes/IdentNode';\n    import { LiteralNode, LiteralKind, LiteralValue }\n                                    from '../../level-4/ExprNodes/LiteralNode';\n    import { ObjectNode }           from '../../level-4/ExprNodes/ObjectNode';\n    import { PropNode }             from '../../level-5/ExprNodes/PropNode';\n    import { ParenNode }            from '../../level-4/ExprNodes/ParenNode';\n    import { ExprNode }             from '../../level-2/ExprNode';\n    import { ExprTupleNode }        from '../../../ast';\n    import { TypeNode }             from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export type PrimaryKind = 'Literal' | 'Ident' | 'Paren' | 'Object' | 'Tuple' | 'Type';\n    export type PrimaryTypes = IdentNode | LiteralNode | ParenNode | ObjectNode | ExprTupleNode | TypeNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PrimaryNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public kind         : PrimaryKind,\n                public span         : Span,\n                public source       ?: PrimaryTypes,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.source!);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): PrimaryNode {\n                const cloned = new PrimaryNode(this.kind, newSpan || this.span, this.source);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: PrimaryKind): boolean {\n                return this.kind === kind;\n            }\n\n            getLiteral(): LiteralNode {\n                return this.source as LiteralNode;\n            }\n\n            getIdent(): IdentNode {\n                return this.source as IdentNode;\n            }\n\n            getObject(): ObjectNode {\n                return this.source as ObjectNode;\n            }\n\n            getParen(): ParenNode {\n                return this.source as ParenNode;\n            }\n\n            getTuple(): ExprTupleNode {\n                return this.source as ExprTupleNode;\n            }\n\n            getType(): TypeNode {\n                return this.source as TypeNode;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: PrimaryKind, span: Span, source?: PrimaryTypes): PrimaryNode {\n                // Validate\n                if(kind === 'Ident' && !(source instanceof IdentNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n                if(kind === 'Literal' && !(source instanceof LiteralNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n                if(kind === 'Object' && !(source instanceof ObjectNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n                if(kind === 'Paren' && !(source instanceof ParenNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n                if(kind === 'Tuple' && !(source instanceof ExprTupleNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n                if(kind === 'Type' && !(source instanceof TypeNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n\n                // Create\n                return new PrimaryNode(kind, span, source);\n            }\n\n            static asIdent(span:Span, name: string, builtin= false) : PrimaryNode {\n                return this.create('Ident', span, IdentNode.create(span, name, builtin));\n            }\n\n            static asLiteral(kind: LiteralKind, span:Span, value: LiteralValue) : PrimaryNode {\n                return this.create('Literal', span, LiteralNode.create(kind, span, value));\n            }\n\n            static asParen(span:Span, source: ExprNode) : PrimaryNode {\n                return this.create('Paren', span, ParenNode.create(span, source));\n            }\n\n            static asObject(span:Span, props: PropNode[], ident: IdentNode | undefined) : PrimaryNode {\n                return this.create('Object', span, ObjectNode.create(span, props, ident));\n            }\n\n            static asTuple(span:Span, exprs: ExprNode[]) : PrimaryNode {\n                return this.create('Tuple', span, ExprTupleNode.create(span, exprs));\n            }\n\n            static asType(span:Span, type: TypeNode) : PrimaryNode {\n                return this.create('Type', span, type);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class MemberAccessNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'MemberAccess' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public base         : ExprNode,\n                public target       : ExprNode,\n                public optional     : boolean\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.base);\n                children.push(this.target);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): MemberAccessNode {\n                const cloned = new MemberAccessNode(newSpan || this.span, this.base, this.target, this.optional);\n                return cloned;\n            }\n\n            toString(): string {\n                return `${this.base.toString()}${this.optional ? '?.' : '.'}${this.target.toString()}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, base: ExprNode, target: ExprNode, optional= false): MemberAccessNode {\n                return new MemberAccessNode(span, base, target, optional);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ArrayAccessNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'ArrayAccess' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public base         : ExprNode,\n                public index        : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.base);\n                children.push(this.index);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ArrayAccessNode {\n                const cloned = new ArrayAccessNode(newSpan || this.span, this.base, this.index);\n                return cloned;\n            }\n\n            toString(): string {\n                return `${this.base.toString()}[${this.index.toString()}]`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, base: ExprNode, index: ExprNode): ArrayAccessNode {\n                return new ArrayAccessNode(span, base, index);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class CallNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Call' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public base         : ExprNode,\n                public args         : ExprNode[],\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.base);\n                children.push(...this.args);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): CallNode {\n                const cloned = new CallNode(newSpan || this.span, this.base, this.args);\n                return cloned;\n            }\n\n            toString(): string {\n                const argsStr = this.args.map(arg => arg.toString()).join(', ');\n                return `${this.base.toString()}(${argsStr})`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, base: ExprNode, args: ExprNode[]): CallNode {\n                return new CallNode(span, base, args);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }           from '../../node';\n    import { ExprNode }             from '../../level-2/ExprNode';\n    import { MemberAccessNode }     from '../../level-5/ExprNodes/MemberAccessNode';\n    import { ArrayAccessNode }      from '../../level-5/ExprNodes/ArrayAccessNode';\n    import { CallNode }             from '../../level-5/ExprNodes/CallNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export type PostfixKind =\n    | 'Increment'    | 'Decrement'       | 'Dereference' | 'MemberAccess'\n    | 'Call'         | 'ArrayAccess';\n\n    export type PostfixTypes = ExprNode | MemberAccessNode | ArrayAccessNode | CallNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PostfixNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public kind         : PostfixKind,\n                public span         : Span,\n                public expr         : PostfixTypes,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.expr);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): PostfixNode {\n                const cloned = new PostfixNode(this.kind, newSpan || this.span, this.expr);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: PostfixKind): boolean {\n                return this.kind === kind;\n            }\n\n            getCall(): CallNode {\n                return this.expr as CallNode;\n            }\n\n            getMemberAccess(): MemberAccessNode {\n                return this.expr as MemberAccessNode;\n            }\n\n            getArrayAccess(): ArrayAccessNode {\n                return this.expr as ArrayAccessNode;\n            }\n\n            getAsExprNode(): ExprNode | undefined {\n                if(this.is('Increment') || this.is('Decrement') || this.is('Dereference')) {\n                    return this.expr as ExprNode;\n                }\n\n                return undefined;\n            }\n\n            toString(): string {\n                switch (this.kind) {\n                    case 'Increment':    return `${this.expr.toString()}++`;\n                    case 'Decrement':    return `${this.expr.toString()}--`;\n                    case 'Dereference':  return `*${this.expr.toString()}`;\n                    case 'MemberAccess': return this.getMemberAccess().toString();\n                    case 'ArrayAccess':  return this.getArrayAccess().toString();\n                    case 'Call':         return this.getCall().toString();\n                    default:             return `${this.expr.toString()}/* unknown postfix */`;\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: PostfixKind, span: Span, expr: PostfixTypes): PostfixNode {\n                return new PostfixNode(kind, span, expr);\n            }\n\n            static asIncrement(span: Span, base: ExprNode): PostfixNode {\n                return PostfixNode.create('Increment', span, base);\n            }\n\n            static asDecrement(span: Span, base: ExprNode): PostfixNode {\n                return PostfixNode.create('Decrement', span, base);\n            }\n\n            static asDereference(span: Span, base: ExprNode): PostfixNode {\n                return PostfixNode.create('Dereference', span, base);\n            }\n\n            static asMember(span:Span, base: ExprNode, target: ExprNode, optional= false) : PostfixNode {\n                const memberExpr = MemberAccessNode.create(span, base, target, optional);\n                return PostfixNode.create('MemberAccess', span, memberExpr);\n            }\n\n            static asArrayAccess(span: Span, base: ExprNode, index: ExprNode): PostfixNode {\n                const arrayExpr = ArrayAccessNode.create(span, base, index);\n                const node = PostfixNode.create('ArrayAccess', span, arrayExpr);\n                return node;\n            }\n\n            static asCall(span: Span, base: ExprNode, args: ExprNode[]): PostfixNode {\n                const callExpr = CallNode.create(span, base, args);\n                return PostfixNode.create('Call', span, callExpr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export type PrefixKind =\n    | 'Increment'    | 'Decrement'       | 'Reference'   | 'UnaryMinus'\n    | 'UnaryPlus'    | 'LogicalNot'      | 'BitwiseNot';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PrefixNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public kind         : PrefixKind,\n                public span         : Span,\n                public expr         : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.expr);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): PrefixNode {\n                const cloned = new PrefixNode(this.kind, newSpan || this.span, this.expr);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: PrefixKind): boolean {\n                return this.kind === kind;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: PrefixKind, span: Span, expr: ExprNode): PrefixNode {\n                return new PrefixNode(kind, span, expr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export type BinaryKind =\n    | 'Unset'         | 'Power'           | 'Additive'    | 'Multiplicative'\n    | 'Shift'         | 'Relational'      | 'Equality'    | 'Bitwise'\n    | 'Logical'       | 'BitwiseAnd'      | 'BitwiseOr'   | 'BitwiseXor'\n    | 'LogicalAnd'    | 'LogicalOr'       | 'Conditional' | 'Assignment';\n\n    const op_table: Record<string, BinaryKind> = {\n        '**': 'Power',\n\n        '*' : 'Multiplicative',\n        '/' : 'Multiplicative',\n        '%' : 'Multiplicative',\n\n        '+' : 'Additive',\n        '-' : 'Additive',\n\n        '<<': 'Shift',\n        '>>': 'Shift',\n\n        '<' : 'Relational',\n        '<=': 'Relational',\n        '>' : 'Relational',\n        '>=': 'Relational',\n\n        '==': 'Equality',\n        '!=': 'Equality',\n\n        '&' : 'BitwiseAnd',\n        '^' : 'BitwiseXor',\n        '|' : 'BitwiseOr',\n\n        'and': 'LogicalAnd',\n        'or' : 'LogicalOr',\n\n        '=' : 'Assignment',\n        '+=': 'Assignment',\n        '-=': 'Assignment',\n        '*=': 'Assignment',\n        '/=': 'Assignment',\n        '%=': 'Assignment'\n    };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class BinaryNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public kind         : BinaryKind,\n                public span         : Span,\n                public left         : ExprNode,\n                public operator     : string,\n                public right        : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.left);\n                children.push(this.right);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): BinaryNode {\n                const cloned = new BinaryNode(this.kind, newSpan || this.span, this.left, this.operator, this.right);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: BinaryKind): boolean {\n                return this.kind === kind;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, left: ExprNode, operator: string, right: ExprNode): BinaryNode {\n                const kind : BinaryNode[\"kind\"] = op_table[operator as keyof typeof op_table];\n                if (!kind) {\n                    throw new Error(`Unknown operator: ${operator}`);\n                }\n                return new BinaryNode(kind, span, left, operator, right);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ConditionalNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Conditional' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public condExpr     : ExprNode,\n                public trueExpr     : ExprNode,\n                public falseExpr    : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.condExpr);\n                children.push(this.trueExpr);\n                children.push(this.falseExpr);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ConditionalNode {\n                const cloned = new ConditionalNode(newSpan || this.span, this.condExpr, this.trueExpr, this.falseExpr);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, condExpr: ExprNode, trueExpr: ExprNode, falseExpr: ExprNode): ConditionalNode {\n                return new ConditionalNode(span, condExpr, trueExpr, falseExpr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n    import { StmtNode }         from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class IfNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'If' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public condExpr     : ExprNode,\n                public thenStmt     : StmtNode,\n                public elseStmt     : StmtNode | null\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.condExpr);\n                children.push(this.thenStmt);\n                if(this.elseStmt) { children.push(this.elseStmt);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): IfNode {\n                const cloned = new IfNode(newSpan || this.span, this.condExpr, this.thenStmt, this.elseStmt);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, condExpr: ExprNode, thenStmt: StmtNode, elseStmt: StmtNode | null): IfNode {\n                return new IfNode(span, condExpr, thenStmt, elseStmt);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { CaseNode }     from '../../level-5/ExprNodes/CaseNode';\n    import { DefaultNode }  from '../../level-5/ExprNodes/DefaultNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class SwitchNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Switch' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public condExpr     : ExprNode,\n                public cases        : CaseNode[],\n                public defCase      : DefaultNode | null\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.condExpr);\n\n                for (const caseItem of this.cases) {\n                    children.push(...caseItem.getChildrenNodes());\n                }\n\n                if (this.defCase) {\n                    children.push(...this.defCase.getChildrenNodes());\n                }\n\n                return children;\n            }\n\n            clone(newSpan?: Span): SwitchNode {\n                const cloned = new SwitchNode(newSpan || this.span, this.condExpr, this.cases, this.defCase);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, condExpr: ExprNode, cases: CaseNode[], defCase: DefaultNode | null): SwitchNode {\n                return new SwitchNode(span, condExpr, cases, defCase);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { StmtNode }         from '../../level-1/StmtNode';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class CatchNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Catch' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public leftExpr     : ExprNode,\n                public tag          : ExprNode | null,\n                public rightStmt    : StmtNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.leftExpr);\n                if(this.tag) { children.push(this.tag);}\n                children.push(this.rightStmt);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): CatchNode {\n                const cloned = new CatchNode(newSpan || this.span, this.leftExpr, this.tag, this.rightStmt);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, leftExpr: ExprNode, tag: ExprNode | null, rightStmt: StmtNode): CatchNode {\n                return new CatchNode(span, leftExpr, tag, rightStmt);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class TryNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Try' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public expr         : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.expr);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): TryNode {\n                const cloned = new TryNode(newSpan || this.span, this.expr);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, leftExpr: ExprNode): TryNode {\n                return new TryNode(span, leftExpr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class RangeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Range' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public leftExpr     : ExprNode | null,\n                public rangeType    : string,\n                public rightExpr    : ExprNode | null\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                if(this.leftExpr) { children.push(this.leftExpr);}\n                if(this.rightExpr) { children.push(this.rightExpr);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): RangeNode {\n                const cloned = new RangeNode(newSpan || this.span, this.leftExpr, this.rangeType, this.rightExpr);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, leftExpr: ExprNode | null, rangeType: string, elseStmt: ExprNode | null): RangeNode {\n                return new RangeNode(span, leftExpr, rangeType, elseStmt);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// OrelseNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class OrelseNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n            public kind = 'Orelse';\n\n            constructor(\n                public span         : Span,\n                public left         : ExprNode,\n                public right        : ExprNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.left, this.right];\n            }\n\n            clone(newSpan?: Span): OrelseNode {\n                return new OrelseNode(\n                    newSpan ?? this.span,\n                    this.left,\n                    this.right\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, left: ExprNode, right: ExprNode): OrelseNode {\n                return new OrelseNode(span, left, right);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// AsNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class AsNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n            public kind = 'As';\n\n            constructor(\n                public span         : Span,\n                public base         : ExprNode,\n                public type         : TypeNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.base, this.type];\n            }\n\n            clone(newSpan?: Span): AsNode {\n                return new AsNode(\n                    newSpan ?? this.span,\n                    this.base,\n                    this.type\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, left: ExprNode, type: TypeNode): AsNode {\n                return new AsNode(span, left, type);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { IdentNode }    from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PropNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Prop' as const;\n            public level = 5;\n\n            constructor(\n                public span        : Span,\n                public key         : IdentNode,\n                public val         : ExprNode | undefined,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                if (this.key) {children.push(this.key);}\n                if (this.val) {children.push(this.val);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): PropNode {\n                const cloned = new PropNode(newSpan ?? this.span, this.key, this.val);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, key: IdentNode, val: ExprNode): PropNode {\n                return new PropNode(span, key, val);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { StmtNode }         from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class CaseNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Case' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public expr         : ExprNode,\n                public stmt         : StmtNode | null,\n                public hasBreak     : boolean | undefined\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.expr);\n\n                if(this.stmt) { children.push(this.stmt); }\n\n                return children;\n            }\n\n            clone(newSpan?: Span): CaseNode {\n                const cloned = new CaseNode(newSpan || this.span, this.expr, this.stmt, this.hasBreak);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, expr: ExprNode, stmt: StmtNode | null, hasBreak: boolean | undefined = undefined): CaseNode {\n                return new CaseNode(span, expr, stmt, hasBreak);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { StmtNode }         from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class DefaultNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Default' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public stmt         : StmtNode,\n                public hasBreak     : boolean | undefined\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.stmt);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): DefaultNode {\n                const cloned = new DefaultNode(newSpan || this.span, this.stmt, this.hasBreak);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, stmt: StmtNode, hasBreak: boolean | undefined = undefined): DefaultNode {\n                return new DefaultNode(span, stmt, hasBreak);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// TypeofNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class TypeofNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n            public kind = 'Typeof';\n\n            constructor(\n                public span         : Span,\n                public expr         : ExprNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.expr];\n            }\n\n            clone(newSpan?: Span): TypeofNode {\n                return new TypeofNode(\n                    newSpan ?? this.span,\n                    this.expr\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, expr: ExprNode): TypeofNode {\n                return new TypeofNode(span, expr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// SizeofNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class SizeofNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n            public kind = 'Sizeof';\n\n            constructor(\n                public span         : Span,\n                public expr         : ExprNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.expr];\n            }\n\n            clone(newSpan?: Span): SizeofNode {\n                return new SizeofNode(\n                    newSpan ?? this.span,\n                    this.expr\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, expr: ExprNode): SizeofNode {\n                return new SizeofNode(span, expr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, DEF_SPAN }                         from '../node';\n    import { StmtNode }                                     from '../level-1/StmtNode';\n    import { TypeNode }                                     from './TypeNode';\n\n    import { PrimaryNode }                                  from '../level-3/ExprNodes/PrimaryNode';\n    import { PostfixNode }                                  from '../level-3/ExprNodes/PostfixNode';\n    import { PrefixNode }                                   from '../level-3/ExprNodes/PrefixNode';\n    import { BinaryNode }                                   from '../level-3/ExprNodes/BinaryNode';\n    import { ConditionalNode as CondNode }                  from '../level-3/ExprNodes/ConditionalNode';\n    import { IfNode }                                       from '../level-3/ExprNodes/IfNode';\n    import { SwitchNode }                                   from '../level-3/ExprNodes/SwitchNode';\n    import { CatchNode }                                    from '../level-3/ExprNodes/CatchNode';\n    import { TryNode }                                      from '../level-3/ExprNodes/TryNode';\n    import { RangeNode }                                    from '../level-3/ExprNodes/RangeNode';\n    import { OrelseNode }                                   from '../level-3/ExprNodes/OrelseNode';\n    import { AsNode }                                       from '../level-3/ExprNodes/AsNode';\n\n    import { LiteralNode }                                  from '../level-4/ExprNodes/LiteralNode';\n    import { IdentNode }                                    from '../level-4/CommonNodes/IdentNode';\n    import { ParenNode }                                    from '../level-4/ExprNodes/ParenNode';\n    import { ObjectNode }                                   from '../level-4/ExprNodes/ObjectNode';\n    import { ExprTupleNode }                                from '../level-4/ExprNodes/ExprTupleNode';\n\n    import { PropNode }                                     from '../level-5/ExprNodes/PropNode';\n    import { CaseNode }                                     from '../level-5/ExprNodes/CaseNode';\n    import { DefaultNode }                                  from '../level-5/ExprNodes/DefaultNode';\n    import { TypeofNode }                                   from '../level-3/ExprNodes/TypeofNode';\n    import { SizeofNode }                                   from '../level-3/ExprNodes/SizeofNode';\n\n    export { PropNode, CaseNode, DefaultNode };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type ExprKind =\n    | 'Unset'       | 'Primary'     | 'Postfix'     | 'Prefix'\n    | 'Binary'      | 'Cond'        | 'If'          | 'Switch'\n    | 'Catch'       | 'Try'         | 'Range'       | 'Orelse'\n    | 'As'          | 'Typeof'      | 'Sizeof';\n\n    export type ExprTypes =\n    | PrimaryNode   | PostfixNode   | PrefixNode    | BinaryNode\n    | CondNode      | IfNode        | SwitchNode    | CatchNode\n    | TryNode       | RangeNode     | OrelseNode    | AsNode\n    | TypeofNode    | SizeofNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ExprNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 2;\n\n            constructor(\n                public kind : ExprKind,\n                public span : Span,\n                public data : ExprTypes,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return this.data.getChildrenNodes();\n            }\n\n            clone(newSpan?: Span): ExprNode {\n                const cloned = new ExprNode(this.kind, newSpan ?? this.span, this.data);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            getPrimary()        : PrimaryNode   | undefined     { return this.is('Primary')     ? this.data as PrimaryNode      : undefined; }\n            getPostfix()        : PostfixNode   | undefined     { return this.is('Postfix')     ? this.data as PostfixNode      : undefined; }\n            getPrefix()         : PrefixNode    | undefined     { return this.is('Prefix')      ? this.data as PrefixNode       : undefined; }\n            getBinary()         : BinaryNode    | undefined     { return this.is('Binary')      ? this.data as BinaryNode       : undefined; }\n            getConditional()    : CondNode      | undefined     { return this.is('Cond')        ? this.data as CondNode         : undefined; }\n            getIf()             : IfNode        | undefined     { return this.is('If')          ? this.data as IfNode           : undefined; }\n            getSwitch()         : SwitchNode    | undefined     { return this.is('Switch')      ? this.data as SwitchNode       : undefined; }\n            getCatch()          : CatchNode     | undefined     { return this.is('Catch')       ? this.data as CatchNode        : undefined; }\n            getTry()            : TryNode       | undefined     { return this.is('Try')         ? this.data as TryNode          : undefined; }\n            getRange()          : RangeNode     | undefined     { return this.is('Range')       ? this.data as RangeNode        : undefined; }\n            getOrelse()         : OrelseNode    | undefined     { return this.is('Orelse')      ? this.data as OrelseNode       : undefined; }\n            getAs()             : AsNode        | undefined     { return this.is('As')          ? this.data as AsNode           : undefined; }\n\n            getTypeof()         : TypeofNode    | undefined     { return this.is('Typeof')      ? this.data as TypeofNode      : undefined; }\n            getSizeof()         : SizeofNode    | undefined     { return this.is('Sizeof')      ? this.data as SizeofNode      : undefined; }\n\n            getLiteral()        : LiteralNode   | undefined     { return this.is('Primary') && this.getPrimary()!.is('Literal') ? this.getPrimary()!.getLiteral() : undefined; }\n            getIdent()          : IdentNode     | undefined     { return this.is('Primary') && this.getPrimary()!.is('Ident')   ? this.getPrimary()!.getIdent()   : undefined; }\n            getParen()          : ParenNode     | undefined     { return this.is('Primary') && this.getPrimary()!.is('Paren')   ? this.getPrimary()!.getParen()   : undefined; }\n            getObject()         : ObjectNode    | undefined     { return this.is('Primary') && this.getPrimary()!.is('Object')  ? this.getPrimary()!.getObject()  : undefined; }\n            getTuple()          : ExprTupleNode | undefined     { return this.is('Primary') && this.getPrimary()!.is('Tuple')   ? this.getPrimary()!.getTuple()   : undefined; }\n            getType()           : TypeNode      | undefined     { return this.is('Primary') && this.getPrimary()!.is('Type')    ? this.getPrimary()!.getType()    : undefined; }\n\n            is(kind: ExprKind)  { return this.kind === kind; }\n            isOrEndWith(kind: ExprKind) : boolean { return (this.is(kind) || this.isParen() && this.getParen()!.source.isOrEndWith(kind)) || false; }\n\n            isIdent()           { return this.is('Primary') && this.getPrimary()!.is('Ident'); }\n            isLiteral()         { return this.is('Primary') && this.getPrimary()!.is('Literal'); }\n            isObject()          { return this.is('Primary') && this.getPrimary()!.is('Object'); }\n            isParen()           { return this.is('Primary') && this.getPrimary()!.is('Paren'); }\n            isTuple()           { return this.is('Primary') && this.getPrimary()!.is('Tuple'); }\n            isType()            { return this.is('Primary') && this.getPrimary()!.is('Type'); }\n\n            isMemberAccess()    { return this.is('Postfix') && this.getPostfix()!.is('MemberAccess'); }\n            isArrayAccess()     { return this.is('Postfix') && this.getPostfix()!.is('ArrayAccess'); }\n            isCall()            { return this.is('Postfix') && this.getPostfix()!.is('Call'); }\n            isOrelse()          { return this.is('Orelse'); }\n            isAs()              { return this.is('As'); }\n\n            isTypeof()          { return this.is('Typeof'); }\n            isSizeof()          { return this.is('Sizeof'); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            // ────────────────────────── Primary ──────────────────────────\n\n                static asPrimary(span: Span, source: PrimaryNode) : ExprNode {\n                    return new ExprNode('Primary', span, source); }\n\n                static asLiteral(span: Span, kind: LiteralNode[\"kind\"], value: LiteralNode[\"value\"]) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asLiteral(kind, span, value)); }\n\n                static asIdent(span: Span, name: string, builtin = false) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asIdent(span || DEF_SPAN, name, builtin)); }\n\n                static asType(span: Span, type: TypeNode) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asType(span || DEF_SPAN, type)); }\n\n                static asInteger(span: Span, value: number) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Integer', value); }\n\n                static asFloat(span: Span, value: number) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Float', value); }\n\n                static asBool(span: Span, value: boolean) : ExprNode  { return this.asLiteral(span || DEF_SPAN, 'Bool', value); }\n\n                static asNull(span: Span) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Null', null); }\n\n                static asUndefined(span: Span) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Undefined', undefined); }\n\n                static asString(span: Span, value: string) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'String', value); }\n\n                static asChar(span: Span, value: string) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Character', value); }\n\n                static asArray(span: Span, elements: ExprNode[]) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Array', [...elements]); }\n\n                static asObject(span: Span, props: PropNode[], ident?: IdentNode | undefined) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asObject(span || DEF_SPAN, props, ident)); }\n\n                static asParen(span:Span, expression: ExprNode) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asParen(span || DEF_SPAN, expression)); }\n\n                static asTuple(span:Span, fields: ExprNode[]) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asTuple(span || DEF_SPAN, fields)); }\n\n            // ────────────────────────── Postfix ──────────────────────────\n\n                static asPostfix(span: Span, source: PostfixNode) : ExprNode {\n                    return new ExprNode('Postfix', span, source); }\n\n                static asPostIncrement(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asIncrement(span || DEF_SPAN, base)); }\n\n                static asPostDecrement(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asDecrement(span || DEF_SPAN, base)); }\n\n                static asDereference(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asDereference(span || DEF_SPAN, base)); }\n\n                static asMemberAccess(span: Span, base: ExprNode, target: ExprNode, optional = false) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asMember(span || DEF_SPAN, base, target, optional)); }\n\n                static asCall(span: Span, base: ExprNode, args: ExprNode[]) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asCall(span || DEF_SPAN, base, args)); }\n\n                static asArrayAccess(span: Span, base: ExprNode, index: ExprNode) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asArrayAccess(span || DEF_SPAN, base, index)); }\n\n            // ────────────────────────── Prefix ──────────────────────────\n\n                static asPrefix(span: Span, source: PrefixNode) : ExprNode {\n                    return new ExprNode('Prefix', span, source); }\n\n                static asPreIncrement(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('Increment', span, base)); }\n\n                static asPreDecrement(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('Decrement', span, base)); }\n\n                static asReference(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('Reference', span, base)); }\n\n                static asUnaryMinus(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('UnaryMinus', span, base)); }\n\n                static asUnaryPlus(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('UnaryPlus', span, base)); }\n\n                static asLogicalNot(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('LogicalNot', span, base)); }\n\n                static asxBitwiseNot(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('BitwiseNot', span, base)); }\n\n            // ────────────────────────── Rest ──────────────────────────\n\n                static asBinary(span:Span, left: ExprNode, operator: string, right: ExprNode) : ExprNode {\n                    return new ExprNode('Binary', span, BinaryNode.create(span || DEF_SPAN, left, operator, right)); }\n\n                static asConditional(span: Span, condExpr: ExprNode, trueExpr: ExprNode, falseExpr: ExprNode) : ExprNode {\n                    return new ExprNode('Cond', span, CondNode.create(span || DEF_SPAN, condExpr, trueExpr, falseExpr)); }\n\n                static asIf(span: Span, condExpr: ExprNode, thenStmt: StmtNode, elseStmt: StmtNode | null) : ExprNode {\n                    return new ExprNode('If', span, IfNode.create(span || DEF_SPAN, condExpr, thenStmt, elseStmt)); }\n\n                static asSwitch(span: Span, condExpr: ExprNode, cases: CaseNode[], defCase: DefaultNode | null) : ExprNode {\n                    return new ExprNode('Switch', span, SwitchNode.create(span || DEF_SPAN, condExpr, cases, defCase)); }\n\n                static asCatch(span: Span, leftExpr: ExprNode, tag: ExprNode | null, rightStmt: StmtNode) : ExprNode {\n                    return new ExprNode('Catch', span, CatchNode.create(span || DEF_SPAN, leftExpr, tag, rightStmt)); }\n\n                static asTry(span: Span, expr: ExprNode) : ExprNode {\n                    return new ExprNode('Try', span, TryNode.create(span || DEF_SPAN, expr)); }\n\n                static asRange(span: Span, leftExpr: ExprNode | null, rangeType: string, rightExpr: ExprNode | null) : ExprNode {\n                    return new ExprNode('Range', span, RangeNode.create(span || DEF_SPAN, leftExpr, rangeType, rightExpr)); }\n\n                static asOrelse(span: Span, left: ExprNode, right: ExprNode) : ExprNode {\n                    return new ExprNode('Orelse', span, OrelseNode.create(span || DEF_SPAN, left, right)); }\n\n                static asAs(span: Span, base: ExprNode, type: TypeNode) : ExprNode {\n                    return new ExprNode('As', span, AsNode.create(span || DEF_SPAN, base, type)); }\n\n                static asTypeof(span: Span, type: ExprNode) : ExprNode {\n                    return new ExprNode('Typeof', span, TypeofNode.create(span || DEF_SPAN, type)); }\n\n                static asSizeof(span: Span, type: ExprNode) : ExprNode {\n                    return new ExprNode('Sizeof', span, SizeofNode.create(span || DEF_SPAN, type)); }\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ExprTupleNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Tuple' as const;\n            public level = 4;\n\n            constructor(\n                public span         : Span,\n                public fields       : ExprNode[],\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.fields);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ExprTupleNode {\n                const cloned = new ExprTupleNode(newSpan || this.span, this.fields);\n                return cloned;\n            }\n\n            toString(): string {\n                return `{ ${this.fields.map(f => `f${f.getIdent()!.name}`).join(', ') } }`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, fields: ExprNode[]): ExprTupleNode {\n                return new ExprTupleNode(span, fields);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// EnumVariantNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { TypeNode } from '../../level-2/TypeNode';\nimport { IdentNode } from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class EnumVariantNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'EnumVariant' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public ident        : IdentNode,\n                public type?        : TypeNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return this.type ? [this.type] : [];\n            }\n\n            clone(newSpan?: Span): EnumVariantNode {\n                return new EnumVariantNode(\n                    newSpan ?? this.span,\n                    this.ident,\n                    this.type\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            hasType(): boolean {\n                return this.type !== undefined;\n            }\n\n            isUnit(): boolean {\n                return this.type === undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, ident: IdentNode, type?: TypeNode): EnumVariantNode {\n                return new EnumVariantNode(span, ident, type);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// FieldNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, VisibilityKind, VisibilityInfo, MutabilityInfo, ComptimeInfo }\n                                        from '../../node';\n    import { ExprNode }                 from '../../level-2/ExprNode';\n    import { TypeNode }                 from '../../level-2/TypeNode';\n    import { IdentNode }                from '../../level-4/CommonNodes/IdentNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class FieldNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 5;\n            public kind = 'Field' as const;\n\n            constructor(\n                public span             : Span,\n                public visibility       : VisibilityInfo,\n                public comptime         : ComptimeInfo,\n                public mutability       : MutabilityInfo,\n                public ident            : IdentNode,\n                public type?            : TypeNode,\n                public initializer      ?: ExprNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                if (this.type)          { children.push(this.type); }\n                if (this.initializer)   { children.push(this.initializer); }\n\n                return children;\n            }\n\n            clone(newSpan?: Span): FieldNode {\n                return new FieldNode(\n                    newSpan ?? this.span,\n                    this.visibility,\n                    this.comptime,\n                    this.mutability,\n                    this.ident,\n                    this.type,\n                    this.initializer\n                );\n            }\n\n            // for factory\n            getField(): FieldNode {\n                return this;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, visibility: VisibilityInfo, comptime: ComptimeInfo, mutability: MutabilityInfo, ident: IdentNode, type?: TypeNode, initializer?: ExprNode): FieldNode {\n                return new FieldNode(span, visibility, comptime, mutability, ident, type, initializer);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// StructMemberNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { FieldNode, FuncStmtNode } from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type StructMemberKind = 'Field' | 'Method';\n\n    export type StructMemberVisibility = 'Private' | 'Public' | 'Static';\n\n    export type StructMemeberSourceType = FuncStmtNode | FieldNode\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class StructMemberNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public kind         : StructMemberKind,\n                public source       : StructMemeberSourceType\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n                if (this.source) children.push(this.source);\n                return children;\n            }\n\n            clone(newSpan?: Span): StructMemberNode {\n                return new StructMemberNode(\n                    newSpan ?? this.span,\n                    this.kind,\n                    this.source,\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            isField(): boolean {\n                return this.kind === 'Field';\n            }\n\n            isMethod(): boolean {\n                return this.kind === 'Method';\n            }\n\n            getField(): FieldNode | undefined {\n                if(this.isField()) return this.source as FieldNode;\n                return undefined;\n            }\n\n            getMethod(): FuncStmtNode | undefined {\n                if(this.isMethod()) return this.source as FuncStmtNode;\n                return undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, source: StructMemeberSourceType): StructMemberNode {\n                return new StructMemberNode(span, source.kind === 'Function' ? 'Method' : 'Field', source);\n            }\n\n            static createField(span: Span, structFieldNode: FieldNode): StructMemberNode {\n                return new StructMemberNode(span, 'Field', structFieldNode);\n            }\n\n            static createMethod(span: Span, funcNode: FuncStmtNode): StructMemberNode {\n                return new StructMemberNode(span, 'Method', funcNode);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// DiagnosticManager.ts — Simplified diagnostic management\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span }                 from '@je-es/ast';\n    import { ContextTracker }       from './ContextTracker';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export enum DiagCode {\n        // General\n        INTERNAL_ERROR              = 'INTERNAL_ERROR',\n        PARSER_ERROR                = 'PARSER_ERROR',\n        MODULE_SCOPE_NOT_FOUND      = 'MODULE_SCOPE_NOT_FOUND',\n        MODULE_NOT_FOUND            = 'MODULE_NOT_FOUND',\n        TYPE_INFERENCE_FAILED       = 'TYPE_INFERENCE_FAILED',\n        OPTIMIZATION_HINT           = 'OPTIMIZATION_HINT',\n        SYMBOL_NOT_FOUND            = 'SYMBOL_NOT_FOUND',\n        ANONYMOUS_STRUCT            = 'ANONYMOUS_STRUCT',\n        TYPE_CYCLE_DETECTED         = 'TYPE_CYCLE_DETECTE',\n        TYPE_NESTING_TOO_DEEP       = 'TYPE_NESTING_TOO_DEEP',\n        SYMBOL_NOT_EXPORTED         = 'SYMBOL_NOT_EXPORTED',\n        MISSING_REQUIRED_FIELD      = 'MISSING_REQUIRED_FIELD',\n        INVALID_VISIBILITY          = 'INVALID_VISIBILITY',\n        INVALID_TYPE_WIDTH          = 'INVALID_TYPE_WIDTH',\n        MISSING_RETURN_STATEMENT    = 'MISSING_RETURN_STATEMENT',\n        INVALID_STATIC_ACCESS       = 'INVALID_STATIC_ACCESS',\n        SYMBOL_NOT_ACCESSIBLE       = 'SYMBOL_NOT_ACCESSIBLE',\n        INVALID_SIZEOF_TARGET       = 'INVALID_SIZEOF_TARGET',\n\n        // Error handling codes\n        THROW_WITHOUT_ERROR_TYPE    = 'THROW_WITHOUT_ERROR_TYPE',\n        THROW_TYPE_MISMATCH         = 'THROW_TYPE_MISMATCH',\n        THROW_OUTSIDE_FUNCTION      = 'THROW_OUTSIDE_FUNCTION',\n        INVALID_ERROR_TYPE          = 'INVALID_ERROR_TYPE',\n\n        TYPE_VALIDATION_FAILED      = 'TYPE_VALIDATION_FAILED',\n        INVALID_TYPE_OPERATION      = 'INVALID_TYPE_OPERATION',\n        TYPE_INCOMPATIBLE           = 'TYPE_INCOMPATIBLE',\n        TYPE_INFERENCE_ERROR        = 'TYPE_INFERENCE_ERROR',\n        NULL_POINTER_ERROR          = 'NULL_POINTER_ERROR',\n        TYPE_SAFETY_ERROR           = 'TYPE_SAFETY_ERROR',\n\n        // Syntax & Structure\n        SYNTAX_ERROR                = 'SYNTAX_ERROR',\n        ANALYSIS_ERROR              = 'ANALYSIS_ERROR',\n\n        // Entry Point\n        ENTRY_MODULE_NOT_FOUND      = 'ENTRY_MODULE_NOT_FOUND',\n        ENTRY_MODULE_NO_MAIN        = 'ENTRY_MODULE_NO_MAIN',\n        ENTRY_MODULE_PRIVATE_MAIN   = 'ENTRY_MODULE_PRIVATE_MAIN',\n\n        // Type System\n        TYPE_MISMATCH               = 'TYPE_MISMATCH',\n        ARRAY_TO_NON_ARRAY          = 'ARRAY_TO_NON_ARRAY',\n        NON_ARRAY_TO_ARRAY          = 'NON_ARRAY_TO_ARRAY',\n        BOOL_TO_NON_BOOL            = 'BOOL_TO_NON_BOOL',\n        NON_BOOL_TO_BOOL            = 'NON_BOOL_TO_BOOL',\n        NEGATIVE_TO_UNSIGNED        = 'NEGATIVE_TO_UNSIGNED',\n        LITERAL_OVERFLOW            = 'LITERAL_OVERFLOW',\n        CANNOT_INFER_TYPE           = 'CANNOT_INFER_TYPE',\n\n        // Symbol Resolution\n        UNDEFINED_IDENTIFIER        = 'UNDEFINED_IDENTIFIER',\n        UNDEFINED_BUILTIN           = 'UNDEFINED_BUILTIN',\n        UNDEFINED_FUNCTION          = 'UNDEFINED_FUNCTION',\n        NOT_A_FUNCTION              = 'NOT_A_FUNCTION',\n        USED_BEFORE_DECLARED        = 'USED_BEFORE_DECLARED',\n        USED_BEFORE_INITIALIZED     = 'USED_BEFORE_INITIALIZED',\n        UNDEFINED_TYPE              = 'UNDEFINED_TYPE',\n        UNSUPPORTED_TYPE            = 'UnsupportedType',\n\n        // Self Reference\n        VARIABLE_SELF_INIT          = 'VARIABLE_SELF_INIT',\n        PARAMETER_SELF_INIT         = 'PARAMETER_SELF_INIT',\n        PARAMETER_FORWARD_REFERENCE = 'PARAMETER_FORWARD_REFERENCE',\n\n        // Shadowing\n        USE_SHADOWING               = 'USE_SHADOWING',\n        DEFINITION_SHADOWING        = 'DEFINITION_SHADOWING',\n        VARIABLE_SHADOWING          = 'VARIABLE_SHADOWING',\n        FUNCTION_SHADOWING          = 'FUNCTION_SHADOWING',\n        PARAMETER_SHADOWING         = 'PARAMETER_SHADOWING',\n        STRUCT_FIELD_SHADOWING      = 'STRUCT_FIELD_SHADOWING',\n        ENUM_VARIANT_SHADOWING      = 'ENUM_VARIANT_SHADOWING',\n        ERROR_SHADOWING             = 'ERROR_SHADOWING',\n        DUPLICATE_SYMBOL            = 'DUPLICATE_SYMBOL',\n\n        // Function Calls\n        TOO_FEW_ARGUMENTS           = 'TOO_FEW_ARGUMENTS',\n        TOO_MANY_ARGUMENTS          = 'TOO_MANY_ARGUMENTS',\n\n        // Unused Symbols\n        UNUSED_VARIABLE             = 'UNUSED_VARIABLE',\n        UNUSED_PARAMETER            = 'UNUSED_PARAMETER',\n        UNUSED_FUNCTION             = 'UNUSED_FUNCTION',\n\n        // Type Operations\n        UNARY_MINUS_NON_NUMERIC     = 'UNARY_MINUS_NON_NUMERIC',\n        UNARY_PLUS_NON_NUMERIC      = 'UNARY_PLUS_NON_NUMERIC',\n\n        // Import System\n        IMPORT_NOT_FOUND            = 'IMPORT_NOT_FOUND',\n        IMPORT_CIRCULAR_DEPENDENCY  = 'IMPORT_CIRCULAR_DEPENDENCY',\n        IMPORT_PRIVATE_SYMBOL       = 'IMPORT_PRIVATE_SYMBOL',\n\n        // OVERFLOW\n        NEGATIVE_SHIFT              = 'NEGATIVE_SHIFT',\n        SHIFT_OVERFLOW              = 'SHIFT_OVERFLOW',\n        SHIFT_RESULT_OVERFLOW       = 'SHIFT_RESULT_OVERFLOW',\n        ARITHMETIC_OVERFLOW         = 'ARITHMETIC_OVERFLOW',\n        POTENTIAL_OVERFLOW          = 'POTENTIAL_OVERFLOW',\n\n        DIVISION_BY_ZERO            = 'DIVISION_BY_ZERO',\n        MODULO_BY_ZERO              = 'MODULO_BY_ZERO',\n        PRECISION_LOSS              = 'PRECISION_LOSS',\n        ARITHMETIC_ERROR            = 'ARITHMETIC_ERROR',\n\n        ARRAY_SIZE_MISMATCH         = 'ARRAY_SIZE_MISMATCH',\n        MUTABILITY_MISMATCH         = 'MUTABILITY_MISMATCH',\n        POTENTIAL_PRECISION_LOSS    = 'POTENTIAL_PRECISION_LOSS',\n        POTENTIAL_DATA_LOSS         = 'POTENTIAL_DATA_LOSS',\n\n    }\n\n    export enum DiagKind {\n        ERROR                       = 'error',\n        WARNING                     = 'warning',\n        INFO                        = 'info'\n    }\n\n    export interface Diagnostic {\n        code        : DiagCode;\n        kind        : DiagKind;\n        contextSpan ?: Span;\n        targetSpan  ?: Span;\n        msg         : string;\n        fixes       ?: DiagnosticFix[];\n\n        sourceModuleName ?: string;\n        sourceModulePath ?: string;\n    }\n\n    export interface DiagnosticFix {\n        kind        : 'add' | 'remove' | 'replace' | 'rename';\n        span        : Span;\n        msg         : string;\n        fix         ?: () => void;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class DiagnosticManager {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public diagnostics          : Diagnostic[] = [];\n            private readonly strictMode : boolean;\n            private contextTracker      : ContextTracker;\n\n            constructor(contextTracker: ContextTracker, strictMode = false) {\n                this.strictMode         = strictMode;\n                this.contextTracker     = contextTracker;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            push(diagnostic: Diagnostic): void {\n\n                // Enrich diagnostic only if values are not already provided by the caller\n                if (!diagnostic.sourceModuleName) {\n                    diagnostic.sourceModuleName = this.contextTracker.getModuleName();\n                }\n                if (!diagnostic.sourceModulePath) {\n                    // Prefer the explicit module path from the context tracker when available\n                    const ctxPath = this.contextTracker.getModulePath();\n                    if (ctxPath && ctxPath.length > 0) {\n                        diagnostic.sourceModulePath = ctxPath;\n                    } else {\n                        // Best-effort fallback: if we know the module name, synthesize a\n                        // reasonable relative path like './<moduleName>' so downstream\n                        // consumers get a non-empty path. This avoids clearing path in\n                        // earlier phases and provides a predictable default.\n                        const moduleName = this.contextTracker.getModuleName();\n                        if (moduleName && moduleName.length > 0) {\n                            diagnostic.sourceModulePath = `./${moduleName}`;\n                        }\n                    }\n                }\n                if (!diagnostic.contextSpan) {\n                    diagnostic.contextSpan = this.contextTracker.getContextSpan();\n                }\n\n                if (this.strictMode && this.diagnostics.length > 0 && diagnostic.kind === DiagKind.ERROR) {\n                    // In strict mode, avoid pushing more errors after the first\n                    return;\n                }\n\n                this.diagnostics.push(diagnostic);\n            }\n\n            reportError(code: DiagCode, msg: string, targetSpan?: Span): void {\n                this.push({ code, kind: DiagKind.ERROR, msg, targetSpan });\n            }\n\n            reportWarning(code: DiagCode, msg: string, targetSpan?: Span): void {\n                this.push({ code, kind: DiagKind.WARNING, msg, targetSpan });\n            }\n\n            reportInfo(code: DiagCode, msg: string, targetSpan?: Span): void {\n                this.push({ code, kind: DiagKind.INFO, msg, targetSpan });\n            }\n\n            addErrorDiagnostic(diagnostic: { message: string, phase: any, severity: 'error' | 'warning' | 'info' }): void {\n                this.push({\n                    code: DiagCode.ANALYSIS_ERROR,\n                    kind: diagnostic.severity === 'error' ? DiagKind.ERROR :\n                          diagnostic.severity === 'warning' ? DiagKind.WARNING :\n                          DiagKind.INFO,\n                    msg: diagnostic.message\n                });\n            }\n\n            getDiagnostics(): Diagnostic[] {\n                return this.filterDuplicates(this.diagnostics);\n            }\n\n            reset(): void {\n                this.diagnostics = [];\n            }\n\n            hasErrors(): boolean {\n                return this.diagnostics.some(d => d.kind === DiagKind.ERROR);\n            }\n\n            length(): number {\n                return this.diagnostics.length;\n            }\n\n            getAllErrors(): Diagnostic[] {\n                return this.diagnostics.filter(d => d.kind === DiagKind.ERROR);\n            }\n\n            getAllWarnings(): Diagnostic[] {\n                return this.diagnostics.filter(d => d.kind === DiagKind.WARNING);\n            }\n\n            getAllInfos(): Diagnostic[] {\n                return this.diagnostics.filter(d => d.kind === DiagKind.INFO);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            private getContextKey(diagnostic: Diagnostic): string {\n                return diagnostic.contextSpan\n                    ? `c:${diagnostic.contextSpan.start}-${diagnostic.contextSpan.end}`\n                    : 'no-context';\n            }\n\n            private isMoreSpecific(d1: Diagnostic, d2: Diagnostic): boolean {\n                // Longer message usually means more context\n                if (d1.msg.length !== d2.msg.length) {\n                    return d1.msg.length > d2.msg.length;\n                }\n\n                // Larger context span means more detail\n                const context1Size = d1.contextSpan\n                    ? d1.contextSpan.end - d1.contextSpan.start\n                    : 0;\n                const context2Size = d2.contextSpan\n                    ? d2.contextSpan.end - d2.contextSpan.start\n                    : 0;\n\n                if (context1Size !== context2Size) {\n                    return context1Size > context2Size;\n                }\n\n                // Check priority (error > warning)\n                return this.hasHigherPriority(d1, d2);\n            }\n\n            private hasHigherPriority(d1: Diagnostic, d2: Diagnostic): boolean {\n                const priority = { error: 2, warning: 1, info: 0 };\n                return (priority[d1.kind] || 0) > (priority[d2.kind] || 0);\n            }\n\n            private filterDuplicates(diagnostics: Diagnostic[]): Diagnostic[] {\n                const seen = new Map<string, Diagnostic>();\n\n                for (const diagnostic of diagnostics) {\n                    let foundDuplicate = false;\n                    let duplicateKey: string | null = null;\n\n                    // First, check if this is the same issue as any existing diagnostic\n                    for (const [key, existingDiagnostic] of seen.entries()) {\n                        if (this.isSameIssue(diagnostic, existingDiagnostic)) {\n                            foundDuplicate = true;\n                            duplicateKey = key;\n                            break;\n                        }\n                    }\n\n                    if (!foundDuplicate) {\n                        // No duplicate found, use the normal target key\n                        const targetKey = this.getTargetKey(diagnostic);\n                        seen.set(targetKey, diagnostic);\n                    } else if (duplicateKey) {\n                        // Found a duplicate - keep the more specific one\n                        const existing = seen.get(duplicateKey)!;\n                        if (this.isMoreSpecific(diagnostic, existing)) {\n                            seen.set(duplicateKey, diagnostic);\n                        }\n                    }\n                }\n\n                return Array.from(seen.values());\n            }\n\n            private getTargetKey(diagnostic: Diagnostic): string {\n                const targetKey = diagnostic.targetSpan\n                    ? `t:${diagnostic.targetSpan.start}-${diagnostic.targetSpan.end}`\n                    : 'no-target';\n                // Remove diagnostic code from key to allow different codes for same location\n                return targetKey;\n            }\n\n            private isSameIssue(d1: Diagnostic, d2: Diagnostic): boolean {\n                // Same target span is the primary indicator\n                const target1 = d1.targetSpan ? `${d1.targetSpan.start}-${d1.targetSpan.end}` : 'no-target';\n                const target2 = d2.targetSpan ? `${d2.targetSpan.start}-${d2.targetSpan.end}` : 'no-target';\n\n                if (target1 !== target2) {\n                    return false;\n                }\n\n                // Extract identifier from message using more flexible patterns\n                const identifierPatterns = [\n                    /identifier '([^']+)'/i,\n                    /Symbol '([^']+)'/i,\n                    /'([^']+)' already imported/i,\n                    /'([^']+)' shadows use/i\n                ];\n\n                let id1: string | null = null;\n                let id2: string | null = null;\n\n                for (const pattern of identifierPatterns) {\n                    id1 = id1 || d1.msg.match(pattern)?.[1] || null;\n                    id2 = id2 || d2.msg.match(pattern)?.[1] || null;\n                }\n\n                // If both mention the same identifier, it's the same issue\n                if (id1 && id2 && id1 === id2) {\n                    return true;\n                }\n\n                // Check for duplicate/shadowing patterns with same target\n                const isDuplicateRelated = (code: DiagCode) =>\n                    code === DiagCode.DUPLICATE_SYMBOL ||\n                    code === DiagCode.USE_SHADOWING ||\n                    code === DiagCode.VARIABLE_SHADOWING ||\n                    code === DiagCode.FUNCTION_SHADOWING ||\n                    code === DiagCode.DEFINITION_SHADOWING ||\n                    code === DiagCode.PARAMETER_SHADOWING;\n\n                if (isDuplicateRelated(d1.code) && isDuplicateRelated(d2.code)) {\n                    return true;\n                }\n\n                return false;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ContextTracker.ts — Enhanced with state save/restore mechanism\r\n//\r\n// Developed with ❤️ by Maysara.\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\r\n\r\n    import * as AST                 from '@je-es/ast';\r\n    import { ScopeId, SymbolId }    from './ScopeManager';\r\n    import { DebugManager }         from './DebugManager';\r\n    import { DiagnosticManager }    from './DiagnosticManager';\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ TYPES ════════════════════════════════════════╗\r\n\r\n    export enum DeclarationPhase {\r\n        PreDeclaration          = 'PreDeclaration',\r\n        InDeclaration           = 'InDeclaration',\r\n        InInitialization        = 'InInitialization',\r\n        PostDeclaration         = 'PostDeclaration'\r\n    }\r\n\r\n    export enum ExpressionContext {\r\n        VariableInitializer     = 'VariableInitializer',\r\n        ParameterInitializer    = 'ParameterInitializer',\r\n        FunctionBody            = 'FunctionBody',\r\n        AssignmentTarget        = 'AssignmentTarget',\r\n        AssignmentSource        = 'AssignmentSource',\r\n        ConditionExpression     = 'ConditionExpression',\r\n        ReturnExpression        = 'ReturnExpression',\r\n        DeferExpression         = 'DeferExpression',\r\n        ThrowExpression         = 'ThrowExpression',\r\n        CallArgument            = 'CallArgument',\r\n        FunctionCall            = 'FunctionCall',\r\n        GeneralExpression       = 'GeneralExpression'\r\n    }\r\n\r\n    export interface DeclarationContext {\r\n        symbolName              : string;\r\n        symbolId                : SymbolId;\r\n        symbolKind              : SymbolKind;\r\n        phase                   : DeclarationPhase;\r\n        span                    : AST.Span;\r\n        parentScope             : ScopeId;\r\n    }\r\n\r\n    export interface ExpressionContextInfo {\r\n        type                    : ExpressionContext;\r\n        relatedSymbol           ?: SymbolId;\r\n        depth                   : number;\r\n        span                    : AST.Span;\r\n    }\r\n\r\n    export interface AnalysisContext {\r\n        currentModuleName       : string;\r\n        currentModulePath       : string;\r\n        currentPhase            : AnalysisPhase;\r\n        contextSpanStack        : AST.Span[];\r\n        declarationStack        : DeclarationContext[];\r\n        expressionStack         : ExpressionContextInfo[];\r\n        currentScope            : ScopeId;\r\n        processingSymbols       : Set<SymbolId>;\r\n        pendingReferences       : Map<string, AST.Span[]>;\r\n        resolvedSymbols         : Set<SymbolId>;\r\n    }\r\n\r\n    export enum AnalysisPhase {\r\n        Collection              = 'Collection',\r\n        Resolution              = 'Resolution',\r\n        TypeValidation          = 'TypeValidation',\r\n        SemanticValidation      = 'SemanticValidation',\r\n        FinalValidation         = 'FinalValidation'\r\n    }\r\n\r\n    export type SymbolKind = 'let' | 'Param' | 'fn' | 'Use' | 'def';\r\n\r\n    // NEW: Saved state for scope operations\r\n    export interface SavedContextState {\r\n        scopeId                 : ScopeId;\r\n        moduleName              : string;\r\n        modulePath              : string;\r\n        spanStackDepth          : number;\r\n        declarationStackDepth   : number;\r\n        expressionStackDepth    : number;\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\r\n\r\n    export class ContextTracker {\r\n\r\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\r\n\r\n            private context             : AnalysisContext;\r\n            private currentPhase        : AnalysisPhase;\r\n            private phaseStack          : AnalysisPhase[];\r\n            private contextMap          : Map<string, unknown>;\r\n\r\n            constructor(\r\n                private debugManager?: DebugManager,\r\n                private diagnosticManager?: DiagnosticManager\r\n            ) {\r\n                this.context = this.genAnalysisContext();\r\n                this.currentPhase = AnalysisPhase.Collection;\r\n                this.phaseStack = [];\r\n                this.contextMap = new Map();\r\n            }\r\n\r\n            init(): void {\r\n                this.reset();\r\n            }\r\n\r\n            reset(): void {\r\n                this.context = this.genAnalysisContext();\r\n                this.currentPhase = AnalysisPhase.Collection;\r\n                this.phaseStack = [];\r\n                this.contextMap.clear();\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\r\n\r\n            genAnalysisContext(): AnalysisContext {\r\n                return {\r\n                    currentModuleName   : '',\r\n                    currentModulePath   : '',\r\n                    currentPhase        : AnalysisPhase.Collection,\r\n                    contextSpanStack    : [],\r\n                    declarationStack    : [],\r\n                    expressionStack     : [],\r\n                    currentScope        : 0,\r\n                    processingSymbols   : new Set(),\r\n                    pendingReferences   : new Map(),\r\n                    resolvedSymbols     : new Set()\r\n                };\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────── STATE SAVE/RESTORE (NEW) ──────────────────┐\r\n\r\n            /**\r\n             * Save the current context state before entering a new scope/context.\r\n             * This captures all relevant state that needs to be restored later.\r\n             */\r\n            saveState(): SavedContextState {\r\n                const state: SavedContextState = {\r\n                    scopeId                 : this.context.currentScope,\r\n                    moduleName              : this.context.currentModuleName,\r\n                    modulePath              : this.context.currentModulePath,\r\n                    spanStackDepth          : this.context.contextSpanStack.length,\r\n                    declarationStackDepth   : this.context.declarationStack.length,\r\n                    expressionStackDepth    : this.context.expressionStack.length\r\n                };\r\n\r\n                this.debugManager?.log('verbose',\r\n                    `💾 Saved context state: scope=${state.scopeId}, ` +\r\n                    `module=${state.moduleName}, spans=${state.spanStackDepth}`\r\n                );\r\n\r\n                return state;\r\n            }\r\n\r\n            /**\r\n             * Restore with validation to catch state corruption\r\n             */\r\n            restoreState(state: SavedContextState): void {\r\n                this.debugManager?.log('verbose',\r\n                    `♻️  Restoring context state: scope=${state.scopeId}, module=${state.moduleName}`\r\n                );\r\n\r\n                // CRITICAL: Validate state before restoration\r\n                if (!this.validateSavedState(state)) {\r\n                    this.debugManager?.log('errors', `⚠️  Invalid saved state detected, attempting recovery`);\r\n                    // Don't throw - try to recover gracefully\r\n                }\r\n\r\n                // Restore scope\r\n                this.context.currentScope = state.scopeId;\r\n\r\n                // Restore module info\r\n                this.context.currentModuleName = state.moduleName;\r\n                this.context.currentModulePath = state.modulePath;\r\n\r\n                // Restore stack depths with overflow protection\r\n                this.restoreStack(this.context.contextSpanStack, state.spanStackDepth, 'contextSpan');\r\n                this.restoreStack(this.context.expressionStack, state.expressionStackDepth, 'expression');\r\n\r\n                // Declaration stack needs special handling for symbol cleanup\r\n                while (this.context.declarationStack.length > state.declarationStackDepth) {\r\n                    const decl = this.context.declarationStack.pop();\r\n                    if (decl) {\r\n                        this.context.processingSymbols.delete(decl.symbolId);\r\n                    }\r\n                }\r\n            }\r\n\r\n            private restoreStack<T>(stack: T[], targetDepth: number, name: string): void {\r\n                if (stack.length < targetDepth) {\r\n                    this.debugManager?.log('errors',\r\n                        `⚠️ Stack underflow for ${name}: current=${stack.length}, target=${targetDepth}. Clearing stack.`\r\n                    );\r\n                    stack.length = 0; // Clear corrupted stack\r\n                    return;\r\n                }\r\n                while (stack.length > targetDepth) {\r\n                    stack.pop();\r\n                }\r\n            }\r\n\r\n            private validateSavedState(state: SavedContextState): boolean {\r\n                if (state.scopeId < 0) return false;\r\n                if (state.spanStackDepth < 0) return false;\r\n                if (state.declarationStackDepth < 0) return false;\r\n                if (state.expressionStackDepth < 0) return false;\r\n                return true;\r\n            }\r\n\r\n            /**\r\n             * Execute a function with saved/restored context.\r\n             * This is a convenience wrapper that automatically handles state management.\r\n             *\r\n             * Usage:\r\n             * ```typescript\r\n             * contextTracker.withSavedState(() => {\r\n             *     // Do work that changes context\r\n             *     contextTracker.setScope(newScope);\r\n             *     processNode(node);\r\n             * });\r\n             * // Context is automatically restored here\r\n             * ```\r\n             */\r\n            withSavedState<T>(fn: () => T): T {\r\n                const savedState = this.saveState();\r\n                try {\r\n                    return fn();\r\n                } finally {\r\n                    this.restoreState(savedState);\r\n                }\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────── MODULE & PHASE ────────────────────────┐\r\n\r\n            setModuleName(moduleName: string): void {\r\n                this.context.currentModuleName = moduleName;\r\n                this.debugManager?.log('verbose', `Context: Set module name to '${moduleName}'`);\r\n            }\r\n\r\n            setModulePath(modulePath: string): void {\r\n                this.context.currentModulePath = modulePath;\r\n                this.debugManager?.log('verbose', `Context: Set module path to '${modulePath}'`);\r\n            }\r\n\r\n            pushPhase(phase: AnalysisPhase): void {\r\n                this.phaseStack.push(this.currentPhase);\r\n                this.setPhase(phase);\r\n                this.debugManager?.log('verbose', `Context: Pushed phase '${phase}' (stack: ${this.phaseStack.length})`);\r\n            }\r\n\r\n            popPhase(): AnalysisPhase | undefined {\r\n                const previousPhase = this.phaseStack.pop();\r\n                if (previousPhase) {\r\n                    this.setPhase(previousPhase);\r\n                    this.debugManager?.log('verbose', `Context: Popped phase, returned to '${previousPhase}'`);\r\n                }\r\n                return previousPhase;\r\n            }\r\n\r\n            setPhase(phase: AnalysisPhase): void {\r\n                this.currentPhase = phase;\r\n                this.context.currentPhase = phase;\r\n                this.debugManager?.log('verbose', `Context: Entered phase '${phase}'`);\r\n            }\r\n\r\n            getCurrentPhase(): AnalysisPhase | undefined {\r\n                return this.context.currentPhase;\r\n            }\r\n\r\n            setScope(scopeId: ScopeId): void {\r\n                this.context.currentScope = scopeId;\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────── CONTEXT SPAN MANAGEMENT ────────────────────┐\r\n\r\n            setCurrentContextSpan(span?: AST.Span): void {\r\n                if (span) {\r\n                    this.context.contextSpanStack.push(span);\r\n                    this.debugManager?.log('verbose', `Context: Pushed span [${span.start}-${span.end}] (stack depth: ${this.context.contextSpanStack.length})`);\r\n                } else {\r\n                    if (this.context.contextSpanStack.length > 0) {\r\n                        const removed = this.context.contextSpanStack.pop();\r\n                        this.debugManager?.log('verbose', `Context: Popped span [${removed?.start}-${removed?.end}] (stack depth: ${this.context.contextSpanStack.length})`);\r\n                    }\r\n                }\r\n            }\r\n\r\n            pushContextSpan(span: AST.Span): void {\r\n                this.context.contextSpanStack.push(span);\r\n                this.debugManager?.log('verbose', `Context: Pushed scoped span [${span.start}-${span.end}]`);\r\n            }\r\n\r\n            popContextSpan(): AST.Span | undefined {\r\n                const span = this.context.contextSpanStack.pop();\r\n                if (span) {\r\n                    this.debugManager?.log('verbose', `Context: Popped scoped span [${span.start}-${span.end}]`);\r\n                }\r\n                return span;\r\n            }\r\n\r\n            clearContextSpans(): void {\r\n                const count = this.context.contextSpanStack.length;\r\n                this.context.contextSpanStack = [];\r\n                this.debugManager?.log('verbose', `Context: Cleared ${count} context spans`);\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────── DECLARATION TRACKING ──────────────────────┐\r\n\r\n            startDeclaration(\r\n                symbolName: string,\r\n                symbolId: SymbolId,\r\n                symbolKind: SymbolKind | 'Use',\r\n                span: AST.Span,\r\n                parentScope: ScopeId\r\n            ): void {\r\n                const declaration: DeclarationContext = {\r\n                    symbolName,\r\n                    symbolId,\r\n                    symbolKind,\r\n                    phase: DeclarationPhase.InDeclaration,\r\n                    span,\r\n                    parentScope\r\n                };\r\n\r\n                this.context.declarationStack.push(declaration);\r\n                this.context.processingSymbols.add(symbolId);\r\n                this.pushContextSpan(span);\r\n\r\n                this.debugManager?.log('verbose', `Context: Started declaration of ${symbolKind} '${symbolName}' (id: ${symbolId})`);\r\n            }\r\n\r\n            startInitialization(symbolId: SymbolId): void {\r\n                const current = this.getCurrentDeclaration();\r\n                if (current && current.symbolId === symbolId) {\r\n                    current.phase = DeclarationPhase.InInitialization;\r\n                    this.debugManager?.log('verbose', `Context: Started initialization of symbol '${current.symbolName}' (id: ${symbolId})`);\r\n                }\r\n            }\r\n\r\n            completeDeclaration(symbolId: SymbolId): void {\r\n                const index = this.context.declarationStack.findIndex(d => d.symbolId === symbolId);\r\n                if (index >= 0) {\r\n                    const declaration = this.context.declarationStack[index];\r\n                    declaration.phase = DeclarationPhase.PostDeclaration;\r\n                    this.context.declarationStack.splice(index, 1);\r\n                    this.popContextSpan();\r\n                    this.debugManager?.log('verbose', `Context: Completed declaration of '${declaration.symbolName}' (id: ${symbolId})`);\r\n                }\r\n\r\n                this.context.processingSymbols.delete(symbolId);\r\n                this.context.resolvedSymbols.add(symbolId);\r\n            }\r\n\r\n            isInDeclaration(symbolName: string): boolean {\r\n                return this.context.declarationStack.some(d => d.symbolName === symbolName);\r\n            }\r\n\r\n            isInInitialization(symbolName: string): boolean {\r\n                return this.context.declarationStack.some(d =>\r\n                    d.symbolName === symbolName && d.phase === DeclarationPhase.InInitialization\r\n                );\r\n            }\r\n\r\n            getCurrentDeclaration(): DeclarationContext | undefined {\r\n                return this.context.declarationStack[this.context.declarationStack.length - 1];\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────────── EXPRESSION TRACKING ──────────────────────┐\r\n\r\n            enterExpression(type: ExpressionContext, span: AST.Span, relatedSymbol?: SymbolId): void {\r\n                if (!span) {\r\n                    this.debugManager?.log('verbose', 'Warning: Attempted to enter expression context without span');\r\n                    return;\r\n                }\r\n\r\n                const depth = this.context.expressionStack.length;\r\n                this.context.expressionStack.push({ type, relatedSymbol, depth, span });\r\n                this.pushContextSpan(span);\r\n                this.debugManager?.log('verbose', `Context: Entered expression ${type} at depth ${depth}`);\r\n            }\r\n\r\n            exitExpression(): ExpressionContextInfo | undefined {\r\n                if (this.context.expressionStack.length === 0) {\r\n                    return undefined;\r\n                }\r\n\r\n                const exited = this.context.expressionStack.pop();\r\n                this.popContextSpan();\r\n\r\n                if (exited) {\r\n                    this.debugManager?.log('verbose', `Context: Exited expression ${exited.type} from depth ${exited.depth}`);\r\n                }\r\n\r\n                return exited;\r\n            }\r\n\r\n            getCurrentExpressionContext(): ExpressionContextInfo | undefined {\r\n                return this.context.expressionStack[this.context.expressionStack.length - 1];\r\n            }\r\n\r\n            isInExpressionType(type: ExpressionContext): boolean {\r\n                return this.context.expressionStack.some(ctx => ctx.type === type);\r\n            }\r\n\r\n            getExpressionDepth(): number {\r\n                return this.context.expressionStack.length;\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌────────────────────── SELF-REFERENCE DETECTION ────────────────────┐\r\n\r\n            checkSelfReference(symbolName: string, referenceSpan: AST.Span): {\r\n                isSelfReference: boolean;\r\n                declarationContext?: DeclarationContext;\r\n                errorType?: 'VARIABLE_SELF_INIT' | 'PARAMETER_SELF_INIT';\r\n            } {\r\n                const currentDeclaration = this.context.declarationStack.find(d =>\r\n                    d.symbolName === symbolName && d.phase === DeclarationPhase.InInitialization\r\n                );\r\n\r\n                if (currentDeclaration) {\r\n                    const errorType = currentDeclaration.symbolKind === 'let' ?\r\n                        'VARIABLE_SELF_INIT' as const : 'PARAMETER_SELF_INIT' as const;\r\n\r\n                    return {\r\n                        isSelfReference: true,\r\n                        declarationContext: currentDeclaration,\r\n                        errorType\r\n                    };\r\n                }\r\n\r\n                return { isSelfReference: false };\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────── FORWARD REFERENCE TRACKING ───────────────────┐\r\n\r\n            recordPendingReference(symbolName: string, span: AST.Span): void {\r\n                if (!this.context.pendingReferences.has(symbolName)) {\r\n                    this.context.pendingReferences.set(symbolName, []);\r\n                }\r\n                this.context.pendingReferences.get(symbolName)!.push(span);\r\n            }\r\n\r\n            resolvePendingReferences(symbolName: string): AST.Span[] {\r\n                const spans = this.context.pendingReferences.get(symbolName) || [];\r\n                this.context.pendingReferences.delete(symbolName);\r\n                return spans;\r\n            }\r\n\r\n            getPendingReferences(): Map<string, AST.Span[]> {\r\n                return new Map(this.context.pendingReferences);\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────── PARAMETER ORDER VALIDATION ───────────────────┐\r\n\r\n            checkParameterForwardReference(\r\n                parameterName: string,\r\n                currentParameterIndex: number,\r\n                allParameters: { name: string; index: number }[]\r\n            ): {\r\n                isForwardReference: boolean;\r\n                referencedParameterIndex?: number;\r\n            } {\r\n                const referencedParam = allParameters.find(p => p.name === parameterName);\r\n\r\n                if (referencedParam && referencedParam.index > currentParameterIndex) {\r\n                    return {\r\n                        isForwardReference: true,\r\n                        referencedParameterIndex: referencedParam.index\r\n                    };\r\n                }\r\n\r\n                return { isForwardReference: false };\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────────── CONTEXT QUERIES ────────────────────────┐\r\n\r\n            getContextSpan(): AST.Span | undefined {\r\n                if (this.context.contextSpanStack.length > 0) {\r\n                    return this.context.contextSpanStack[this.context.contextSpanStack.length - 1];\r\n                }\r\n\r\n                const currentExpression = this.getCurrentExpressionContext();\r\n                if (currentExpression?.span) {\r\n                    return currentExpression.span;\r\n                }\r\n\r\n                const currentDeclaration = this.getCurrentDeclaration();\r\n                if (currentDeclaration?.span) {\r\n                    return currentDeclaration.span;\r\n                }\r\n\r\n                return undefined;\r\n            }\r\n\r\n            getContext(): Readonly<AnalysisContext> {\r\n                return this.context;\r\n            }\r\n\r\n            getPhase(): string {\r\n                return this.context.currentPhase;\r\n            }\r\n\r\n            getModuleName(): string {\r\n                return this.context.currentModuleName;\r\n            }\r\n\r\n            getModulePath(): string {\r\n                return this.context.currentModulePath;\r\n            }\r\n\r\n            getScope(): ScopeId {\r\n                return this.context.currentScope;\r\n            }\r\n\r\n            getProcessingSymbols(): Set<SymbolId> {\r\n                return new Set(this.context.processingSymbols);\r\n            }\r\n\r\n            getResolvedSymbols(): Set<SymbolId> {\r\n                return new Set(this.context.resolvedSymbols);\r\n            }\r\n\r\n            getDeclarationStack(): DeclarationContext[] {\r\n                return [...this.context.declarationStack];\r\n            }\r\n\r\n            getCurrentDeclarationContext(): DeclarationContext | undefined {\r\n                return this.context.declarationStack[this.context.declarationStack.length - 1];\r\n            }\r\n\r\n            getCurrentDeclarationSymbolId(): SymbolId | undefined {\r\n                const current = this.getCurrentDeclaration();\r\n                return current ? current.symbolId : undefined;\r\n            }\r\n\r\n            getCurrentDeclarationSymbolName(): string | undefined {\r\n                const current = this.getCurrentDeclaration();\r\n                return current ? current.symbolName : undefined;\r\n            }\r\n\r\n            getCurrentDeclarationSymbolKind(): SymbolKind | undefined {\r\n                const current = this.getCurrentDeclaration();\r\n                return current ? current.symbolKind : undefined;\r\n            }\r\n\r\n            getCurrentDeclarationPhase(): DeclarationPhase | undefined {\r\n                const current = this.getCurrentDeclaration();\r\n                return current ? current.phase : undefined;\r\n            }\r\n\r\n            getCurrentDeclarationSpan(): AST.Span | undefined {\r\n                const current = this.getCurrentDeclaration();\r\n                return current ? current.span : undefined;\r\n            }\r\n\r\n            getCurrentDeclarationParentScope(): ScopeId | undefined {\r\n                const current = this.getCurrentDeclaration();\r\n                return current ? current.parentScope : undefined;\r\n            }\r\n\r\n            getCurrentDeclarationStackDepth(): number {\r\n                return this.context.declarationStack.length;\r\n            }\r\n\r\n            getCurrentDeclarationStackTrace(): string[] {\r\n                return this.context.declarationStack.map(d =>\r\n                    `${d.symbolKind} '${d.symbolName}' (${d.phase})`\r\n                );\r\n            }\r\n\r\n            isProcessingSymbol(symbolId: SymbolId): boolean {\r\n                return this.context.processingSymbols.has(symbolId);\r\n            }\r\n\r\n            isSymbolResolved(symbolId: SymbolId): boolean {\r\n                return this.context.resolvedSymbols.has(symbolId);\r\n            }\r\n\r\n            getDeclarationStackTrace(): string[] {\r\n                return this.context.declarationStack.map(d =>\r\n                    `${d.symbolKind} '${d.symbolName}' (${d.phase})`\r\n                );\r\n            }\r\n\r\n            getExpressionStackTrace(): string[] {\r\n                return this.context.expressionStack.map(e =>\r\n                    `${e.type} at depth ${e.depth}`\r\n                );\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────────── DEBUG UTILITIES ────────────────────────┐\r\n\r\n            debugState(): void {\r\n                console.log('Enhanced Context Tracker State:', {\r\n                    module: this.context.currentModuleName,\r\n                    phase: this.context.currentPhase,\r\n                    scope: this.context.currentScope,\r\n                    contextSpanStack: this.context.contextSpanStack.map(s => `[${s.start}-${s.end}]`),\r\n                    declarationStack: this.getDeclarationStackTrace(),\r\n                    expressionStack: this.getExpressionStackTrace(),\r\n                    processingSymbols: Array.from(this.context.processingSymbols),\r\n                    pendingReferences: Array.from(this.context.pendingReferences.keys())\r\n                });\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// DebugManager.ts — Simplified debug management\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { ContextTracker } from './ContextTracker';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type DebugKind = 'off' | 'errors' | 'symbols' | 'scopes' | 'nodes' | 'verbose';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class DebugManager {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            private debugLevel          : DebugKind = 'off';\n            private indentLevel         = 0;\n            private contextTracker?     : ContextTracker;\n\n            constructor(contextTracker?: ContextTracker, debugLevel: DebugKind = 'off') {\n                this.debugLevel         = debugLevel;\n                this.contextTracker     = contextTracker;\n            }\n\n            reset(): void {\n                this.indentLevel = 0;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            log(level: DebugKind, message: string): void {\n                if (this.debugLevel === 'off') {return;}\n\n                const levels: DebugKind[] = ['off', 'errors', 'symbols', 'scopes', 'nodes', 'verbose'];\n                const currentIndex = levels.indexOf(this.debugLevel);\n                const messageIndex = levels.indexOf(level);\n\n                if (messageIndex <= currentIndex) {\n                    const prefix = this.getDebugPrefix(level);\n                    const indent = '  '.repeat(this.indentLevel);\n\n                    // Get caller function name\n                    let callerName = '';\n                    try {\n                        const err = new Error();\n                        if (err.stack) {\n                            const stackLines = err.stack.split('\\n');\n\n                            // Try to extract function name and method name\n                            if (stackLines.length > 2) {\n                                const match = stackLines[2].match(/at (?:.*\\.)?([a-zA-Z0-9_$]+)(?: \\[as .*\\])? /);\n                                if (match && match[1]) {\n                                    callerName = match[1];\n                                }\n                            }\n                        }\n                    } catch { /* empty */ }\n\n                    const callerInfo = callerName ? `${callerName}() : ` : '';\n                    // Get short file path and line number\n                    let short_file_path = 'unknown';\n                    let line = 0;\n                    let column = 0;\n                    try {\n                        const err = new Error();\n                        if (err.stack) {\n                            const stackLines = err.stack.split('\\n');\n\n                            // Try to extract file path, line number, and column number\n                            if (stackLines.length > 2) {\n                                const match = stackLines[2].match(/at .* \\((.*):(\\d+):(\\d+)\\)/) ||\n                                              stackLines[2].match(/at (.*):(\\d+):(\\d+)/);\n                                if (match && match[1] && match[2] && match[3]) {\n                                    const fullPath = match[1];\n                                    short_file_path = fullPath.split('/').slice(-2).join('/'); // last two segments\n                                    line = parseInt(match[2], 10);\n                                    column = parseInt(match[3], 10);\n                                }\n                            }\n                        }\n                    } catch { /* empty */ }\n\n                    if(short_file_path !== 'unknown') {\n                        // Extract root folder (e.g., src, lib) and reconstruct path\n                        const match = short_file_path.match(/(src|lib)[/\\\\].*/);\n                        if (match) {\n                            short_file_path = `./${match[0].replace(/\\\\/g, '/')}`;\n                        } else {\n                            // fallback to last two segments\n                            const parts = short_file_path.split(/[/\\\\]/);\n                            if(parts.length > 2) {\n                                short_file_path = `./${parts.slice(-2).join('/')}`;\n                            } else if(parts.length === 2) {\n                                short_file_path = `./${short_file_path.replace(/\\\\/g, '/')}`;\n                            }\n                        }\n                    }\n\n                    console.log(`${prefix} ${indent}${callerInfo}${message} at ${short_file_path}:${line}:${column}`);\n                }\n            }\n\n            increaseIndent(): void {\n                this.indentLevel++;\n            }\n\n            decreaseIndent(): void {\n                this.indentLevel = Math.max(0, this.indentLevel - 1);\n            }\n\n            setDebugLevel(level: DebugKind): void {\n                this.debugLevel = level;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            private getDebugPrefix(level: DebugKind): string {\n                const prefixes: Record<string, string> = {\n                    errors   : '🔥',\n                    symbols  : '', // 📝\n                    scopes   : '📦',\n                    nodes    : '🌳',\n                    verbose  : '', // 📊\n                };\n\n                const prefix = prefixes[level] === '' ? '' : `[${prefixes[level] || '⚡'}]`;\n\n                let phasePrefix = '';\n                if (this.contextTracker) {\n                    const phase = this.contextTracker.getCurrentPhase();\n                    if (phase) {\n                        phasePrefix = `[${phase}] `;\n                    }\n                }\n\n                return `${phasePrefix}${prefix}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ScopeManager.ts — Enhanced scope and symbol management\r\n//\r\n// Developed with ❤️ by Maysara.\r\n\r\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\r\n\r\n    import * as AST                             from '@je-es/ast';\r\n    import { IdGenerator }                      from \"./IdGenerator\";\r\n    import { DebugManager }                     from './DebugManager';\r\n    import { DiagnosticManager}                 from './DiagnosticManager';\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\r\n\r\n    export type ScopeId = number;\r\n    export type SymbolId = number;\r\n\r\n    export enum ScopeKind {\r\n        Global          = 'Global',\r\n        Module          = 'Module',\r\n        Function        = 'Function',\r\n        Loop            = 'Loop',\r\n        Block           = 'Block',\r\n        Expression      = 'Expression',\r\n        Type            = 'Type',\r\n    }\r\n\r\n    export enum SymbolKind {\r\n        Use             = 'Use',\r\n        Definition      = 'Definition',\r\n        Variable        = 'Variable',\r\n        Function        = 'Function',\r\n        Parameter       = 'Parameter',\r\n        StructField     = 'StructField',\r\n        EnumVariant     = 'EnumVariant',\r\n        Error           = 'Error'\r\n    }\r\n\r\n    export interface Scope {\r\n        id              : ScopeId;\r\n        kind            : ScopeKind;\r\n        name            : string;\r\n        parent          : ScopeId | null;\r\n        children        : ScopeId[];\r\n        symbols         : Map<string, Symbol>;\r\n        level           : number;\r\n        metadata       ?: Record<string, unknown>;\r\n    }\r\n\r\n    export interface Symbol {\r\n        id              : SymbolId;\r\n        name            : string;\r\n        kind            : SymbolKind;\r\n        type            : AST.TypeNode | null;\r\n        scope           : ScopeId;\r\n        contextSpan     : AST.Span;\r\n        targetSpan?     : AST.Span;\r\n\r\n        // State flags\r\n        declared        : boolean;\r\n        initialized     : boolean;\r\n        used            : boolean;\r\n        isTypeChecked   : boolean;\r\n\r\n        // Type information\r\n        typeInfo?       : {\r\n            baseTypes?      : SymbolId[];       // Base classes/interfaces\r\n            typeParams?     : Symbol[];         // Generic type parameters\r\n            constraints?    : AST.TypeNode[];   // Type parameter constraints\r\n            isGeneric?      : boolean;          // Whether this is a generic type/function\r\n        };\r\n\r\n        // Metadata\r\n        module?             : string;\r\n        namespace?          : string;\r\n        visibility          : AST.VisibilityInfo;\r\n        mutability          : AST.MutabilityInfo;\r\n        metadata?           : {\r\n            callable?       : boolean;      // For callable symbols\r\n            params?         : Symbol[];     // Function parameters\r\n            returnType?     : AST.TypeNode; // Function return type\r\n            isAsync?        : boolean;      // Async function\r\n            isStatic?       : boolean;      // Static member\r\n            isAbstract?     : boolean;      // Abstract member\r\n            isBuiltin?      : boolean;      // Built-in symbol\r\n            [key: string]   : unknown;      // Other metadata\r\n        };\r\n\r\n        // Import/Export metadata\r\n        importSource?   : string;       // Source module\r\n        importPath?     : string;       // Import path\r\n        importAlias?    : string;       // Import alias\r\n        sourceSymbol?   : SymbolId;     // Original symbol ID\r\n        isExported      : boolean;      // Is exported\r\n        exportAlias?    : string;       // Export alias\r\n    }\r\n\r\n\r\n    interface BuiltinSymbolOption {\r\n        type            : AST.TypeNode | null\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\r\n\r\n    export class ScopeManager {\r\n        private scopes!: Map<ScopeId, Scope>;\r\n        private currentScope!: ScopeId;\r\n        private globalScope!: Scope;\r\n        private symbolTable!: Map<SymbolId, Symbol>;\r\n        private namespaceLookup!: Map<string, Set<SymbolId>>;\r\n\r\n        readonly idGenerator: IdGenerator;\r\n        readonly symbolIdGenerator: IdGenerator;\r\n\r\n        constructor(\r\n            private readonly diagnosticManager: DiagnosticManager,\r\n            private readonly debugManager?: DebugManager\r\n        ) {\r\n            this.idGenerator = new IdGenerator();\r\n            this.symbolIdGenerator = new IdGenerator();\r\n            this.init();\r\n        }\r\n\r\n        init(): void {\r\n            this.scopes = new Map();\r\n            this.symbolTable = new Map();\r\n            this.namespaceLookup = new Map();\r\n\r\n            // Create global scope\r\n            this.globalScope = this.createScope(ScopeKind.Global, 'global', null);\r\n            this.currentScope = this.globalScope.id;\r\n\r\n            // Initialize built-in symbols\r\n            this.initializeBuiltins();\r\n        }\r\n\r\n        reset(): void {\r\n            // Store global scope ID before cleanup\r\n            const globalScopeId = this.globalScope.id;\r\n\r\n            // Clear all collections\r\n            this.scopes.clear();\r\n            this.symbolTable.clear();\r\n            this.namespaceLookup.clear();\r\n\r\n            // Re-add global scope\r\n            this.scopes.set(globalScopeId, this.globalScope);\r\n            this.currentScope = globalScopeId;\r\n\r\n            // Clear global scope symbols but keep the scope itself\r\n            this.globalScope.symbols.clear();\r\n            this.globalScope.children = [];\r\n\r\n            // Reinitialize built-ins\r\n            this.initializeBuiltins();\r\n        }\r\n\r\n        // Scope Management Methods\r\n\r\n        createScope(kind: ScopeKind, name: string, parentId: ScopeId | null): Scope {\r\n            const scope: Scope = {\r\n                id: this.idGenerator.next(),\r\n                kind,\r\n                name,\r\n                parent: parentId,\r\n                children: [],\r\n                symbols: new Map(),\r\n                level: parentId ? this.getScope(parentId).level + 1 : 0\r\n            };\r\n\r\n            this.scopes.set(scope.id, scope);\r\n\r\n            if (parentId) {\r\n                const parent = this.getScope(parentId);\r\n                parent.children.push(scope.id);\r\n            }\r\n\r\n            return scope;\r\n        }\r\n\r\n\r\n        /**\r\n         * Execute a function with proper scope cleanup guarantee.\r\n         * Uses try-finally to ensure scope is ALWAYS restored, even on errors.\r\n         */\r\n        withScope<T>(scopeId: ScopeId, fn: () => T): T {\r\n            const previousScope = this.currentScope;\r\n\r\n            if (!this.scopes.has(scopeId)) {\r\n                throw new Error(`Cannot switch to non-existent scope ${scopeId}`);\r\n            }\r\n\r\n            this.debugManager?.log('verbose',\r\n                `→ Entering scope ${scopeId} (${this.getScope(scopeId).name}) from ${previousScope}`\r\n            );\r\n\r\n            this.setCurrentScope(scopeId);\r\n\r\n            try {\r\n                return fn();\r\n            } finally {\r\n                this.debugManager?.log('verbose',\r\n                    `← Restoring scope ${previousScope} from ${scopeId}`\r\n                );\r\n                this.setCurrentScope(previousScope);\r\n            }\r\n        }\r\n\r\n        findScopeByName(name: string, kind?: ScopeKind): Scope | null {\r\n            for (const scope of this.scopes.values()) {\r\n                if (scope.name === name && (kind ? scope.kind === kind : true)) {\r\n                    return scope;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        getSymbolInCurrentScope(name: string): Symbol | null {\r\n            const currentScope = this.getScope(this.currentScope);\r\n            return currentScope.symbols.get(name) || null;\r\n        }\r\n\r\n        findChildScopeByName(name: string, kind?: ScopeKind): Scope | null {\r\n            const currentScope = this.getScope(this.currentScope);\r\n            for (const childId of currentScope.children) {\r\n                const childScope = this.getScope(childId);\r\n                if (childScope.name === name && (kind ? childScope.kind === kind : true)) {\r\n                    return childScope;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        findChildScopeByNameFromId(name: string, scopeId: ScopeId, kind?: ScopeKind): Scope | null {\r\n            const scope = this.getScope(scopeId);\r\n            for (const childId of scope.children) {\r\n                const childScope = this.getScope(childId);\r\n                if (childScope.name === name && (kind ? childScope.kind === kind : true)) {\r\n                    return childScope;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n\r\n        getScopeParent(scopeId: ScopeId): Scope | null {\r\n            const scope = this.getScope(scopeId);\r\n            return scope.parent !== null ? this.getScope(scope.parent) : null;\r\n        }\r\n\r\n        enterScopeById(scopeId: ScopeId): void {\r\n            this.currentScope = scopeId;\r\n        }\r\n\r\n        getCurrentScopeId(): ScopeId {\r\n            return this.currentScope;\r\n        }\r\n\r\n        setCurrentScope(scopeId: ScopeId): void {\r\n            if (!this.scopes.has(scopeId)) {\r\n                throw new Error(`Scope ${scopeId} does not exist`);\r\n            }\r\n            this.currentScope = scopeId;\r\n        }\r\n\r\n        enterScope(kind: ScopeKind, name: string): ScopeId {\r\n            const scope = this.createScope(kind, name, this.currentScope);\r\n            this.currentScope = scope.id;\r\n            return scope.id;\r\n        }\r\n\r\n        exitScope(): ScopeId | null {\r\n            const current = this.getScope(this.currentScope);\r\n            if (current.parent !== null) {\r\n                const parentId = current.parent;\r\n                this.currentScope = parentId;\r\n                return parentId;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        removeScope(scopeId: ScopeId): void {\r\n            this.scopes.delete(scopeId);\r\n        }\r\n\r\n        // Symbol Management Methods\r\n\r\n        defineSymbol(name: string, kind: SymbolKind, opts: {\r\n            type?: AST.TypeNode,\r\n            visibility?: AST.VisibilityInfo,\r\n            mutability?: AST.MutabilityInfo,\r\n            namespace?: string,\r\n            metadata?: Symbol['metadata'],\r\n            typeInfo?: Symbol['typeInfo'],\r\n            span?: AST.Span\r\n        }): SymbolId {\r\n            const symbol: Symbol = {\r\n                id: this.symbolIdGenerator.next(),\r\n                name,\r\n                kind,\r\n                type: opts.type || null,\r\n                scope: this.currentScope,\r\n                contextSpan: opts.span || { start: 0, end: 0 },\r\n                declared: true,\r\n                initialized: false,\r\n                used: false,\r\n                isTypeChecked: false,\r\n                visibility: opts.visibility || { kind: 'Private' },\r\n                mutability: opts.mutability || { kind: 'Immutable' },\r\n                namespace: opts.namespace,\r\n                metadata: opts.metadata,\r\n                typeInfo: opts.typeInfo,\r\n                isExported: false\r\n            };\r\n\r\n            const scope = this.getScope(this.currentScope);\r\n            scope.symbols.set(name, symbol);\r\n            this.symbolTable.set(symbol.id, symbol);\r\n\r\n            // Add to namespace lookup if in a namespace\r\n            if (opts.namespace) {\r\n                const nsSymbols = this.namespaceLookup.get(opts.namespace) || new Set();\r\n                nsSymbols.add(symbol.id);\r\n                this.namespaceLookup.set(opts.namespace, nsSymbols);\r\n            }\r\n\r\n            return symbol.id;\r\n        }\r\n\r\n        resolveSymbol(name: string, opts: {\r\n            currentScopeOnly?: boolean,\r\n            includeParents?: boolean,\r\n            namespace?: string\r\n        } = {}): Symbol | null {\r\n            // Check namespace first if specified\r\n            if (opts.namespace) {\r\n                const nsSymbols = this.namespaceLookup.get(opts.namespace);\r\n                if (nsSymbols) {\r\n                    for (const symbolId of nsSymbols) {\r\n                        const symbol = this.symbolTable.get(symbolId);\r\n                        if (symbol && symbol.name === name) {\r\n                            return symbol;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Regular scope-based lookup\r\n            let scope : Scope | null = this.getScope(this.currentScope);\r\n\r\n            do {\r\n                const symbol = scope.symbols.get(name);\r\n                if (symbol) {\r\n                    return symbol;\r\n                }\r\n\r\n                if (opts.currentScopeOnly) {\r\n                    break;\r\n                }\r\n\r\n                scope = scope.parent !== null ? this.getScope(scope.parent) : null;\r\n            } while (scope && (opts.includeParents ?? true));\r\n\r\n            return null;\r\n        }\r\n\r\n        private initializeBuiltins(): void {\r\n            // functions\r\n            this.createBuiltinSymbol('func', '@print', {\r\n                type: AST.TypeNode.asFunction({start: 0, end: 0}, [\r\n                        AST.TypeNode.asU8Array({start: 0, end: 0})\r\n                ], AST.TypeNode.asVoid({start: 0, end: 0}))\r\n            })\r\n\r\n            // types\r\n            this.createBuiltinSymbol('type', 'str', {\r\n                type: AST.TypeNode.asU8Array({start: 0, end: 0})\r\n            })\r\n            this.createBuiltinSymbol('type', 'char', {\r\n                type: AST.TypeNode.asUnsigned({start: 0, end: 0}, 'u8', 8),\r\n            })\r\n        }\r\n\r\n        private createBuiltinSymbol(kind: 'func' | 'type', name: string, options: BuiltinSymbolOption = { type: null}) : Symbol {\r\n            if(kind == 'func') {\r\n                const symbol: Symbol = {\r\n                    id: this.symbolIdGenerator.next(),\r\n                    kind: SymbolKind.Function,\r\n                    name: name,\r\n                    contextSpan: { start: 0, end: 0 },\r\n                    scope: this.globalScope.id,\r\n                    visibility: { kind: 'Public' },\r\n                    mutability: { kind: 'Immutable'},\r\n                    type: options.type,\r\n                    used: false,\r\n                    initialized: true,\r\n                    declared: true,\r\n                    isTypeChecked: true,\r\n                    isExported: false,\r\n                    metadata: {\r\n                        callable: true,\r\n                        isBuiltin: true\r\n                    }\r\n                };\r\n\r\n                this.globalScope.symbols.set(name, symbol);\r\n                this.symbolTable.set(symbol.id, symbol);\r\n\r\n                return symbol;\r\n            }\r\n\r\n            else if(kind == 'type') {\r\n                const symbol: Symbol = {\r\n                    id: this.symbolIdGenerator.next(),\r\n                    kind: SymbolKind.Definition,\r\n                    name: 'str',\r\n                    contextSpan: { start: 0, end: 0 },\r\n                    scope: this.globalScope.id,\r\n                    visibility: { kind: 'Public' },\r\n                    mutability: { kind: 'Immutable'},\r\n                    type: options.type,\r\n                    used: false,\r\n                    initialized: true,\r\n                    declared: true,\r\n                    isTypeChecked: true,\r\n                    isExported: false,\r\n                    metadata: {\r\n                        isBuiltin: true\r\n                    }\r\n                };\r\n\r\n                this.globalScope.symbols.set('str', symbol);\r\n                this.symbolTable.set(symbol.id, symbol);\r\n\r\n                return symbol;\r\n            }\r\n\r\n            throw new Error(\"Unreachable\");\r\n        }\r\n\r\n        // Utility Methods\r\n\r\n        getScope(id: ScopeId): Scope {\r\n            const scope = this.scopes.get(id);\r\n            if (!scope) {\r\n                throw new Error(`Scope ${id} not found`);\r\n            }\r\n            return scope;\r\n        }\r\n\r\n        getAllSymbols(): Symbol[] {\r\n            return Array.from(this.symbolTable.values());\r\n        }\r\n\r\n        getSymbol(id: SymbolId): Symbol {\r\n            const symbol = this.symbolTable.get(id);\r\n            if (!symbol) {\r\n                throw new Error(`Symbol ${id} not found`);\r\n            }\r\n            return symbol;\r\n        }\r\n\r\n        getCurrentScope(): Scope {\r\n            return this.getScope(this.currentScope);\r\n        }\r\n\r\n        getGlobalScope(): Scope {\r\n            return this.globalScope;\r\n        }\r\n\r\n        getAllScopes(): Scope[] {\r\n            return Array.from(this.scopes.values());\r\n        }\r\n\r\n        // Enhanced Symbol Operations\r\n\r\n        markSymbolUsed(symbolId: SymbolId): void {\r\n            const symbol = this.getSymbol(symbolId);\r\n            symbol.used = true;\r\n        }\r\n\r\n        markSymbolInitialized(symbolId: SymbolId): void {\r\n            const symbol = this.getSymbol(symbolId);\r\n            symbol.initialized = true;\r\n        }\r\n\r\n        markSymbolTypeChecked(symbolId: SymbolId): void {\r\n            const symbol = this.getSymbol(symbolId);\r\n            symbol.isTypeChecked = true;\r\n        }\r\n\r\n        setSymbolType(symbolId: SymbolId, type: AST.TypeNode): void {\r\n            const symbol = this.getSymbol(symbolId);\r\n            symbol.type = type;\r\n        }\r\n\r\n        // Namespace Operations\r\n\r\n        getNamespaceSymbols(namespace: string): Symbol[] {\r\n            const nsSymbols = this.namespaceLookup.get(namespace);\r\n            if (!nsSymbols) {\r\n                return [];\r\n            }\r\n\r\n            return Array.from(nsSymbols).map(id => this.getSymbol(id));\r\n        }\r\n\r\n        getAllSymbolsInScope(scopeId: ScopeId): Symbol[] {\r\n            const scope = this.getScope(scopeId);\r\n            return Array.from(scope.symbols.values());\r\n        }\r\n\r\n        getAllNamespaces(): string[] {\r\n            return Array.from(this.namespaceLookup.keys());\r\n        }\r\n\r\n        // More\r\n        addSymbolToScope(symbol: Symbol, scopeId: ScopeId): void {\r\n            const scope = this.getScope(scopeId);\r\n            scope.symbols.set(symbol.name, symbol);\r\n            this.symbolTable.set(symbol.id, symbol);\r\n        }\r\n\r\n        /**\r\n         * Look up a symbol in the current scope chain.\r\n         * Prioritizes symbols from the current module before checking imported symbols.\r\n         */\r\n        lookupSymbol(name: string): Symbol | null {\r\n            return this.lookupSymbolInScopeChain(name, this.currentScope);\r\n        }\r\n\r\n        /**\r\n         * Walk up scope chain with module boundary awareness.\r\n         * This prevents symbols from other modules from shadowing local definitions.\r\n         */\r\n        lookupSymbolInScopeChain(name: string, scopeId: ScopeId): Symbol | null {\r\n            let scope: Scope | null = this.getScope(scopeId);\r\n            let currentModuleScope: Scope | null = null;\r\n\r\n            // STEP 1: Find which module we're currently in\r\n            let checkScope: Scope | null = scope;\r\n            while (checkScope) {\r\n                if (checkScope.kind === ScopeKind.Module) {\r\n                    currentModuleScope = checkScope;\r\n                    break;\r\n                }\r\n                checkScope = checkScope.parent !== null ? this.getScope(checkScope.parent) : null;\r\n            }\r\n\r\n            // STEP 2: Search ONLY within the current module first\r\n            if (currentModuleScope) {\r\n                checkScope = scope;\r\n                while (checkScope && checkScope.id !== currentModuleScope.id) {\r\n                    const symbol = checkScope.symbols.get(name);\r\n                    if (symbol) {\r\n                        return symbol; // Found in current scope chain\r\n                    }\r\n                    checkScope = checkScope.parent !== null ? this.getScope(checkScope.parent) : null;\r\n                }\r\n\r\n                // Check the module scope itself\r\n                const moduleSymbol = currentModuleScope.symbols.get(name);\r\n                if (moduleSymbol) {\r\n                    return moduleSymbol; // Found in module scope\r\n                }\r\n\r\n                // STEP 3: Check child Type scopes (for struct/enum definitions)\r\n                for (const childId of currentModuleScope.children) {\r\n                    const childScope = this.getScope(childId);\r\n                    if (childScope.kind === ScopeKind.Type && childScope.name === name) {\r\n                        // This is a type definition - return its symbol from the module scope\r\n                        return currentModuleScope.symbols.get(name) || null;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // STEP 4: Only check global scope for imports and built-ins\r\n            const globalScope = this.scopes.get(1); // Global scope is always ID 1\r\n            if (globalScope) {\r\n                const globalSymbol = globalScope.symbols.get(name);\r\n                if (globalSymbol) {\r\n                    // Only return if it's a Use (import) or built-in\r\n                    if (globalSymbol.kind === SymbolKind.Use ||\r\n                        globalSymbol.metadata?.isBuiltin) {\r\n                        return globalSymbol;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return null; // Not found anywhere\r\n        }\r\n\r\n        /**\r\n         * Find which module scope a symbol belongs to.\r\n         */\r\n        private findModuleScopeForSymbol(symbol: Symbol): Scope | null {\r\n            let scope: Scope | null = this.getScope(symbol.scope);\r\n\r\n            while (scope) {\r\n                if (scope.kind === ScopeKind.Module) {\r\n                    return scope;\r\n                }\r\n                scope = scope.parent !== null ? this.getScope(scope.parent) : null;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        lookupSymbolInParentScopes(name: string, startingScopeId: ScopeId): Symbol | null {\r\n            let scope: Scope | null = this.getScope(startingScopeId);\r\n            while (scope) {\r\n                const symbol = scope.symbols.get(name);\r\n                if (symbol) {\r\n                    return symbol;\r\n                }\r\n                scope = scope.parent !== null ? this.getScope(scope.parent) : null;\r\n            }\r\n            return null;\r\n        }\r\n\r\n\r\n        /**\r\n         * Alternative: If spans are not reliable, search by analyzing symbol positions\r\n         */\r\n        private findScopeBySymbolPosition(position: AST.Span): Scope | null {\r\n            let bestMatch: { scope: Scope; distance: number } | null = null;\r\n\r\n            // Search all scopes for symbols near the position\r\n            for (const scope of this.scopes.values()) {\r\n                for (const symbol of scope.symbols.values()) {\r\n                    // Check if position is within or very close to this symbol\r\n                    const symbolSpan = symbol.targetSpan || symbol.contextSpan;\r\n\r\n                    if (position.start >= symbolSpan.start && position.end <= symbolSpan.end) {\r\n                        // Position is inside this symbol's span - this is the scope\r\n                        const distance = scope.level; // Prefer deeper scopes\r\n\r\n                        if (!bestMatch || distance > bestMatch.distance) {\r\n                            bestMatch = { scope, distance };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return bestMatch?.scope || null;\r\n        }\r\n// Complete ScopeManager LSP Lookup Methods\r\n// Add these methods to your ScopeManager class\r\n\r\n/**\r\n * Look up a symbol from LSP position information.\r\n * This finds the narrowest scope at the given span and searches for the symbol.\r\n * \r\n * @param word - The identifier to search for\r\n * @param position_span - The span where the hover/completion was requested\r\n * @param moduleName - Optional: The name of the module to restrict search to\r\n * @returns The symbol if found, null otherwise\r\n */\r\nlookupSymbolFromLSP(word: string, position_span: AST.Span, moduleName?: string): Symbol | null {\r\n    console.log(`[ScopeManager] LSP lookup for \"${word}\" at span ${JSON.stringify(position_span)}${moduleName ? ` in module \"${moduleName}\"` : ''}`);\r\n    \r\n    // STEP 1: If module name provided, find that specific module scope\r\n    let searchScope: Scope | null = null;\r\n    \r\n    if (moduleName) {\r\n        // Find the module scope by name\r\n        for (const scope of this.scopes.values()) {\r\n            if (scope.kind === ScopeKind.Module && scope.name === moduleName) {\r\n                searchScope = scope;\r\n                console.log(`[ScopeManager] Restricted search to module: ${moduleName} (id: ${scope.id})`);\r\n                break;\r\n            }\r\n        }\r\n        \r\n        if (!searchScope) {\r\n            console.warn(`[ScopeManager] Module \"${moduleName}\" not found`);\r\n            return null;\r\n        }\r\n        \r\n        // ✅ CRITICAL: Check if position is within an import statement first\r\n        const importSymbol = this.findImportAtPosition(position_span, searchScope);\r\n        if (importSymbol) {\r\n            console.log(`[ScopeManager] Position is within import statement`);\r\n            console.log(`[ScopeManager] Import symbol name: ${importSymbol.name}, alias: ${importSymbol.importAlias || 'none'}`);\r\n            console.log(`[ScopeManager] Looking for word: \"${word}\"`);\r\n            \r\n            // Hovering anywhere in \"use x as sdsdsds from ...\" should show what 'x' is from other module\r\n            // So always resolve the import to show the source symbol\r\n            console.log(`[ScopeManager] Resolving import to source symbol`);\r\n            return this.resolveSymbolThroughImports(importSymbol);\r\n        }\r\n        \r\n        // Within the module, find the narrowest scope at the position\r\n        const narrowestScope = this.findNarrowestScopeAtPosition(position_span, searchScope.id);\r\n        searchScope = narrowestScope || searchScope;\r\n    } else {\r\n        // No module specified - use original behavior\r\n        searchScope = this.findNarrowestScopeAtPosition(position_span);\r\n    }\r\n    \r\n    if (!searchScope) {\r\n        console.log(`[ScopeManager] No scope found at position`);\r\n        return null;\r\n    }\r\n    \r\n    console.log(`[ScopeManager] Found search scope: ${searchScope.name} (kind: ${searchScope.kind}, id: ${searchScope.id})`);\r\n    \r\n    // STEP 2: Search for the symbol starting from the search scope\r\n    const symbol = this.lookupSymbolInScopeChain(word, searchScope.id);\r\n    \r\n    if (!symbol) {\r\n        console.log(`[ScopeManager] Symbol \"${word}\" not found in scope chain`);\r\n        return null;\r\n    }\r\n    \r\n    console.log(`[ScopeManager] Found symbol: ${symbol.name} (kind: ${symbol.kind})`);\r\n    \r\n    // ✅ CRITICAL FIX: Check if cursor is on the import statement itself or on usage\r\n    if (symbol.kind === SymbolKind.Use) {\r\n        const isOnImportStatement = this.isPositionOnSymbolDefinition(position_span, symbol);\r\n        \r\n        if (isOnImportStatement) {\r\n            console.log(`[ScopeManager] Position is ON import statement, returning Use symbol`);\r\n            return symbol; // Show the import itself\r\n        } else {\r\n            console.log(`[ScopeManager] Position is on USAGE of imported symbol, resolving to source`);\r\n            return this.resolveSymbolThroughImports(symbol); // Show what it imports\r\n        }\r\n    }\r\n    \r\n    return symbol;\r\n}\r\n\r\n/**\r\n * Find if the position is within an import statement.\r\n * Returns the Use symbol if position is within any import's contextSpan.\r\n */\r\nprivate findImportAtPosition(position: AST.Span, scope: Scope): Symbol | null {\r\n    // Check all symbols in this scope for Use symbols\r\n    for (const symbol of scope.symbols.values()) {\r\n        if (symbol.kind === SymbolKind.Use) {\r\n            const contextSpan = symbol.contextSpan;\r\n            // Check if position is within this import statement\r\n            if (position.start >= contextSpan.start && position.start <= contextSpan.end) {\r\n                console.log(`[ScopeManager] Found position within import: ${symbol.name} (alias: ${symbol.importAlias || 'none'}, context: ${contextSpan.start}-${contextSpan.end})`);\r\n                return symbol;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Check if the word matches this import symbol (either the imported name or alias).\r\n * For \"use x as y\", matches both \"x\" (original) and \"y\" (alias).\r\n */\r\nprivate doesWordMatchImport(word: string, importSymbol: Symbol): boolean {\r\n    // The import symbol's name is what it's known as in the current scope (the alias if exists)\r\n    // But we also need to check the original imported name\r\n    \r\n    // If there's an alias, symbol.name is the alias\r\n    // The original name would need to be stored differently...\r\n    // For now, check if word matches the symbol name\r\n    if (importSymbol.name === word) {\r\n        return true;\r\n    }\r\n    \r\n    // Check if this import has an alias and word might be the original name\r\n    if (importSymbol.importAlias) {\r\n        // If symbol has an alias, the name IS the alias\r\n        // We need to extract original name from importSource or metadata\r\n        // This is tricky - let's check metadata\r\n        const originalName = importSymbol.metadata?.originalImportName as string | undefined;\r\n        if (originalName && originalName === word) {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\n/**\r\n * Check if the position is on the symbol's definition/declaration.\r\n * Returns true if hovering on where the symbol is defined, false if hovering on usage.\r\n */\r\nprivate isPositionOnSymbolDefinition(position: AST.Span, symbol: Symbol): boolean {\r\n    // For Use symbols, check BOTH targetSpan and contextSpan\r\n    // because the import statement spans across \"use x from ...\"\r\n    if (symbol.kind === SymbolKind.Use) {\r\n        const contextSpan = symbol.contextSpan;\r\n        const targetSpan = symbol.targetSpan;\r\n        \r\n        // Check if position is anywhere within the import statement (contextSpan)\r\n        const isInContext = position.start >= contextSpan.start && position.start <= contextSpan.end;\r\n        \r\n        console.log(`[ScopeManager] Checking Use symbol ${symbol.name}:`);\r\n        console.log(`  - position: ${position.start}-${position.end}`);\r\n        console.log(`  - contextSpan: ${contextSpan.start}-${contextSpan.end}`);\r\n        console.log(`  - targetSpan: ${targetSpan?.start}-${targetSpan?.end}`);\r\n        console.log(`  - isInContext: ${isInContext}`);\r\n        \r\n        return isInContext;\r\n    }\r\n    \r\n    // For other symbols, check target span only\r\n    const targetSpan = symbol.targetSpan || symbol.contextSpan;\r\n    const isOnTarget = position.start >= targetSpan.start && position.start <= targetSpan.end;\r\n    \r\n    console.log(`[ScopeManager] Checking if position ${position.start}-${position.end} is on definition of ${symbol.name} (target: ${targetSpan.start}-${targetSpan.end}): ${isOnTarget}`);\r\n    \r\n    return isOnTarget;\r\n}\r\n\r\n/**\r\n * Resolve a symbol through imports to get the actual underlying symbol.\r\n * If the symbol is a Use (import), this follows the chain to find the real definition.\r\n */\r\nprivate resolveSymbolThroughImports(symbol: Symbol): Symbol {\r\n    // If not an import, return as-is\r\n    if (symbol.kind !== SymbolKind.Use) {\r\n        return symbol;\r\n    }\r\n    \r\n    console.log(`[ScopeManager] Resolving import symbol: ${symbol.name} (alias: ${symbol.importAlias || 'none'})`);\r\n    \r\n    // Try to find the source symbol by ID\r\n    if (symbol.sourceSymbol) {\r\n        const sourceSymbol = this.symbolTable.get(symbol.sourceSymbol);\r\n        if (sourceSymbol) {\r\n            console.log(`[ScopeManager] Resolved via sourceSymbol ID to: ${sourceSymbol.name} (${sourceSymbol.kind}) in module ${sourceSymbol.module}`);\r\n            return sourceSymbol;\r\n        }\r\n    }\r\n    \r\n    // Fallback: Search by import information\r\n    if (symbol.importSource) {\r\n        console.log(`[ScopeManager] Searching in module \"${symbol.importSource}\"`);\r\n        \r\n        // The original imported name might be different from symbol.name if there's an alias\r\n        // If symbol has an alias, we need to find what the original name was\r\n        // For \"use x as y\", symbol.name is \"y\", but we need to search for \"x\" in the source module\r\n        \r\n        // Find the source module scope\r\n        for (const scope of this.scopes.values()) {\r\n            if (scope.kind === ScopeKind.Module && scope.name === symbol.importSource) {\r\n                console.log(`[ScopeManager] Found source module scope: ${scope.name}`);\r\n                \r\n                // If there's an alias, the original name should be stored somewhere\r\n                // Check metadata for original name\r\n                const originalName = symbol.metadata?.originalImportName as string | undefined;\r\n                const searchName = originalName || symbol.name;\r\n                \r\n                console.log(`[ScopeManager] Looking for symbol \"${searchName}\" in source module`);\r\n                \r\n                // Look for the symbol in that module\r\n                const sourceSymbol = scope.symbols.get(searchName);\r\n                if (sourceSymbol && sourceSymbol.kind !== SymbolKind.Use) {\r\n                    console.log(`[ScopeManager] Found source symbol: ${sourceSymbol.name} (${sourceSymbol.kind})`);\r\n                    return sourceSymbol;\r\n                }\r\n                \r\n                // If not found with that name, try all exported symbols\r\n                console.log(`[ScopeManager] Symbol not found directly, checking all exported symbols`);\r\n                for (const [name, sym] of scope.symbols.entries()) {\r\n                    if (sym.isExported && sym.kind !== SymbolKind.Use) {\r\n                        console.log(`[ScopeManager]   - Found exported: ${name} (${sym.kind})`);\r\n                        // For now, if there's an alias but we can't find the original, return first exported\r\n                        if (originalName === name || (!originalName && name === symbol.name)) {\r\n                            return sym;\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    // If we can't resolve, return the import symbol itself\r\n    console.log(`[ScopeManager] Could not resolve import, returning import symbol`);\r\n    return symbol;\r\n}\r\n\r\n/**\r\n * Find the narrowest (most specific) scope that contains the given position.\r\n * This walks the scope tree depth-first to find the deepest scope containing the position.\r\n * \r\n * @param position - The position to search for\r\n * @param rootScopeId - Optional: Start search from this scope instead of global\r\n */\r\nprivate findNarrowestScopeAtPosition(position: AST.Span, rootScopeId?: ScopeId): Scope | null {\r\n    let narrowestScope: Scope | null = null;\r\n    let maxDepth = -1;\r\n    \r\n    // Helper to check if a span contains a position\r\n    const spanContainsPosition = (scopeSpan: AST.Span | undefined, pos: AST.Span): boolean => {\r\n        if (!scopeSpan) return false;\r\n        \r\n        // Position is within scope if it's between scope's start and end\r\n        return pos.start >= scopeSpan.start && pos.end <= scopeSpan.end;\r\n    };\r\n    \r\n    // Helper to check if scope contains symbols near the position\r\n    const scopeContainsSymbolsNearPosition = (scope: Scope, pos: AST.Span): boolean => {\r\n        for (const symbol of scope.symbols.values()) {\r\n            const symbolSpan = symbol.targetSpan || symbol.contextSpan;\r\n            \r\n            // Check if symbol is close to or contains the position\r\n            if (Math.abs(symbolSpan.start - pos.start) < 1000 || // Within 1000 chars\r\n                spanContainsPosition(symbolSpan, pos)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    \r\n    // Recursive function to search scopes\r\n    const searchScope = (scopeId: ScopeId, depth: number) => {\r\n        const scope = this.getScope(scopeId);\r\n        \r\n        // Check if this scope contains the position\r\n        const scopeSpan = scope.metadata?.span as AST.Span | undefined;\r\n        \r\n        let containsPosition = false;\r\n        \r\n        if (scopeSpan) {\r\n            containsPosition = spanContainsPosition(scopeSpan, position);\r\n        } else if (scope.kind === ScopeKind.Module) {\r\n            // For module scopes, check if they have symbols near this position\r\n            containsPosition = scopeContainsSymbolsNearPosition(scope, position);\r\n        } else {\r\n            // For other scopes, check if any symbols contain the position\r\n            for (const symbol of scope.symbols.values()) {\r\n                if (spanContainsPosition(symbol.contextSpan, position) ||\r\n                    (symbol.targetSpan && spanContainsPosition(symbol.targetSpan, position))) {\r\n                    containsPosition = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (containsPosition && depth > maxDepth) {\r\n            narrowestScope = scope;\r\n            maxDepth = depth;\r\n        }\r\n        \r\n        // Search children regardless (they might be more specific)\r\n        for (const childId of scope.children) {\r\n            searchScope(childId, depth + 1);\r\n        }\r\n    };\r\n    \r\n    // Start search from specified scope or global scope\r\n    const startScopeId = rootScopeId ?? this.globalScope.id;\r\n    searchScope(startScopeId, 0);\r\n    \r\n    // If we found no scope, try to find by analyzing all symbols (within root scope)\r\n    if (!narrowestScope) {\r\n        console.log(`[ScopeManager] No scope found via tree search, searching by symbol proximity`);\r\n        narrowestScope = this.findScopeBySymbolProximity(position, rootScopeId);\r\n    }\r\n    \r\n    // Final fallback: return the root scope\r\n    if (!narrowestScope) {\r\n        console.log(`[ScopeManager] Using root scope as final fallback`);\r\n        narrowestScope = rootScopeId ? this.getScope(rootScopeId) : this.globalScope;\r\n    }\r\n    \r\n    return narrowestScope;\r\n}\r\n\r\n/**\r\n * Find scope by symbol proximity - looks for symbols closest to position.\r\n * This is used as a fallback when scope span information is not available.\r\n * \r\n * @param position - The position to search near\r\n * @param rootScopeId - Optional: Restrict search to this scope and its children\r\n */\r\nprivate findScopeBySymbolProximity(position: AST.Span, rootScopeId?: ScopeId): Scope | null {\r\n    let bestMatch: { scope: Scope; distance: number; symbol: Symbol } | null = null;\r\n    \r\n    console.log(`[ScopeManager] Searching by symbol proximity for position ${position.start}-${position.end}${rootScopeId ? ` within scope ${rootScopeId}` : ''}`);\r\n    \r\n    // Helper to check if scope is within the root scope tree\r\n    const isWithinRootScope = (scope: Scope): boolean => {\r\n        if (!rootScopeId) return true; // No restriction\r\n        \r\n        let current: Scope | null = scope;\r\n        while (current) {\r\n            if (current.id === rootScopeId) return true;\r\n            current = current.parent !== null ? this.getScope(current.parent) : null;\r\n        }\r\n        return false;\r\n    };\r\n    \r\n    // Search all module and function scopes\r\n    for (const scope of this.scopes.values()) {\r\n        // Skip global scope\r\n        if (scope.kind === ScopeKind.Global) continue;\r\n        \r\n        // If rootScopeId specified, only search within that scope tree\r\n        if (rootScopeId && !isWithinRootScope(scope)) {\r\n            continue;\r\n        }\r\n        \r\n        // Prioritize Module and Function scopes\r\n        if (scope.kind === ScopeKind.Module || scope.kind === ScopeKind.Function) {\r\n            for (const symbol of scope.symbols.values()) {\r\n                const symbolSpan = symbol.contextSpan;\r\n                \r\n                // If position is within this symbol's context span, this is likely the right scope\r\n                if (position.start >= symbolSpan.start && position.start <= symbolSpan.end) {\r\n                    console.log(`[ScopeManager] Found scope by direct containment: ${scope.name} (symbol: ${symbol.name})`);\r\n                    return scope;\r\n                }\r\n                \r\n                // Calculate distance from position to symbol\r\n                const distance = Math.abs(symbolSpan.start - position.start);\r\n                \r\n                // Track the closest symbol (likely in the same scope as our position)\r\n                if (!bestMatch || distance < bestMatch.distance) {\r\n                    bestMatch = { scope, distance, symbol };\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    if (bestMatch) {\r\n        console.log(`[ScopeManager] Found scope by proximity: ${bestMatch.scope.name} (closest symbol: ${bestMatch.symbol.name}, distance: ${bestMatch.distance})`);\r\n        return bestMatch.scope;\r\n    }\r\n    \r\n    return null;\r\n}\r\n\r\n/**\r\n * Public method to get symbol at a specific position (used by LSP).\r\n * This checks if the position directly points to a symbol definition.\r\n */\r\ngetSymbolAtPosition(position: AST.Span): Symbol | null {\r\n    // First, try to find if the position directly points to a symbol\r\n    for (const symbol of this.symbolTable.values()) {\r\n        const targetSpan = symbol.targetSpan || symbol.contextSpan;\r\n        \r\n        // Check if position is exactly on this symbol\r\n        if (position.start >= targetSpan.start && position.start <= targetSpan.end) {\r\n            console.log(`[ScopeManager] Found symbol directly at position: ${symbol.name}`);\r\n            return symbol;\r\n        }\r\n    }\r\n    \r\n    return null;\r\n}\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// IdGenerator.ts - Simple ID generation utility\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class IdGenerator {\n\n        private counter = 0;\n\n        next(): number {\n            return ++this.counter;\n        }\n\n        reset(): void {\n            this.counter = 0;\n        }\n\n        current(): number {\n            return this.counter;\n        }\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// SymbolCollector.ts – Complete symbol collection Phase\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as AST                 from '@je-es/ast';\n    import { AnalysisPhase }        from '../components/ContextTracker';\n    import { DiagCode, DiagKind }   from '../components/DiagnosticManager';\n    import { Scope, Symbol, SymbolKind, ScopeKind }\n                                    from '../components/ScopeManager';\n    import { PathUtils }            from '../utils/PathUtils';\n    import { PhaseBase }            from '../interfaces/PhaseBase';\n    import { AnalysisConfig }       from '../ast-analyzer';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    interface PathResolutionContext {\n        rootPath                    ?: string;\n        currentModulePath           ?: string;\n        pathMappings                : Map<string, string>;\n    }\n\n    interface CollectionStats {\n        modulesProcessed            : number;\n        symbolsCollected            : number;\n        importResolutionFailures    : number;\n        scopesCreated               : number;\n        startTime                   : number;\n        syntheticSymbolsInjected    : number;\n    }\n\n    // Structured type collection context\n    interface TypeCollectionContext {\n        visitedTypes                : Set<string>;\n        currentTypePath             : string[];\n        nestingDepth                : number;\n        maxNestingDepth             : number;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class SymbolCollector extends PhaseBase {\n\n        // ┌──────────────────────────────── INIT ────────────────────────────────┐\n\n            private pathContext     : PathResolutionContext     = { pathMappings: new Map() };\n            private stats           : CollectionStats           = this.initStats();\n            private typeContext     : TypeCollectionContext     = this.initTypeContext();\n            private typeRegistry    : Map<string, Symbol> = new Map();\n            private moduleExports   : Map<string, Set<string>> = new Map(); // moduleName -> exported symbol names\n\n            constructor( config : AnalysisConfig ) {\n                super(AnalysisPhase.Collection, config);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ────────────────────────────────┐\n\n            handle(): boolean {\n                try {\n                    this.log('verbose', 'Starting symbol collection phase...');\n                    this.stats.startTime = Date.now();\n\n                    if (!this.init()) { return false; }\n                    if (!this.buildPathMappings()) { return false; }\n                    if (!this.collectAllModules()) { return false; }\n\n                    this.logStatistics();\n                    return !this.config.services.diagnosticManager.hasErrors();\n\n                } catch (error) {\n                    this.log('errors', `Fatal error during symbol collection: ${error}`);\n                    this.reportError( DiagCode.INTERNAL_ERROR, `Fatal error during symbol collection: ${error}` );\n                    return false;\n                }\n            }\n\n            reset(): void {\n                this.pathContext    = { pathMappings: new Map() };\n                this.stats          = this.initStats();\n                this.typeContext    = this.initTypeContext();\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌────────────────────────── [1] Program Level ─────────────────────────┐\n\n            private buildPathMappings(): boolean {\n                this.log('verbose', 'Building module path mappings...');\n                this.pathContext.pathMappings.clear();\n\n                const rootPath = this.config.program!.metadata?.path as string | undefined;\n                if (!rootPath) {\n                    this.reportWarning( DiagCode.MODULE_NOT_FOUND, 'No root path found in program metadata' );\n                    return false; // stop immediately\n                }\n\n                this.pathContext.rootPath = rootPath;\n\n                for (const [moduleName, module] of this.config.program!.modules) {\n                    const modulePath = module.metadata?.path as string | undefined;\n                    if (!modulePath) {\n                        this.reportWarning( DiagCode.MODULE_NOT_FOUND, `No file path found for module ${moduleName}` );\n                        continue;\n                    }\n\n                    try {\n                        const relativePath = PathUtils.getRelativePath(rootPath, modulePath);\n                        const normalizedPath = PathUtils.normalizePath(relativePath);\n\n                        // Detect path collisions\n                        if (this.pathContext.pathMappings.has(normalizedPath)) {\n                            const existing = this.pathContext.pathMappings.get(normalizedPath)!;\n                            if (existing !== moduleName) {\n                                this.reportError(\n                                    DiagCode.MODULE_NOT_FOUND,\n                                    `Path collision: '${normalizedPath}' maps to both '${existing}' and '${moduleName}'`\n                                );\n                                return false; // Stop immediately - invalid program\n                            }\n                        }\n\n                        this.pathContext.pathMappings.set(modulePath, moduleName);\n                        this.pathContext.pathMappings.set(relativePath, moduleName);\n                        this.pathContext.pathMappings.set(normalizedPath, moduleName);\n                        this.log('verbose', `Mapped ${moduleName} -> ${relativePath}`);\n                    } catch (error) {\n                        this.reportWarning( DiagCode.MODULE_NOT_FOUND, `Failed to map module path for ${moduleName}: ${error}` );\n                    }\n                }\n\n                return true;\n            }\n\n            private collectAllModules(): boolean {\n                this.log('verbose', 'Collecting symbols from all modules...');\n                const globalScope = this.config.services.scopeManager.getCurrentScope();\n\n                for (const [moduleName, module] of this.config.program!.modules) {\n                    this.config.services.contextTracker.pushContextSpan({ start: 0, end: 0 });\n                    try {\n                        if (!this.collectModule(moduleName, module, globalScope)) {\n                            if (this.config.services.contextTracker.getCurrentPhase() === AnalysisPhase.Collection) {\n                                this.log('errors', `Failed to collect from module ${moduleName}, continuing...`);\n                            }\n                        }\n                        this.stats.modulesProcessed++;\n                    } finally {\n                        this.config.services.contextTracker.popContextSpan();\n                    }\n                }\n\n                return true;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌────────────────────────── [2] Module Level ──────────────────────────┐\n\n            private collectModule(moduleName: string, module: AST.Module, parentScope: Scope): boolean {\n                this.log('symbols', `Collecting from module '${moduleName}'`);\n\n                // Reset type context for each module\n                this.typeContext = this.initTypeContext();\n\n                try {\n                    this.config.services.contextTracker.setModuleName(moduleName);\n                    const modulePath = module.metadata?.path as string;\n                    if (modulePath) {\n                        this.config.services.contextTracker.setModulePath(modulePath);\n                        this.pathContext.currentModulePath = modulePath;\n                    }\n\n                    const moduleScope = this.createModuleScope(moduleName, parentScope);\n\n                    // ✅ PASS 1: Collect all local definitions FIRST\n                    for (const statement of module.statements) {\n                        if (statement.kind === 'Def' || statement.kind === 'Let' || statement.kind === 'Func') {\n                            this.collectStmt(statement, moduleScope, moduleName);\n                        }\n                    }\n\n                    // ✅ PASS 2: Then process imports\n                    for (const statement of module.statements) {\n                        if (statement.kind === 'Use') {\n                            this.collectStmt(statement, moduleScope, moduleName);\n                        }\n                    }\n\n                    // ✅ PASS 3: Process everything else\n                    for (const statement of module.statements) {\n                        if (statement.kind !== 'Def' && statement.kind !== 'Let' &&\n                            statement.kind !== 'Func' && statement.kind !== 'Use') {\n                            this.collectStmt(statement, moduleScope, moduleName);\n                        }\n                    }\n\n                    return true;\n\n                } catch (error) {\n                    this.reportError( DiagCode.MODULE_NOT_FOUND, `Failed to collect symbols from module '${moduleName}': ${error}` );\n                    return false;\n                }\n            }\n\n            private createModuleScope(moduleName: string, parentScope: Scope): Scope {\n                const moduleScope = this.config.services.scopeManager.createScope(ScopeKind.Module, moduleName, parentScope.id);\n                this.incrementScopesCreated();\n                this.log('scopes', `Created module scope ${moduleScope.id} for '${moduleName}'`);\n                return moduleScope;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [3] Stmt Level ───────────────────────────┐\n\n            private collectStmt(stmt: AST.StmtNode, currentScope: Scope, moduleName: string): void {\n                if (!stmt) {\n                    this.reportError(DiagCode.ANALYSIS_ERROR, 'Found null statement during collection');\n                    return;\n                }\n\n                this.log('verbose', `Collecting from ${stmt.kind} statement`);\n                this.config.services.contextTracker.pushContextSpan(stmt.span);\n\n                try {\n                    // Nest withScope and withSavedState for complete safety\n                    this.config.services.scopeManager.withScope(currentScope.id, () => {\n                        this.config.services.contextTracker.withSavedState(() => {\n                            this.config.services.contextTracker.setScope(currentScope.id);\n                            this.processStmt(stmt, currentScope, moduleName);\n                        });\n                    });\n                } catch (error) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Failed to process ${stmt.kind} statement: ${error}`,\n                        stmt.span\n                    );\n                } finally {\n                    this.config.services.contextTracker.popContextSpan();\n                }\n            }\n\n            private processStmt(stmt: AST.StmtNode, currentScope: Scope, moduleName: string): void {\n                // Validate node before processing\n                const nodeGetter = this.getNodeGetter(stmt);\n                if (!nodeGetter) {\n                    this.reportError(DiagCode.INTERNAL_ERROR, `Invalid AST: ${stmt.kind} node is null`);\n                    return;\n                }\n\n                switch (stmt.kind) {\n                    case 'Block':\n                        this.handleBlockStatement(stmt.getBlock()!, currentScope, moduleName);\n                        break;\n                    case 'Test':\n                        this.handleTestStmt(stmt.getTest()!, currentScope, moduleName);\n                        break;\n                    case 'Use':\n                        this.handleUseStatement(stmt.getUse()!, currentScope, moduleName);\n                        break;\n                    case 'Def':\n                        this.handleDefStatement(stmt.getDef()!, currentScope, moduleName);\n                        break;\n                    case 'Let':\n                        this.handleLetStatement(stmt.getLet()!, currentScope, moduleName);\n                        break;\n                    case 'Func':\n                        this.handleFuncStatement(stmt.getFunc()!, currentScope, moduleName);\n                        break;\n                    case 'While':\n                    case 'Do':\n                    case 'For':\n                        this.handleLoopStmt(stmt, currentScope, moduleName);\n                        break;\n                    case 'Return':\n                    case 'Defer':\n                    case 'Throw':\n                        this.handleControlflowStmt(stmt, currentScope, moduleName);\n                        break;\n                    case 'Expression':\n                        this.collectExpr(stmt.getExpr()!, currentScope, moduleName);\n                        break;\n                }\n            }\n\n            private getNodeGetter(stmt: AST.StmtNode): (() => any) | null {\n                switch (stmt.kind) {\n                    case 'Def'          : return () => stmt.getDef();\n                    case 'Use'          : return () => stmt.getUse();\n                    case 'Let'          : return () => stmt.getLet();\n                    case 'Func'         : return () => stmt.getFunc();\n                    case 'Block'        : return () => stmt.getBlock();\n                    case 'Return'       : return () => stmt.getReturn();\n                    case 'Defer'        : return () => stmt.getDefer();\n                    case 'Throw'        : return () => stmt.getThrow();\n                    case 'Expression'   : return () => stmt.getExpr();\n                    case 'While'        :\n                    case 'Do'           :\n                    case 'For'          : return () => stmt.getLoop();\n                    case 'Break'        : return () => stmt.getBreak();\n                    case 'Continue'     : return () => stmt.getContinue();\n                    case 'Test'         : return () => stmt.getTest();\n                    default             : return null;\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────── [3.1] BLOCK ─────────────────────────────┐\n\n            private handleBlockStatement(blockNode: AST.BlockStmtNode, scope: Scope, moduleName: string): void {\n                this.collectBlockStmt(blockNode, scope, moduleName);\n            }\n\n            private createBlockScope(parentScope: Scope): Scope {\n                const blockScope = this.config.services.scopeManager.createScope(ScopeKind.Block, 'block', parentScope.id);\n                this.incrementScopesCreated();\n                this.log('scopes', `Created block scope ${blockScope.id} under parent ${parentScope.id}`);\n                return blockScope;\n            }\n\n            private collectBlockStmt(blockNode: AST.BlockStmtNode, parentScope: Scope, moduleName: string): void {\n                const blockScope = this.createBlockScope(parentScope);\n\n                this.config.services.scopeManager.withScope(blockScope.id, () => {\n                    this.config.services.contextTracker.withSavedState(() => {\n                        this.config.services.contextTracker.setScope(blockScope.id);\n\n                        for (const stmt of blockNode.stmts) {\n                            this.collectStmt(stmt, blockScope, moduleName);\n                        }\n                    });\n                });\n            }\n\n            private handleTestStmt(testNode: AST.TestStmtNode, scope: Scope, moduleName: string): void {\n                this.collectBlockStmt(testNode.block, scope, moduleName);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.2] USE ──────────────────────────────┐\n\n            private handleUseStatement(useNode: AST.UseStmtNode, scope: Scope, moduleName: string): void {\n                this.collectUseStmt(useNode, scope, moduleName);\n            }\n\n            private createUseSymbol(\n                useNode: AST.UseStmtNode,\n                currentScope: Scope,\n                moduleName: string,\n                targetModuleName?: string,\n            ): Symbol {\n                const symbolName = this.extractImportSymbolName(useNode);\n\n                // ✅ Handle wildcard vs specific import spans\n                const targetSpan = useNode.alias\n                    ? useNode.alias.span\n                    : useNode.targetArr\n                        ? useNode.targetArr[useNode.targetArr.length - 1].span\n                        : useNode.span; // Fallback for wildcard without proper span\n\n                const symbol = this.createBaseSymbol(\n                    symbolName,\n                    SymbolKind.Use,\n                    currentScope,\n                    moduleName,\n                    useNode.span,\n                    targetSpan\n                );\n\n                const isModuleScope = currentScope.kind === ScopeKind.Module;\n                const isPublic = useNode.visibility.kind === 'Public';\n\n                // ✅ Handle wildcard import metadata\n                const metadata: any = {};\n\n                if (!useNode.targetArr) {\n                    // Wildcard import\n                    metadata.isWildcardImport = true;\n                    metadata.exportedSymbols = targetModuleName\n                        ? Array.from(this.getModuleExports(targetModuleName) || [])\n                        : [];\n                } else if (useNode.targetArr.length > 1) {\n                    // Multi-part member path\n                    metadata.memberPath = useNode.targetArr.map(t => t.name);\n                    metadata.needsFullResolution = true;\n                }\n\n                return {\n                    ...symbol,\n                    initialized     : true,\n                    visibility      : useNode.visibility,\n                    isExported      : isModuleScope && isPublic,\n                    importSource    : targetModuleName,\n                    importPath      : targetModuleName ? useNode.path : undefined,\n                    importAlias     : targetModuleName ? useNode.alias?.name : undefined,\n                    metadata        : Object.keys(metadata).length > 0 ? metadata : undefined,\n                    declared        : false, // ⚠️ Not declared until resolution validates it\n                };\n            }\n\n            private collectUseStmt(useNode: AST.UseStmtNode, currentScope: Scope, moduleName: string): void {\n                this.log('symbols', 'Collecting use statement');\n\n                try {\n                    if (useNode.path) {\n                        this.processModuleImport(useNode, currentScope, moduleName);\n                    } else {\n                        this.processLocalUse(useNode, currentScope, moduleName);\n                    }\n                } catch (error) {\n                    this.reportError( DiagCode.ANALYSIS_ERROR, `Failed to process use statement: ${error}`, useNode.span );\n                }\n            }\n\n            private extractImportSymbolName(useNode: AST.UseStmtNode, allow_alias = true): string {\n                if (allow_alias && useNode.alias) {\n                    return useNode.alias.name;\n                }\n\n                // ✅ Handle wildcard import\n                if (!useNode.targetArr) {\n                    // Must have alias for wildcard\n                    if (!useNode.alias) {\n                        this.reportError(\n                            DiagCode.ANALYSIS_ERROR,\n                            `Wildcard import requires an alias (use * as <name> from \"...\")`,\n                            useNode.span\n                        );\n                        return '<invalid>';\n                    }\n                    return useNode.alias.name;\n                }\n\n                const isJustIdent = useNode.targetArr.length === 1;\n\n                if(isJustIdent) {\n                    return useNode.targetArr[0].name;\n                } else {\n                    return useNode.targetArr[useNode.targetArr.length - 1].name;\n                }\n            }\n\n            private processModuleImport(useNode: AST.UseStmtNode, currentScope: Scope, moduleName: string): void {\n                if (!this.config.program! || !useNode.path) {\n                    this.reportError(DiagCode.MODULE_NOT_FOUND, 'Invalid import: missing path', useNode.span);\n                    return;\n                }\n\n                const currentModule = this.config.program!.modules.get(moduleName);\n                const currentModulePath = currentModule?.metadata?.path as string | undefined;\n\n                if (!PathUtils.validatePath(this.config.program!, useNode.path, currentModulePath)) {\n                    this.reportError(DiagCode.MODULE_NOT_FOUND, `Module not found in path '${useNode.path}'`, useNode.pathSpan);\n                    this.stats.importResolutionFailures++;\n                    return;\n                }\n\n                const resolvedPath = PathUtils.resolveModulePath(this.config.program!, useNode.path, currentModulePath);\n                const targetModuleName = PathUtils.findModuleNameByPath(this.config.program!, resolvedPath);\n\n                if (!targetModuleName) {\n                    this.reportError(DiagCode.MODULE_NOT_FOUND, `Could not resolve module name for path: ${useNode.path}`, useNode.span);\n                    this.stats.importResolutionFailures++;\n                    return;\n                }\n\n                const targetModule = this.config.program!.modules.get(targetModuleName);\n                if (!targetModule) {\n                    this.reportError(DiagCode.MODULE_NOT_FOUND, `Target module '${targetModuleName}' not found`, useNode.span);\n                    this.stats.importResolutionFailures++;\n                    return;\n                }\n\n                // ✅ Handle wildcard import\n                if (!useNode.targetArr) {\n                    this.processWildcardImport(useNode, targetModule, targetModuleName, currentScope, moduleName);\n                    return;\n                }\n\n                // Existing validation for specific imports\n                if (!this.validateMemberPathInModule(targetModule, useNode.targetArr, useNode)) {\n                    this.reportError(DiagCode.SYMBOL_NOT_FOUND, `Symbol '${useNode.targetArr[0].name}' not found in module '${targetModuleName}'`, useNode.targetArr[0].span);\n                    this.stats.importResolutionFailures++;\n                    return;\n                }\n\n                const symbolName = this.extractImportSymbolName(useNode);\n\n                // Check for duplicate imports\n                const existingImport = currentScope.symbols.get(symbolName);\n                if (existingImport && existingImport.kind === SymbolKind.Use && existingImport.importSource === targetModuleName) {\n                    this.reportWarning(\n                        DiagCode.DUPLICATE_SYMBOL,\n                        `Symbol '${symbolName}' already imported from module '${targetModuleName}'`,\n                        useNode.alias?.span ?? useNode.targetArr[useNode.targetArr.length - 1].span\n                    );\n                }\n\n                if(this.checkForShadowing(symbolName, currentScope, SymbolKind.Use, useNode.alias?.span ?? useNode.targetArr[useNode.targetArr.length - 1].span)) {\n                    return;\n                }\n\n                const rootSymbolName = useNode.targetArr[0].name;\n                if (!this.canImportSymbol(targetModuleName, rootSymbolName)) {\n                    this.reportError(\n                        DiagCode.SYMBOL_NOT_EXPORTED,\n                        `Symbol '${rootSymbolName}' is private in module '${targetModuleName}'`,\n                        useNode.targetArr[0].span\n                    );\n                    this.stats.importResolutionFailures++;\n                    return;\n                }\n\n                const useSymbol = this.createUseSymbol(useNode, currentScope, moduleName, targetModuleName);\n                this.config.services.scopeManager.addSymbolToScope(useSymbol, currentScope.id);\n                this.incrementSymbolsCollected();\n\n                this.log('verbose', `Resolved import ${useNode.path} -> ${targetModuleName}.${useNode.targetArr.map(t => t.name).join('.')}`);\n            }\n\n            private processWildcardImport(\n                useNode: AST.UseStmtNode,\n                targetModule: AST.Module,\n                targetModuleName: string,\n                currentScope: Scope,\n                moduleName: string\n            ): void {\n                if (!useNode.alias) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Wildcard import requires an alias (use * as <name> from \"...\")`,\n                        useNode.span\n                    );\n                    return;\n                }\n\n                const aliasName = useNode.alias.name;\n\n                // Check for shadowing\n                if(this.checkForShadowing(aliasName, currentScope, SymbolKind.Use, useNode.alias.span)) {\n                    return;\n                }\n\n                // Get all exported symbols from target module\n                const exports = this.getModuleExports(targetModuleName);\n                if (!exports || exports.size === 0) {\n                    this.reportWarning(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Module '${targetModuleName}' has no exported symbols`,\n                        useNode.span\n                    );\n                }\n\n                // Create a special symbol for the wildcard import\n                const symbol = this.createBaseSymbol(\n                    aliasName,\n                    SymbolKind.Use,\n                    currentScope,\n                    moduleName,\n                    useNode.span,\n                    useNode.alias.span\n                );\n\n                const isModuleScope = currentScope.kind === ScopeKind.Module;\n                const isPublic = useNode.visibility.kind === 'Public';\n\n                const wildcardSymbol: Symbol = {\n                    ...symbol,\n                    initialized     : true,\n                    visibility      : useNode.visibility,\n                    isExported      : isModuleScope && isPublic,\n                    importSource    : targetModuleName,\n                    importPath      : useNode.path,\n                    importAlias     : aliasName,\n                    metadata        : {\n                        isWildcardImport: true,\n                        exportedSymbols: exports ? Array.from(exports) : []\n                    },\n                    declared        : false, // Will be resolved later\n                };\n\n                this.config.services.scopeManager.addSymbolToScope(wildcardSymbol, currentScope.id);\n                this.incrementSymbolsCollected();\n\n                this.log('verbose', `Collected wildcard import from '${targetModuleName}' as '${aliasName}'`);\n            }\n\n            private processLocalUse(useNode: AST.UseStmtNode, currentScope: Scope, moduleName: string): void {\n                // ✅ Wildcard not supported for local use\n                if (!useNode.targetArr) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Wildcard import not supported for local use. Use 'use * as x from \"path\"' for module imports`,\n                        useNode.span\n                    );\n                    return;\n                }\n\n                const symbolName = this.extractImportSymbolName(useNode);\n\n                if(this.checkForShadowing(symbolName, currentScope, SymbolKind.Use, useNode.alias?.span ?? useNode.targetArr[0].span)) {\n                    return;\n                }\n\n                const useSymbol = this.createUseSymbol(useNode, currentScope, moduleName);\n                this.config.services.scopeManager.addSymbolToScope(useSymbol, currentScope.id);\n                this.incrementSymbolsCollected();\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.3] DEF ──────────────────────────────┐\n\n            private handleDefStatement(defNode: AST.DefStmtNode, scope: Scope, moduleName: string): void {\n                this.collectDefStmt(defNode, scope, moduleName);\n            }\n\n            private createDefSymbol(defNode: AST.DefStmtNode, scope: Scope, moduleName: string): Symbol {\n                const symbol = this.createBaseSymbol(\n                    defNode.ident.name,\n                    SymbolKind.Definition,\n                    scope,\n                    moduleName,\n                    defNode.span,\n                    defNode.ident.span\n                );\n\n                const isModuleScope = scope.kind === ScopeKind.Module;\n                const isPublic = defNode.visibility.kind === 'Public';\n\n                return {\n                    ...symbol,\n                    type: defNode.type ?? null,\n                    initialized: true,\n                    visibility: defNode.visibility,\n                    isExported: isModuleScope && isPublic  // ✅ Set export flag\n                };\n            }\n\n            private collectDefStmt(defNode: AST.DefStmtNode, scope: Scope, moduleName: string): void {\n                this.log('symbols', `Collecting definition '${defNode.ident.name}'`);\n\n                if(this.checkForShadowing(defNode.ident.name, scope, SymbolKind.Definition, defNode.ident.span)) {\n                    return;\n                }\n\n\n                const symbol = this.createDefSymbol(defNode, scope, moduleName);\n                this.config.services.scopeManager.addSymbolToScope(symbol, scope.id);\n                this.incrementSymbolsCollected();\n\n                this.trackModuleExport(moduleName, defNode.ident.name, symbol.isExported);\n\n                // Register type name for resolution\n                this.typeRegistry.set(defNode.ident.name, symbol);\n\n                this.collectType(defNode.type, scope, moduleName, defNode.ident.name);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.4] LET ──────────────────────────────┐\n\n            private handleLetStatement(letNode: AST.LetStmtNode, scope: Scope, moduleName: string): void {\n                this.collectLetStmt(letNode, scope, moduleName);\n            }\n\n            private createLetSymbol(varNode: AST.LetStmtNode, scope: Scope, moduleName: string): Symbol {\n                const symbol = this.createBaseSymbol(\n                    varNode.field.ident.name,\n                    SymbolKind.Variable,\n                    scope,\n                    moduleName,\n                    varNode.field.span,\n                    varNode.field.ident.span\n                );\n\n                const isModuleScope = scope.kind === ScopeKind.Module;\n                const isPublic = varNode.field.visibility.kind === 'Public'\n\n                return {\n                    ...symbol,\n                    type            : varNode.field.type ?? null,\n                    initialized     : !!varNode.field.initializer,\n                    visibility      : varNode.field.visibility,\n                    mutability      : varNode.field.mutability,\n                    isExported      : isModuleScope && isPublic,\n                    metadata: {\n                        initializer: varNode.field.initializer  // ✅ ADD THIS\n                    }\n                };\n            }\n\n            private collectLetStmt(letNode: AST.LetStmtNode, scope: Scope, moduleName: string): void {\n                this.log('symbols', `Collecting let '${letNode.field.ident.name}'`);\n\n                if(this.checkForShadowing(letNode.field.ident.name, scope, SymbolKind.Variable, letNode.field.ident.span, false)) {\n                    return;\n                }\n\n                this.checkForShadowing(letNode.field.ident.name, scope, SymbolKind.Variable, letNode.field.ident.span, true);\n\n                const symbol: Symbol = this.createLetSymbol(letNode, scope, moduleName);\n                this.config.services.scopeManager.addSymbolToScope(symbol, scope.id);\n                this.incrementSymbolsCollected();\n\n                this.trackModuleExport(moduleName, letNode.field.ident.name, symbol.isExported);\n\n                // ✅ Handle constructor expressions during collection\n                if (letNode.field.initializer) {\n                    const initType = this.extractTypeFromInitializer(letNode.field.initializer);\n                    if (initType) {\n                        letNode.field.type = initType;\n                        symbol.type = initType;\n\n                        // If it's a struct, collect its type structure\n                        if (initType.isStruct() || initType.isEnum()) {\n                            this.collectType(initType, scope, moduleName, letNode.field.ident.name);\n                        }\n                    }\n                }\n\n                // Handle explicit type annotation\n                if (letNode.field.type) {\n                    this.collectType(letNode.field.type, scope, moduleName, letNode.field.ident.name);\n                }\n\n                // Collect initializer expression (for validation during resolution)\n                if (letNode.field.initializer && !letNode.field.type) {\n                    this.collectExpr(letNode.field.initializer, scope, moduleName);\n                }\n            }\n\n            private extractTypeFromInitializer(expr: AST.ExprNode): AST.TypeNode | null {\n                if (expr.kind !== 'Primary') return null;\n\n                const primary = expr.getPrimary();\n                if (!primary) return null;\n\n                // Handle anonymous types: struct { x: i32 }, enum { A, B }\n                if (primary.kind === 'Type') {\n                    return primary.getType();\n                }\n\n                // ✅ Handle constructor syntax: Point { x: 10, y: 20 }\n                if (primary.kind === 'Object') {\n                    const obj = primary.getObject();\n                    if (!obj || !obj.ident) return null;\n\n                    // Look up the type symbol\n                    const typeSymbol = this.config.services.scopeManager.lookupSymbol(obj.ident.name);\n                    if (!typeSymbol || !typeSymbol.type) return null;\n\n                    // Return the type if it's a struct\n                    if (typeSymbol.type.isStruct()) {\n                        return typeSymbol.type;\n                    }\n                }\n\n                return null;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.5] FUNC ─────────────────────────────┐\n\n            private handleFuncStatement(funcNode: AST.FuncStmtNode, scope: Scope, moduleName: string): void {\n                this.collectFuncStmt(funcNode, scope, moduleName);\n            }\n\n            private createFuncSymbol(funcNode: AST.FuncStmtNode, scope: Scope, moduleName: string): Symbol {\n                const symbol = this.createBaseSymbol(\n                    funcNode.ident.name,\n                    SymbolKind.Function,\n                    scope,\n                    moduleName,\n                    funcNode.span,\n                    funcNode.ident.span\n                );\n\n                const isModuleScope = scope.kind === ScopeKind.Module;\n                const isPublic = funcNode.visibility.kind === 'Public'\n\n                return {\n                    ...symbol,\n                    initialized     : true,\n                    visibility      : funcNode.visibility,\n                    isExported      : isModuleScope && isPublic,\n                    metadata        : {\n                        callable    : true,\n                        params      : [] as Symbol[],\n                        returnType  : funcNode.returnType || undefined,\n                        errorType   : funcNode.errorType  || undefined\n                    }\n                };\n            }\n\n            private createFuncScope(functionName: string, parentScope: Scope): Scope {\n                const funcScope = this.config.services.scopeManager.createScope(ScopeKind.Function, functionName, parentScope.id);\n                this.incrementScopesCreated();\n                return funcScope;\n            }\n\n            private collectFuncStmt(funcNode: AST.FuncStmtNode, scope: Scope, moduleName: string): void {\n                this.log('symbols', `Collecting function '${funcNode.ident.name}'`);\n\n                if(this.checkForShadowing(funcNode.ident.name, scope, SymbolKind.Function, funcNode.ident.span)) {\n                    return;\n                }\n\n                this.checkForShadowing(funcNode.ident.name, scope, SymbolKind.Function, funcNode.ident.span, true);\n\n                const funcScope = this.createFuncScope(funcNode.ident.name, scope);\n                const funcSymbol = this.createFuncSymbol(funcNode, scope, moduleName);\n                this.config.services.scopeManager.addSymbolToScope(funcSymbol, scope.id);\n                this.incrementSymbolsCollected();\n\n                this.trackModuleExport(moduleName, funcNode.ident.name, funcSymbol.isExported);\n\n                // MOVED: Check if struct method BEFORE processing\n                const parentScope = this.config.services.scopeManager.getScope(scope.id);\n                const isStructMethod = parentScope.kind === ScopeKind.Type &&\n                                    parentScope.metadata?.typeKind === 'Struct' &&\n                                    !(funcNode.visibility.kind === 'Static');\n\n                this.config.services.scopeManager.withScope(funcScope.id, () => {\n                    this.config.services.contextTracker.withSavedState(() => {\n                        // INJECT SELF FIRST (if struct method)\n                        if (isStructMethod) {\n                            this.injectSelfParameter(funcScope, parentScope, moduleName);\n                        }\n\n                        this.collectType(funcNode.returnType, scope, moduleName, funcNode.ident.name);\n\n                        if (funcSymbol.metadata && funcSymbol.metadata.params) {\n                            funcSymbol.metadata.params = this.collectParams(funcNode.parameters, funcScope, moduleName);\n                        }\n\n                        if (funcNode.body) {\n                            this.collectStmt(funcNode.body, funcScope, moduleName);\n                        }\n                    });\n                });\n            }\n\n            // ───── PARAMS ─────\n\n            private createParamSymbol(paramNode: AST.FieldNode, scope: Scope, moduleName: string): Symbol {\n                const symbol = this.createBaseSymbol(\n                    paramNode.ident.name,\n                    SymbolKind.Parameter,\n                    scope,\n                    moduleName,\n                    paramNode.span,\n                    paramNode.ident.span\n                );\n\n                return {\n                    ...symbol,\n                    type            : paramNode.type ?? null,\n                    initialized     : true,\n                    visibility      : paramNode.visibility ?? 'Private',\n                    mutability      : paramNode.mutability,  // ✅ Added\n                };\n            }\n\n            private collectParams(parameters: AST.FieldNode[], funcScope: Scope, moduleName: string): Symbol[] {\n                const collectedParams: Symbol[] = [];\n                const seenParams = new Set<string>();\n\n                // Check if 'self' already exists (injected by struct method)\n                const hasSelfParam = funcScope.symbols.has('self');\n\n                for (const paramNode of parameters) {\n                    // Prevent explicit 'self' parameter if already injected\n                    if (paramNode.ident.name === 'self' && hasSelfParam) {\n                        this.reportError(\n                            DiagCode.PARAMETER_SHADOWING,\n                            `Duplicate parameter name 'self'`,\n                            paramNode.ident.span\n                        );\n                        continue;\n                    }\n\n                    if(this.checkForShadowing(paramNode.ident.name, funcScope, SymbolKind.Parameter, paramNode.ident.span)) {\n                        continue;\n                    }\n\n                    // Warn if parameter shadows outer scope (like variables in parent function)\n                    this.checkForShadowing(paramNode.ident.name, funcScope, SymbolKind.Parameter, paramNode.ident.span, true);\n\n                    seenParams.add(paramNode.ident.name);\n\n                    const paramSymbol = this.createParamSymbol(paramNode, funcScope, moduleName);\n                    this.config.services.scopeManager.addSymbolToScope(paramSymbol, funcScope.id);\n                    this.incrementSymbolsCollected();\n                    collectedParams.push(paramSymbol);\n\n                    if (paramNode.type) {\n                        if (paramNode.type.isStruct() || paramNode.type.isEnum()) {\n                            const typeScopeName = `${paramNode.ident.name}-type`;\n                            const typeScope = this.createTypeScope(typeScopeName, funcScope);\n\n                            if (paramNode.type.isStruct()) {\n                                const struct = paramNode.type.getStruct()!;\n                                struct.metadata = { ...struct.metadata, scopeId: typeScope.id };\n                            } else if (paramNode.type.isEnum()) {\n                                const enumType = paramNode.type.getEnum()!;\n                                enumType.metadata = { ...enumType.metadata, scopeId: typeScope.id };\n                            }\n\n                            this.collectType(paramNode.type, funcScope, moduleName, typeScopeName);\n                        } else {\n                            this.collectType(paramNode.type, funcScope, moduleName, paramNode.ident.name);\n                        }\n                    }\n                }\n\n                return collectedParams;\n            }\n\n            private injectSelfParameter(\n                funcScope: Scope,\n                structScope: Scope,\n                moduleName: string\n            ): void {\n                // Create a type reference to the parent struct\n                const structType = AST.TypeNode.asIdentifier(\n                    { start: 0, end: 0 },\n                    structScope.name\n                );\n\n                const selfSymbol: Symbol = {\n                    id              : this.config.services.scopeManager.symbolIdGenerator.next(),\n                    name            : 'self',\n                    kind            : SymbolKind.Parameter,\n                    type            : structType,\n                    scope           : funcScope.id,\n                    contextSpan     : { start: 0, end: 0 }, // Synthetic - no source location\n                    targetSpan      : { start: 0, end: 0 },\n                    declared        : true,\n                    initialized     : true,\n                    used            : true, // ✅ Mark as used by default since it's implicit\n                    visibility      : { kind: 'Private' },\n                    mutability      : { kind: 'Immutable' },\n                    isTypeChecked   : false,\n                    isExported      : false,\n                    module          : moduleName,\n                    metadata        : {\n                        isSynthetic : true,\n                        isSelf      : true\n                    }\n                };\n\n                this.config.services.scopeManager.addSymbolToScope(selfSymbol, funcScope.id);\n                this.stats.syntheticSymbolsInjected++; // Track synthetic symbols separately\n                this.incrementSymbolsCollected();\n\n                this.log('symbols', `Injected implicit 'self' parameter in struct method '${funcScope.name}'`);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.6] LOOP ─────────────────────────────┐\n\n            private handleLoopStmt(stmt: AST.StmtNode, scope: Scope, moduleName: string): void {\n                if(stmt.getLoop === undefined) {\n                    const data = stmt;\n                    switch (stmt.kind) {\n                        case 'While' : {\n                            const src = data.source as AST.LoopStmtNode;\n                            const loop = AST.LoopStmtNode.createWhile(data.span, src.expr, src.stmt);\n                            this.collectLoopStmt(loop, scope, moduleName);\n                            break;\n                        }\n                        case 'Do' : {\n                            const src = data.source as AST.LoopStmtNode;\n                            const loop = AST.LoopStmtNode.createDo(data.span, src.expr, src.stmt);\n                            this.collectLoopStmt(loop, scope, moduleName);\n                            break;\n                        }\n                        case 'For' : {\n                            const src = data.source as AST.LoopStmtNode;\n                            const loop = AST.LoopStmtNode.createFor(data.span, src.expr, src.stmt);\n                            this.collectLoopStmt(loop, scope, moduleName);\n                            break;\n                        }\n                    }\n                } else {\n                    this.collectLoopStmt(stmt.getLoop()!, scope, moduleName);\n                }\n            }\n\n            private createLoopScope(parentScope: Scope): Scope {\n                const loopScope = this.config.services.scopeManager.createScope(ScopeKind.Loop, 'loop', parentScope.id);\n                this.incrementScopesCreated();\n                this.log('scopes', `Created loop scope ${loopScope.id} under parent ${parentScope.id}`);\n                return loopScope;\n            }\n\n            private collectLoopStmt(loopNode: AST.LoopStmtNode, parentScope: Scope, moduleName: string): void {\n                const loopScope = this.createLoopScope(parentScope);\n\n                this.config.services.scopeManager.withScope(loopScope.id, () => {\n                    this.config.services.contextTracker.withSavedState(() => {\n                        this.config.services.contextTracker.setScope(loopScope.id);\n\n                        switch (loopNode.kind) {\n                            case 'While':\n                                this.collectExpr(loopNode.expr, loopScope, moduleName);\n                                this.collectStmt(loopNode.stmt, loopScope, moduleName);\n                                break;\n                            case 'Do':\n                                this.collectStmt(loopNode.stmt, loopScope, moduleName);\n                                this.collectExpr(loopNode.expr, loopScope, moduleName);\n                                break;\n                            case 'For':\n                                this.collectExpr(loopNode.expr, loopScope, moduleName);\n                                this.collectStmt(loopNode.stmt, loopScope, moduleName);\n                                break;\n                        }\n                    });\n                });\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────── [3.7] CTRLFLOW ──────────────────────────┐\n\n            private handleControlflowStmt(stmt: AST.StmtNode, scope: Scope, moduleName: string): void {\n                if(stmt.getCtrlflow === undefined) {\n                    const data = stmt;\n                    switch (stmt.kind) {\n                        case 'Return' : {\n                            const src = data.source as AST.ControlFlowStmtNode;\n                            const res = AST.ControlFlowStmtNode.asReturn(data.span, src.value);\n                            this.collectReturnStmt(res, scope, moduleName);\n                            break;\n                        }\n                        case 'Defer' : {\n                            const src = data.source as AST.ControlFlowStmtNode;\n                            const res = AST.ControlFlowStmtNode.asDefer(data.span, src.value);\n                            this.collectDeferStmt(res, scope, moduleName);\n                            break;\n                        }\n                        case 'Throw' : {\n                            const src = data.source as AST.ControlFlowStmtNode;\n                            const res = AST.ControlFlowStmtNode.asThrow(data.span, src.value);\n                            this.collectThrowStmt(res, scope, moduleName);\n                            break;\n                        }\n                    }\n                } else {\n                    switch (stmt.getCtrlflow()!.kind) {\n                        case 'return' : {\n                            this.collectReturnStmt(stmt.getCtrlflow()!, scope, moduleName);\n                            break;\n                        }\n                        case 'defer' : {\n                            this.collectDeferStmt(stmt.getCtrlflow()!, scope, moduleName);\n                            break;\n                        }\n                        case 'throw' : {\n                            this.collectThrowStmt(stmt.getCtrlflow()!, scope, moduleName);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            private collectReturnStmt(returnNode: AST.ControlFlowStmtNode, scope: Scope, moduleName: string): void {\n                if (returnNode.value) {\n                    this.collectExpr(returnNode.value, scope, moduleName);\n                }\n            }\n\n            private collectDeferStmt(deferNode: AST.ControlFlowStmtNode, scope: Scope, moduleName: string): void {\n                if (deferNode.value) {\n                    this.collectExpr(deferNode.value, scope, moduleName);\n                }\n            }\n\n            private collectThrowStmt(throwNode: AST.ControlFlowStmtNode, scope: Scope, moduleName: string): void {\n                if (throwNode.value) {\n                    this.collectExpr(throwNode.value, scope, moduleName);\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [4] EXPR Level ───────────────────────────┐\n\n            private createExprScope(parentScope: Scope): Scope {\n                const exprScope = this.config.services.scopeManager.createScope(ScopeKind.Expression, 'expr', parentScope.id);\n                this.incrementScopesCreated();\n                return exprScope;\n            }\n\n            private collectExpr(expr: AST.ExprNode, currentScope: Scope, moduleName: string): void {\n                let needsScope = false;\n\n                switch (expr.kind) {\n                    case 'If':\n                    case 'Switch':\n                    case 'Try':\n                    case 'Catch':\n                        needsScope = true;\n                        break;\n                }\n\n                if (needsScope) {\n                    const exprScope = this.createExprScope(currentScope);\n                    this.config.services.scopeManager.withScope(exprScope.id, () => {\n                        this.config.services.contextTracker.withSavedState(() => {\n                            this.config.services.contextTracker.setScope(exprScope.id);\n                            this.processExprKind(expr, exprScope, moduleName);\n                        });\n                    });\n                } else {\n                    this.processExprKind(expr, currentScope, moduleName);\n                }\n            }\n\n            private processExprKind(expr: AST.ExprNode, scope: Scope, moduleName: string): void {\n                switch (expr.kind) {\n                    case 'As':\n                        this.handleAsExpr(expr.getAs()!, scope, moduleName);\n                        break;\n                    case 'Typeof':\n                        return this.processExprKind(expr.getTypeof()!.expr, scope, moduleName);\n                    case 'Sizeof':\n                        return this.processExprKind(expr.getSizeof()!.expr, scope, moduleName);\n                    case 'Orelse':\n                        this.handleOrelseExpr(expr.getOrelse()!, scope, moduleName);\n                        break;\n                    case 'Range':\n                        this.handleRangeExpr(expr.getRange()!, scope, moduleName);\n                        break;\n                    case 'Try':\n                        this.handleTryExpr(expr.getTry()!, scope, moduleName);\n                        break;\n                    case 'Catch':\n                        this.handleCatchExpr(expr.getCatch()!, scope, moduleName);\n                        break;\n                    case 'If':\n                        this.handleIfExpr(expr.getIf()!, scope, moduleName);\n                        break;\n                    case 'Switch':\n                        this.handleSwitchExpr(expr.getSwitch()!, scope, moduleName);\n                        break;\n                    case 'Binary':\n                        this.handleBinaryExpr(expr.getBinary()!, scope, moduleName);\n                        break;\n                    case 'Postfix':\n                        this.handlePostfixExpr(expr.getPostfix()!, scope, moduleName);\n                        break;\n                    case 'Prefix':\n                        this.handlePrefixExpr(expr.getPrefix()!, scope, moduleName);\n                        break;\n                    case 'Primary':\n                        this.handlePrimaryExpr(expr.getPrimary()!, scope, moduleName);\n                        break;\n                }\n            }\n\n            private handleAsExpr(asExpr: AST.AsNode, scope: Scope, moduleName: string): void {\n                this.collectType(asExpr.type, scope, moduleName);\n                this.collectExpr(asExpr.base, scope, moduleName);\n            }\n\n            private handleOrelseExpr(orelseExpr: AST.OrelseNode, scope: Scope, moduleName: string): void {\n                this.collectExpr(orelseExpr.left, scope, moduleName);\n                this.collectExpr(orelseExpr.right, scope, moduleName);\n            }\n\n            private handleRangeExpr(rangeExpr: AST.RangeNode, scope: Scope, moduleName: string): void {\n                if(rangeExpr.leftExpr) this.collectExpr(rangeExpr.leftExpr, scope, moduleName);\n                if(rangeExpr.rightExpr) this.collectExpr(rangeExpr.rightExpr, scope, moduleName);\n            }\n\n            private handleTryExpr(tryExpr: AST.TryNode, scope: Scope, moduleName: string): void {\n                this.collectExpr(tryExpr.expr, scope, moduleName);\n            }\n\n            private handleCatchExpr(catchExpr: AST.CatchNode, scope: Scope, moduleName: string): void {\n                this.collectExpr(catchExpr.leftExpr, scope, moduleName);\n                this.collectStmt(catchExpr.rightStmt, scope, moduleName);\n            }\n\n            private handleIfExpr(ifExpr: AST.IfNode, scope: Scope, moduleName: string): void {\n                this.collectExpr(ifExpr.condExpr, scope, moduleName);\n                this.collectStmt(ifExpr.thenStmt, scope, moduleName);\n                if (ifExpr.elseStmt) {\n                    this.collectStmt(ifExpr.elseStmt, scope, moduleName);\n                }\n            }\n\n            private handleSwitchExpr(switchExpr: AST.SwitchNode, scope: Scope, moduleName: string): void {\n                this.collectExpr(switchExpr.condExpr, scope, moduleName);\n                for (const switchCase of switchExpr.cases) {\n                    if (switchCase.expr) this.collectExpr(switchCase.expr, scope, moduleName);\n                    if (switchCase.stmt) this.collectStmt(switchCase.stmt, scope, moduleName);\n                }\n                if (switchExpr.defCase) {\n                    this.collectStmt(switchExpr.defCase.stmt, scope, moduleName);\n                }\n            }\n\n            private handleBinaryExpr(binaryExpr: AST.BinaryNode, scope: Scope, moduleName: string): void {\n                this.collectExpr(binaryExpr.left, scope, moduleName);\n                this.collectExpr(binaryExpr.right, scope, moduleName);\n            }\n\n            private handlePostfixExpr(postfixExpr: AST.PostfixNode, scope: Scope, moduleName: string): void {\n                switch(postfixExpr.kind) {\n                    case 'Increment':\n                    case 'Decrement':\n                    case 'Dereference':\n                        this.collectExpr(postfixExpr.getAsExprNode()!, scope, moduleName);\n                        break;\n                    case 'Call': {\n                        const callExpr = postfixExpr.getCall()!;\n                        this.collectExpr(callExpr.base, scope, moduleName);\n                        for (const arg of callExpr.args) {\n                            this.collectExpr(arg, scope, moduleName);\n                        }\n                        break;\n                    }\n                    case 'ArrayAccess': {\n                        const arrayAccess = postfixExpr.getArrayAccess()!;\n                        this.collectExpr(arrayAccess.base, scope, moduleName);\n                        this.collectExpr(arrayAccess.index, scope, moduleName);\n                        break;\n                    }\n                    case 'MemberAccess': {\n                        const memberAccess = postfixExpr.getMemberAccess()!;\n                        this.collectExpr(memberAccess.base, scope, moduleName);\n                        break;\n                    }\n                }\n            }\n\n            private handlePrefixExpr(prefixExpr: AST.PrefixNode, scope: Scope, moduleName: string): void {\n                this.collectExpr(prefixExpr.expr, scope, moduleName);\n            }\n\n            private handlePrimaryExpr(primaryExpr: AST.PrimaryNode, scope: Scope, moduleName: string): void {\n                switch(primaryExpr.kind) {\n                    case 'Ident': {\n                        const ident = primaryExpr.getIdent();\n                        if (ident && ident.name === 'self') {\n                            this.validateSelfUsage(scope, ident.span);\n                        }\n                        break;\n                    }\n                    case 'Literal':\n                        break;\n                    case 'Type': {\n                        const type = primaryExpr.getType()!;\n                        this.collectType(type, scope, moduleName);\n                        break;\n                    }\n                    case 'Paren': {\n                        const paren = primaryExpr.getParen()!;\n                        this.collectExpr(paren.source, scope, moduleName);\n                        break;\n                    }\n                    case 'Tuple': {\n                        const tuple = primaryExpr.getTuple()!;\n                        for (const expr of tuple.fields) {\n                            this.collectExpr(expr, scope, moduleName);\n                        }\n                        break;\n                    }\n                    case 'Object': {\n                        const object = primaryExpr.getObject()!;\n                        if(object.ident) {\n                            this.collectExpr(\n                                AST.ExprNode.asIdent(object.ident.span, object.ident.name),\n                                scope,\n                                moduleName\n                            );\n                        }\n                        for (const field of object.props) {\n                            if(field.val) this.collectExpr(field.val, scope, moduleName);\n                        }\n                        break;\n                    }\n                }\n            }\n\n            private validateSelfUsage(currentScope: Scope, span: AST.Span): void {\n                // ✅ Check if we're in a static method of a struct\n                let checkScope: Scope | null = currentScope;\n                let isInStaticMethod = false;\n                let structScope: Scope | null = null;\n\n                while (checkScope) {\n                    if (checkScope.kind === ScopeKind.Function) {\n                        const parentScope = checkScope.parent !== null\n                            ? this.config.services.scopeManager.getScope(checkScope.parent)\n                            : null;\n\n                        if (parentScope?.kind === ScopeKind.Type &&\n                            parentScope.metadata?.typeKind === 'Struct') {\n                            structScope = parentScope;\n                            // Check if this function is marked as static\n                            const funcSymbol = parentScope.symbols.get(checkScope.name);\n                            if (funcSymbol && funcSymbol.visibility.kind === 'Static') {\n                                isInStaticMethod = true;\n                            }\n                            break;\n                        }\n                    }\n\n                    checkScope = checkScope.parent !== null\n                        ? this.config.services.scopeManager.getScope(checkScope.parent)\n                        : null;\n                }\n\n                // ✅ ALLOW 'self' in static methods - validation happens later in TypeValidator\n                if (isInStaticMethod && structScope) {\n                    // Don't block - let it pass through for member access validation\n                    return;\n                }\n\n                // ✅ For non-static contexts, validate as before\n                const selfSymbol = this.config.services.scopeManager.lookupSymbolInScopeChain('self', currentScope.id);\n\n                if (!selfSymbol || !selfSymbol.metadata?.isSelf) {\n                    this.reportError(\n                        DiagCode.UNDEFINED_IDENTIFIER,\n                        \"Undefined identifier 'self' - can only be used in struct instance methods\",\n                        span\n                    );\n                    return;\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [5] Type Level ───────────────────────────┐\n\n            private createTypeScope(typeName: string, parentScope: Scope, typeKind?: 'Struct' | 'Enum'): Scope {\n                const typeScope = this.config.services.scopeManager.createScope(ScopeKind.Type, typeName, parentScope.id);\n\n                // ✅ Set metadata immediately\n                if (typeKind) {\n                    typeScope.metadata = {\n                        ...typeScope.metadata,\n                        typeKind\n                    };\n                }\n\n                this.incrementScopesCreated();\n                return typeScope;\n            }\n\n            private collectType(\n                type: AST.TypeNode | undefined | null,\n                parentScope: Scope,\n                moduleName: string,\n                newScopeName?: string\n            ): void {\n                if (!type) return;\n\n                // Use withTypeContext for cycle detection\n                this.withTypeContext(type, newScopeName, () => {\n                    this.collectTypeInternal(type, parentScope, moduleName, newScopeName);\n                });\n            }\n\n            private collectTypeInternal(\n                type: AST.TypeNode,\n                parentScope: Scope,\n                moduleName: string,\n                newScopeName?: string\n            ): void {\n                let needsScope = false;\n                let typeName = 'Anonymous';\n                let typeScope: Scope = parentScope;\n\n                switch(type.kind) {\n                    case 'struct':\n                        needsScope = true;\n                        if (newScopeName) {\n                            typeName = newScopeName;\n                        } else {\n                            const anonId = this.config.services.scopeManager.symbolIdGenerator.next();\n                            typeName = `<anonymous-struct-${anonId}>`;\n                        }\n                        break;\n                    case 'enum':\n                        needsScope = true;\n                        if (newScopeName) {\n                            typeName = newScopeName;\n                        } else {\n                            const anonId = this.config.services.scopeManager.symbolIdGenerator.next();\n                            typeName = `<anonymous-enum-${anonId}>`;\n                        }\n                        break;\n                    case 'errset':\n                        needsScope = true;\n                        typeName = newScopeName || '<anonymous-error>';\n                        break;\n                }\n\n                if (needsScope) {\n                    typeScope = this.createTypeScope(typeName, parentScope);\n\n                    // ✅ ADD THIS: Set metadata immediately after scope creation\n                    switch(type.kind) {\n                        case 'struct':\n                            typeScope.metadata = { ...typeScope.metadata, typeKind: 'Struct' };\n                            break;\n                        case 'enum':\n                            typeScope.metadata = { ...typeScope.metadata, typeKind: 'Enum' };\n                            break;\n                        case 'errset':\n                            typeScope.metadata = { ...typeScope.metadata, typeKind: 'Error' };\n                            break;\n                    }\n\n                    // Validate scope ID before use\n                    if (!this.config.services.scopeManager.getScope(typeScope.id)) {\n                        throw new Error(`Invalid scope ID ${typeScope.id} for type ${typeName}`);\n                    }\n                }\n\n                try {\n                    switch(type.kind) {\n                        case 'struct':\n                            this.handleStructType(type.getStruct()!, typeScope, moduleName);\n                            break;\n                        case 'enum':\n                            this.handleEnumType(type.getEnum()!, typeScope, moduleName);\n                            break;\n                        case 'errset':\n                            this.collectErrorType(type.getError()!, typeScope, moduleName);\n                            break;\n                        case 'tuple':\n                            this.handleTupleType(type.getTuple()!, parentScope, moduleName);\n                            break;\n                        case 'array':\n                            this.handleArrayType(type.getArray()!, parentScope, moduleName);\n                            break;\n                        case 'optional':\n                            this.handleOptionalType(type.getOptional()!, parentScope, moduleName);\n                            break;\n                        case 'pointer':\n                            this.handlePointerType(type.getPointer()!, parentScope, moduleName);\n                            break;\n                        case 'function':\n                            this.handleFunctionType(type.getFunction()!, parentScope, moduleName);\n                            break;\n                        case 'union':\n                            this.handleUnionType(type.getUnion()!, parentScope, moduleName);\n                            break;\n                        case 'paren':\n                            this.collectTypeInternal(type.getParen()!.type, parentScope, moduleName);\n                    }\n                } catch (error) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Failed to collect type ${type.kind}: ${error}`\n                    );\n                }\n            }\n\n            private handleStructType(structType: AST.StructTypeNode, typeScope: Scope, moduleName: string): void {\n                structType.metadata = { ...structType.metadata, scopeId: typeScope.id };\n\n                // CRITICAL: Mark scope so we know this is a struct type scope\n                typeScope.metadata = {\n                    ...typeScope.metadata,\n                    typeKind: 'Struct'  // ✅ This line exists but might not be executing\n                };\n\n                for (const member of structType.members) {\n                    if(!member || !member.kind || !member.source) { continue; }\n\n                    if(member.isField()) {\n                        this.collectStructField(member.source as AST.FieldNode, typeScope, moduleName);\n                    } else {\n                        this.collectFuncStmt(member.source as AST.FuncStmtNode, typeScope, moduleName);\n                    }\n                }\n            }\n\n            private handleEnumType(enumType: AST.EnumTypeNode, typeScope: Scope, moduleName: string): void {\n                enumType.metadata = { ...enumType.metadata, scopeId: typeScope.id };\n\n                for (const variant of enumType.variants) {\n                    if (typeScope.symbols.has(variant.ident.name)) {\n                        this.reportError(\n                            DiagCode.ENUM_VARIANT_SHADOWING,\n                            `Duplicate enum variant '${variant.ident.name}'`,\n                            variant.ident.span\n                        );\n                        continue;\n                    }\n\n                    if(variant.type) {\n                        const variantScope = this.createTypeScope(variant.ident.name, typeScope);\n                        if (variant.type.isStruct()) {\n                            const structType = variant.type.getStruct()!;\n                            structType.metadata = {\n                                ...structType.metadata,\n                                scopeId: variantScope.id\n                            };\n\n                            this.config.services.scopeManager.withScope(variantScope.id, () => {\n                                this.config.services.contextTracker.withSavedState(() => {\n                                    this.config.services.contextTracker.setScope(variantScope.id);\n                                    this.collectType(variant.type!, variantScope, moduleName, variant.ident.name);\n                                });\n                            });\n                        } else {\n                            this.collectType(variant.type, typeScope, moduleName);\n                        }\n                    } else {\n                        // Simple variant - NO SCOPE NEEDED\n                        this.collectEnumVariantIdent(variant.ident, typeScope, moduleName);\n                    }\n                }\n            }\n\n            private handleTupleType(tupleType: AST.TupleTypeNode, parentScope: Scope, moduleName: string): void {\n                for (const field of tupleType.fields) {\n                    this.collectType(field, parentScope, moduleName);\n                }\n            }\n\n            private handleArrayType(arrayType: AST.ArrayTypeNode, parentScope: Scope, moduleName: string): void {\n                this.collectType(arrayType.target, parentScope, moduleName);\n                if(arrayType.size) this.collectExpr(arrayType.size, parentScope, moduleName);\n            }\n\n            private handleOptionalType(optionalType: AST.OptionalTypeNode, parentScope: Scope, moduleName: string): void {\n                this.collectType(optionalType.target, parentScope, moduleName);\n            }\n\n            private handlePointerType(pointerType: AST.PointerTypeNode, parentScope: Scope, moduleName: string): void {\n                this.collectType(pointerType.target, parentScope, moduleName);\n            }\n\n            private handleFunctionType(funcType: AST.FunctionTypeNode, parentScope: Scope, moduleName: string): void {\n                for (const param of funcType.params) {\n                    if (param) {\n                        this.collectType(param, parentScope, moduleName);\n                    }\n                }\n\n                if (funcType.returnType) {\n                    this.collectType(funcType.returnType, parentScope, moduleName);\n                }\n\n                if (funcType.errorType) {\n                    this.collectType(funcType.errorType, parentScope, moduleName);\n                }\n            }\n\n            private handleUnionType(unionType: AST.UnionTypeNode, parentScope: Scope, moduleName: string): void {\n                for (const variant of unionType.types) {\n                    this.collectType(variant, parentScope, moduleName);\n                }\n            }\n\n            private collectStructField(fieldNode: AST.FieldNode, scope: Scope, moduleName: string): void {\n                this.log('symbols', `Collecting structure field '${fieldNode.ident.name}'`);\n\n                // Only check for shadowing WITHIN the struct scope\n                if(this.checkForShadowing(fieldNode.ident.name, scope, SymbolKind.StructField, fieldNode.ident.span, false)) {\n                    return;\n                }\n\n                const symbol: Symbol = this.createStructFieldSymbol(fieldNode, scope, moduleName);\n                this.config.services.scopeManager.addSymbolToScope(symbol, scope.id);\n                this.incrementSymbolsCollected();\n\n                if(fieldNode.type) {\n                    this.collectType(fieldNode.type, scope, moduleName);\n                }\n\n                if(fieldNode.initializer) {\n                    this.collectExpr(fieldNode.initializer, scope, moduleName);\n                }\n            }\n\n            private createStructFieldSymbol(fieldNode: AST.FieldNode, scope: Scope, moduleName: string): Symbol {\n                const symbol = this.createBaseSymbol(\n                    fieldNode.ident.name,\n                    SymbolKind.StructField,\n                    scope,\n                    moduleName,\n                    fieldNode.span,\n                    fieldNode.ident.span\n                );\n\n                return {\n                    ...symbol,\n                    type            : fieldNode.type ?? null,\n                    initialized     : !!fieldNode.initializer,\n                    visibility      : fieldNode.visibility ?? 'Private',\n                    mutability      : fieldNode.mutability,  // ✅ Added\n                };\n            }\n\n            private collectEnumVariantIdent(identNode: AST.IdentNode, scope: Scope, moduleName: string): void {\n                const symbol = this.createEnumVariantSymbol(identNode, scope, moduleName);\n                this.config.services.scopeManager.addSymbolToScope(symbol, scope.id);\n                this.incrementSymbolsCollected();\n            }\n\n            private createEnumVariantSymbol(identNode: AST.IdentNode, scope: Scope, moduleName: string): Symbol {\n                return this.createBaseSymbol(\n                    identNode.name,\n                    SymbolKind.EnumVariant,\n                    scope,\n                    moduleName,\n                    identNode.span,\n                    identNode.span\n                );\n            }\n\n            private collectErrorType(errorType: AST.ErrsetTypeNode, scope: Scope, moduleName: string): void {\n                if(errorType.members.length === 0) return;\n\n                const seenErrors = new Set<string>();\n\n                for (const error of errorType.members) {\n                    // Check for duplicate error names\n                    if (seenErrors.has(error.name)) {\n                        this.reportError(\n                            DiagCode.ERROR_SHADOWING,\n                            `Duplicate error member '${error.name}'`,\n                            error.span\n                        );\n                        continue;\n                    }\n\n                    seenErrors.add(error.name);\n\n                    const symbol = this.createErrorSymbol(error, scope, moduleName);\n                    this.config.services.scopeManager.addSymbolToScope(symbol, scope.id);\n                    this.incrementSymbolsCollected();\n                }\n            }\n\n            private createErrorSymbol(error: AST.IdentNode, scope: Scope, moduleName: string): Symbol {\n                return this.createBaseSymbol(\n                    error.name,\n                    SymbolKind.Error,\n                    scope,\n                    moduleName,\n                    error.span,\n                    error.span\n                );\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [x] VALIDATION ───────────────────────────┐\n\n            private checkForShadowing(\n                newSymbolName: string,\n                currentScope: Scope,\n                newSymbolKind: SymbolKind,\n                span: AST.Span,\n                outer = false\n            ): boolean {\n                // Special handling for 'self' - ALWAYS check parent scopes too\n                if (newSymbolName === 'self') {\n                    // For 'self', check both current and parent scopes\n                    const existingSymbol = outer\n                        ? this.config.services.scopeManager.lookupSymbolInParentScopes('self', currentScope.id)\n                        : (currentScope.symbols.get('self') ||\n                        this.config.services.scopeManager.lookupSymbolInParentScopes('self', currentScope.id));\n\n                    if (existingSymbol && existingSymbol.metadata?.isSelf) {\n                        this.reportError(\n                            newSymbolKind === SymbolKind.Parameter\n                                ? DiagCode.PARAMETER_SHADOWING\n                                : DiagCode.VARIABLE_SHADOWING,\n                            newSymbolKind === SymbolKind.Parameter\n                                ? `Duplicate parameter name 'self'`\n                                : `Symbol 'self' shadows parameter 'self' in ${outer ? 'outer' : 'same'} scope`,\n                            span\n                        );\n                        return true; // Always error for 'self'\n                    }\n                }\n\n                // Prevent built-in shadowing\n                if (newSymbolName.startsWith('@')) {\n                    this.reportError(\n                        DiagCode.DUPLICATE_SYMBOL,\n                        `Cannot shadow built-in symbol '${newSymbolName}'`,\n                        span\n                    );\n                    return true;\n                }\n\n                const existingSymbol = outer\n                    ? this.config.services.scopeManager.lookupSymbolInParentScopes(newSymbolName, currentScope.id)\n                    : currentScope.symbols.get(newSymbolName);\n\n                if (existingSymbol) {\n\n                    // Check if we're in a type scope (struct/enum)\n                    const isInTypeScope = currentScope.kind === ScopeKind.Type;\n                    const existingIsInTypeScope = this.config.services.scopeManager.getScope(existingSymbol.scope).kind === ScopeKind.Type;\n\n                    // If one is in type scope and one isn't, they're in different namespaces\n                    if (isInTypeScope !== existingIsInTypeScope && outer) {\n                        this.log('verbose',\n                            `Symbol '${newSymbolName}' in type scope doesn't shadow module-level symbol (different namespaces)`\n                        );\n                        return false; // No shadowing - different namespaces\n                    }\n\n                    let diagnosticCode: DiagCode;\n                    let severity: DiagKind = DiagKind.ERROR;\n\n                    switch (newSymbolKind) {\n                        case SymbolKind.Use:\n                            diagnosticCode = DiagCode.USE_SHADOWING;\n                            break;\n                        case SymbolKind.Definition:\n                            diagnosticCode = DiagCode.DEFINITION_SHADOWING;\n                            break;\n                        case SymbolKind.Variable:\n                            diagnosticCode = DiagCode.VARIABLE_SHADOWING;\n                            if (outer) severity = DiagKind.WARNING;\n                            break;\n                        case SymbolKind.Function:\n                            diagnosticCode = DiagCode.FUNCTION_SHADOWING;\n                            if (outer) severity = DiagKind.WARNING;\n                            break;\n                        case SymbolKind.Parameter:\n                            diagnosticCode = DiagCode.PARAMETER_SHADOWING;\n                            if (outer) severity = DiagKind.WARNING;\n                            break;\n                        case SymbolKind.StructField:\n                            diagnosticCode = DiagCode.STRUCT_FIELD_SHADOWING;\n                            break;\n                        case SymbolKind.EnumVariant:\n                            diagnosticCode = DiagCode.ENUM_VARIANT_SHADOWING;\n                            break;\n                        case SymbolKind.Error:\n                            diagnosticCode = DiagCode.ERROR_SHADOWING;\n                            break;\n                        default:\n                            return false;\n                    }\n\n                    const message = `Symbol '${newSymbolName}' shadows ${(existingSymbol.kind as string).toLowerCase()} '${existingSymbol.name}' in ${outer ? 'outer' : 'same'} scope`;\n\n                    if (severity === DiagKind.WARNING) {\n                        this.reportWarning(diagnosticCode, message, span);\n                    } else {\n                        this.reportError(diagnosticCode, message, span);\n                    }\n\n                    return severity === DiagKind.ERROR ? !outer : false;\n                }\n                return false;\n            }\n\n            private checkTypeCycle(type: AST.TypeNode, scopeName?: string): boolean {\n                const typeKey = this.createTypeKey(type, scopeName);\n\n                if (this.typeContext.visitedTypes.has(typeKey)) {\n                    this.log('verbose', `Cycle detected in type: ${typeKey}`);\n                    this.log('verbose', `Type path: ${this.typeContext.currentTypePath.join(' -> ')}`);\n\n                    // Report as warning, not error - cycles via pointers are valid\n                    this.reportWarning(\n                        DiagCode.TYPE_CYCLE_DETECTED,\n                        `Circular type reference detected for ${type.kind} (this is OK for pointer types)`,\n                        type.span\n                    );\n\n                    // Pointer cycles are OK, just log and continue\n                    this.log('verbose', `Valid pointer cycle: ${typeKey}`);\n                    return false; // Continue processing\n                }\n\n                // Track max nesting for diagnostics\n                if (this.typeContext.nestingDepth > this.typeContext.maxNestingDepth) {\n                    this.typeContext.maxNestingDepth = this.typeContext.nestingDepth;\n                }\n\n                // Safety limit: 100 levels should handle any reasonable code\n                if (this.typeContext.nestingDepth > 100) {\n                    this.reportError(\n                        DiagCode.TYPE_NESTING_TOO_DEEP,\n                        // `Type nesting exceeds safety limit (${this.typeContext.nestingDepth} levels) - possible infinite recursion`,\n                        `Type nesting exceeds safety limit`,\n                        type.span\n                    );\n                    return true;\n                }\n\n                return false;\n            }\n\n            private withTypeContext(type: AST.TypeNode, scopeName: string | undefined, operation: () => void): void {\n                const typeKey = this.createTypeKey(type, scopeName);\n\n                // If cycle detected, stop processing\n                if (this.checkTypeCycle(type, scopeName)) {\n                    return;\n                }\n\n                // Add to visited set and path\n                this.typeContext.visitedTypes.add(typeKey);\n                this.typeContext.currentTypePath.push(typeKey);\n                this.typeContext.nestingDepth++;\n\n                try {\n                    operation();\n                } finally {\n                    // CRITICAL: Always cleanup, even on error\n                    this.typeContext.visitedTypes.delete(typeKey);\n                    this.typeContext.currentTypePath.pop();\n                    this.typeContext.nestingDepth--;\n                }\n            }\n\n            private validateSymbolExistsInModule(module: AST.Module, symbolName: string): boolean {\n                for (const stmt of module.statements) {\n                    if (stmt.kind === 'Let') {\n                        const varNode = stmt.getLet();\n                        if (varNode && varNode.field.ident.name === symbolName) {\n                            return true;\n                        }\n                    } else if (stmt.kind === 'Func') {\n                        const funcNode = stmt.getFunc();\n                        if (funcNode && funcNode.ident.name === symbolName) {\n                            return true;\n                        }\n                    } else if (stmt.kind === 'Def') {\n                        const defNode = stmt.getDef();\n                        if (defNode && defNode.ident.name === symbolName) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }\n\n            private validateMemberPathInModule(\n                module: AST.Module,\n                memberPath: AST.IdentNode[] | undefined, // ✅ Now can be undefined\n                useNode: AST.UseStmtNode\n            ): boolean {\n                // ✅ Wildcard imports don't need validation here\n                if (!memberPath) {\n                    // Wildcard - always valid if module exists\n                    return true;\n                }\n\n                if (memberPath.length === 0) return false;\n                if (memberPath.length === 1) {\n                    return this.validateSymbolExistsInModule(module, memberPath[0].name);\n                }\n\n                // Start with the first identifier in the module\n                let currentSymbolName = memberPath[0].name;\n                if (!this.validateSymbolExistsInModule(module, currentSymbolName)) {\n                    this.reportError(\n                        DiagCode.SYMBOL_NOT_FOUND,\n                        `Symbol '${currentSymbolName}' not found in module`,\n                        memberPath[0].span\n                    );\n                    return false;\n                }\n\n                this.log('verbose',\n                    `Member path ${memberPath.map(m => m.name).join('.')} found in module (full validation deferred to type checking)`\n                );\n\n                return true;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private init(): boolean {\n                this.pathContext.rootPath   = this.config.program!.metadata?.path as string | undefined;\n\n                this.config.services.contextTracker.reset();\n                this.config.services.contextTracker.setPhase(AnalysisPhase.Collection);\n\n                if (!this.config.program) {\n                    this.reportError(DiagCode.ANALYSIS_ERROR, 'No program provided for analysis');\n                    return false;\n                }\n\n                try {\n                    this.config.services.scopeManager.reset();\n                    const globalScope = this.config.services.scopeManager.getCurrentScope();\n                    if (globalScope.kind !== ScopeKind.Global) {\n                        this.reportError( DiagCode.INTERNAL_ERROR, 'Current scope is not global at the start of symbol collection' );\n                        return false;\n                    }\n                    this.incrementScopesCreated();\n                } catch (error) {\n                    this.reportError( DiagCode.INTERNAL_ERROR, `Failed to initialize scope manager: ${error}` );\n                    return false;\n                }\n\n                return true;\n            }\n\n            private initStats(): CollectionStats {\n                return {\n                    modulesProcessed            : 0,\n                    symbolsCollected            : 0,\n                    importResolutionFailures    : 0,\n                    scopesCreated               : 0,\n                    syntheticSymbolsInjected    : 0,\n                    startTime                   : Date.now()\n                };\n            }\n\n            private initTypeContext(): TypeCollectionContext {\n                return {\n                    visitedTypes        : new Set<string>(),\n                    currentTypePath     : [],\n                    nestingDepth        : 0,\n                    maxNestingDepth     : 0\n                };\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private createTypeKey(type: AST.TypeNode, scopeName?: string): string {\n                // Use span for uniqueness, kind for readability\n                const baseKey = `${type.kind}:${type.span.start}:${type.span.end}`;\n                return scopeName ? `${baseKey}:${scopeName}` : baseKey;\n            }\n\n            private createBaseSymbol(\n                name: string,\n                kind: SymbolKind,\n                scope: Scope,\n                moduleName: string,\n                contextSpan: AST.Span,\n                targetSpan: AST.Span\n            ): Symbol {\n                return {\n                    id              : this.config.services.scopeManager.symbolIdGenerator.next(),\n                    name,\n                    kind,\n                    module          : moduleName,\n                    scope           : scope.id,\n                    contextSpan,\n                    targetSpan,\n                    type            : null,\n                    declared        : true,\n                    initialized     : false,\n                    used            : false,\n                    visibility      : { kind: 'Private' },\n                    mutability      : { kind: 'Immutable' },\n                    isTypeChecked   : false,\n                    isExported      : false\n                };\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private incrementSymbolsCollected(): void {\n                this.stats.symbolsCollected++;\n            }\n\n            private incrementScopesCreated(): void {\n                this.stats.scopesCreated++;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private trackModuleExport(moduleName: string, symbolName: string, isExported: boolean): void {\n                if (!isExported) return;\n\n                if (!this.moduleExports.has(moduleName)) {\n                    this.moduleExports.set(moduleName, new Set());\n                }\n                this.moduleExports.get(moduleName)!.add(symbolName);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            logStatistics(): void {\n                const duration = Date.now() - this.stats.startTime;\n                const stats = [\n                    `Collection Statistics:`,\n                    `  Duration             : ${duration}ms`,\n                    `  Modules processed    : ${this.stats.modulesProcessed}`,\n                    `  Symbols collected    : ${this.stats.symbolsCollected}`,\n                    `  Scopes created       : ${this.stats.scopesCreated}`,\n                    `  Import failures      : ${this.stats.importResolutionFailures}`,\n                    `  Max type nesting     : ${this.typeContext.maxNestingDepth}`\n                ];\n                this.log('verbose', stats.join('\\n'));\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            getTypeRegistry(): Map<string, Symbol> {\n                return new Map(this.typeRegistry); // Return copy for safety\n            }\n\n            getModuleExports(moduleName: string): Set<string> | undefined {\n                return this.moduleExports.get(moduleName);\n            }\n\n            canImportSymbol(moduleName: string, symbolName: string): boolean {\n                const exports = this.moduleExports.get(moduleName);\n                return exports ? exports.has(symbolName) : false;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// PathUtils.ts - Enhanced path resolution utilities\r\n//\r\n// Developed with ❤️ by Maysara.\r\n\r\nimport * as path from 'path';\r\nimport type { Program, Module } from '@je-es/ast';\r\n\r\nexport class PathUtils {\r\n    /**\r\n     * Resolves a module import path against the program's root path\r\n     */\r\n    static resolveModulePath(program: Program, importPath: string, currentModulePath?: string): string {\r\n        const programRoot = program.metadata?.path as string || './';\r\n\r\n        // If import path starts with '.' or '..', resolve relative to current module\r\n        if (importPath.startsWith('.') && currentModulePath) {\r\n            const currentDir = path.dirname(currentModulePath);\r\n            const resolved = path.resolve(currentDir, importPath);\r\n            // Normalize to relative path from program root\r\n            return path.relative(programRoot, resolved);\r\n        }\r\n\r\n        // For absolute imports, resolve from program root\r\n        if (path.isAbsolute(importPath)) {\r\n            return path.relative(programRoot, importPath);\r\n        }\r\n\r\n        // Otherwise resolve relative to program root\r\n        return path.normalize(importPath);\r\n    }\r\n\r\n    /**\r\n     * Finds a module by its resolved path\r\n     */\r\n    static findModuleByPath(program: Program, targetPath: string): Module | undefined {\r\n        const programRoot = program.metadata?.path as string || './';\r\n        const normalizedTarget = path.normalize(targetPath);\r\n\r\n        for (const [_, module] of program.modules) {\r\n            const modulePath = module.metadata?.path as string | undefined;\r\n            if (!modulePath) continue;\r\n\r\n            // Compare both absolute and relative paths\r\n            const relativeModulePath = path.relative(programRoot, modulePath);\r\n            const normalizedModulePath = path.normalize(modulePath);\r\n            const normalizedRelativePath = path.normalize(relativeModulePath);\r\n\r\n            if (normalizedModulePath === normalizedTarget ||\r\n                normalizedRelativePath === normalizedTarget ||\r\n                modulePath === targetPath ||\r\n                relativeModulePath === targetPath) {\r\n                return module;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Validates if a path exists in the program structure\r\n     */\r\n    static validatePath(program: Program, importPath: string, currentModulePath?: string): boolean {\r\n        try {\r\n            const resolvedPath = this.resolveModulePath(program, importPath, currentModulePath);\r\n            return this.findModuleByPath(program, resolvedPath) !== undefined;\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the relative path between two modules\r\n     */\r\n    static getRelativePath(fromPath: string, toPath: string): string {\r\n        const relativePath = path.relative(path.dirname(fromPath), toPath);\r\n        return relativePath.startsWith('.') ? relativePath : './' + relativePath;\r\n    }\r\n\r\n    /**\r\n     * Finds the module name by its path\r\n     */\r\n    static findModuleNameByPath(program: Program, targetPath: string): string | undefined {\r\n        const module = this.findModuleByPath(program, targetPath);\r\n        if (!module) return undefined;\r\n\r\n        // Try to get name from metadata first, then fallback to path-based name\r\n        const metadataName = module.metadata?.name as string | undefined;\r\n        if (metadataName) return metadataName;\r\n\r\n        // Extract name from path (remove extension and path separators)\r\n        const baseName = path.basename(targetPath, path.extname(targetPath));\r\n        return baseName === 'index' ? path.basename(path.dirname(targetPath)) : baseName;\r\n    }\r\n\r\n    /**\r\n     * Normalizes a path for consistent comparison\r\n     */\r\n    static normalizePath(filePath: string): string {\r\n        return path.normalize(filePath).replace(/\\\\/g, '/');\r\n    }\r\n}","// BaseValidator.ts — Base validator interface and types for all validators\r\n//\r\n// Developed with ❤️ by Maysara.\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\r\n\r\n    import * as AST                             from '@je-es/ast';\r\n    import { DiagCode }                         from '../components/DiagnosticManager';\r\n    import { DebugKind }                        from '../components/DebugManager';\r\n    import { AnalysisPhase }                    from '../components/ContextTracker';\r\n    import { AnalysisConfig }                   from '../ast-analyzer';\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\r\n\r\n    /** Abstract phase base class */\r\n    export abstract class PhaseBase {\r\n        protected constructor(\r\n            protected readonly phase    : AnalysisPhase,\r\n            protected readonly config   : AnalysisConfig,\r\n        ) {\r\n        }\r\n\r\n        abstract reset(): void;\r\n\r\n        abstract handle(program: AST.Program): boolean;\r\n\r\n        abstract logStatistics(): void;\r\n\r\n        reportError(code: DiagCode, message: string, span?: AST.Span): void {\r\n            this.config.services.diagnosticManager.reportError(code, message, span);\r\n        }\r\n\r\n        reportWarning(code: DiagCode, message: string, span?: AST.Span): void {\r\n            this.config.services.diagnosticManager.reportWarning(code, message, span);\r\n        }\r\n\r\n        reportInfo(code: DiagCode, message: string, span?: AST.Span): void {\r\n            this.config.services.diagnosticManager.reportInfo(code, message, span);\r\n        }\r\n\r\n        log(kind: DebugKind = 'verbose', message: string ) {\r\n            this.config.services.debugManager.log(kind, message);\r\n        }\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// SymbolResolver.ts – Complete Symbol resolution phase\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as AST                 from '@je-es/ast';\n    import { AnalysisPhase, ExpressionContext }\n                                    from '../components/ContextTracker';\n    import { DiagCode }             from '../components/DiagnosticManager';\n    import { Scope, Symbol, SymbolKind, ScopeKind }\n                                    from '../components/ScopeManager';\n    import { PathUtils }            from '../utils/PathUtils';\n    import { PhaseBase }            from '../interfaces/PhaseBase';\n    import { AnalysisConfig }       from '../ast-analyzer';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    interface ResolutionContext {\n        currentModule               : string;\n        moduleStack                 : string[];\n        cache             : Map<string, Symbol | null>;\n    }\n\n    interface FieldContext {\n        currentFieldIndex           : number;\n        parameters                  : Array<{ name: string; index: number }>;\n    }\n\n    interface ResolutionStats {\n        modulesProcessed            : number;\n        totalSymbols                : number;\n        resolvedSymbols             : number;\n        cachedResolutions           : number;\n        forwardReferences           : number;\n        selfReferences              : number;\n        importResolutions           : number;\n        structMethodsResolved       : number;\n        enumVariantsResolved        : number;\n        memberAccessResolved        : number;\n        anonymousTypesResolved      : number;\n        visibilityChecks            : number;\n        errors                      : number;\n        startTime                   : number;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class SymbolResolver extends PhaseBase {\n\n        // ┌──────────────────────────────── INIT ────────────────────────────────┐\n\n            private stats                   : ResolutionStats           = this.initStats();\n            private resolutionCtx           : ResolutionContext         = this.initResolutionContext();\n            private currentIsStaticMethod   : boolean               = false;\n            private currentStructScope      : Scope | null          = null;\n\n            constructor( config : AnalysisConfig ) {\n                super(AnalysisPhase.Resolution, config);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ────────────────────────────────┐\n\n            handle(): boolean {\n                try {\n                    this.log('verbose', 'Starting symbol resolution phase...');\n                    this.stats.startTime = Date.now();\n\n                    if (!this.init()) return false;\n                    if (!this.resolveAllModules()) return false;\n\n                    this.logStatistics();\n                    return !this.config.services.diagnosticManager.hasErrors();\n\n                } catch (error) {\n                    this.log('errors', `Fatal error during symbol resolution: ${error}`);\n                    this.reportError(DiagCode.INTERNAL_ERROR, `Fatal error during symbol resolution: ${error}`);\n                    return false;\n                }\n            }\n\n            reset(): void {\n                this.stats          = this.initStats();\n                this.resolutionCtx  = this.initResolutionContext();\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌────────────────────────── [1] Program Level ─────────────────────────┐\n\n            private resolveAllModules(): boolean {\n                this.log('verbose', 'Resolving symbols from all modules...');\n                const globalScope = this.config.services.scopeManager.getCurrentScope();\n\n                for (const [moduleName, module] of this.config.program!.modules) {\n                    this.config.services.contextTracker.pushContextSpan({ start: 0, end: 0 });\n                    try {\n                        if (!this.resolveModule(moduleName, module, globalScope)) {\n                            this.log('errors', `Failed to resolve module ${moduleName}, continuing...`);\n                        }\n                        this.stats.modulesProcessed++;\n                    } finally {\n                        this.config.services.contextTracker.popContextSpan();\n                    }\n                }\n\n                return true;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌────────────────────────── [2] Module Level ──────────────────────────┐\n\n            private resolveModule(moduleName: string, module: AST.Module, parentScope: Scope): boolean {\n                this.log('symbols', `Resolving module '${moduleName}'`);\n\n                try {\n                    this.config.services.contextTracker.setModuleName(moduleName);\n\n                    if (typeof module.metadata?.path === 'string') {\n                        this.config.services.contextTracker.setModulePath(module.metadata.path);\n                    }\n\n                    this.enterModuleContext(moduleName, module);\n\n                    const moduleScope = this.findModuleScope(moduleName);\n                    if (!moduleScope) {\n                        this.reportError(DiagCode.MODULE_SCOPE_NOT_FOUND, `Module scope for '${moduleName}' not found`);\n                        return false;\n                    }\n\n                    this.config.services.scopeManager.setCurrentScope(moduleScope.id);\n                    this.config.services.contextTracker.setScope(moduleScope.id);;\n\n                    this.resetDeclaredFlags(moduleScope);\n\n                    for (const statement of module.statements) {\n                        this.resolveStmt(statement, moduleScope, moduleName);\n                    }\n\n                    this.exitModuleContext();\n                    return true;\n                } catch (error) {\n                    this.reportError(DiagCode.INTERNAL_ERROR, `Failed to resolve module '${moduleName}': ${error}`);\n                    return false;\n                }\n            }\n\n            private resetDeclaredFlags(scope: Scope): void {\n                for (const [_, symbol] of scope.symbols) {\n                    if (symbol.kind !== SymbolKind.Use && symbol.kind !== SymbolKind.Parameter) {\n                        symbol.declared = false;\n                    }\n                }\n\n                const childScopes = this.config.services.scopeManager.getAllScopes().filter(s => s.parent === scope.id);\n                for (const childScope of childScopes) {\n                    this.resetDeclaredFlags(childScope);\n                }\n            }\n\n            private enterModuleContext(moduleName: string, module: AST.Module): void {\n                this.resolutionCtx.moduleStack.push(this.resolutionCtx.currentModule);\n                this.resolutionCtx.currentModule = moduleName;\n                this.config.services.contextTracker.setModuleName(moduleName);\n                if (typeof module.metadata?.path === 'string') {\n                    this.config.services.contextTracker.setModulePath(module.metadata.path);\n                }\n            }\n\n            private exitModuleContext(): void {\n                const previousModule = this.resolutionCtx.moduleStack.pop();\n                this.resolutionCtx.currentModule = previousModule || '';\n            }\n\n            private findModuleScope(moduleName: string): Scope | null {\n                const moduleScope = this.config.services.scopeManager.findScopeByName(moduleName, ScopeKind.Module);\n                if (!moduleScope) {\n                    this.reportError(DiagCode.MODULE_SCOPE_NOT_FOUND, `Module scope for '${moduleName}' not found`);\n                }\n                return moduleScope;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [3] Stmt Level ───────────────────────────┐\n\n            private resolveStmt(stmt: AST.StmtNode, currentScope: Scope, moduleName?: string): void {\n                if (!stmt) {\n                    this.reportError(DiagCode.ANALYSIS_ERROR, 'Found null statement during resolution');\n                    return;\n                }\n\n                this.log('verbose', `Resolving ${stmt.kind} statement`);\n                this.config.services.contextTracker.pushContextSpan(stmt.span);\n\n                try {\n                    this.config.services.scopeManager.withScope(currentScope.id, () => {\n                        this.config.services.contextTracker.withSavedState(() => {\n                            this.config.services.contextTracker.setScope(currentScope.id);\n                            this.processStmt(stmt, currentScope, moduleName);\n                        });\n                    });\n                } catch (error) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Failed to resolve ${stmt.kind} statement: ${error}`,\n                        stmt.span\n                    );\n                } finally {\n                    this.config.services.contextTracker.popContextSpan();\n                }\n            }\n\n            private processStmt(stmt: AST.StmtNode, currentScope: Scope, moduleName?: string): void {\n                const nodeGetter = this.getNodeGetter(stmt);\n                if (!nodeGetter) {\n                    this.reportError(DiagCode.INTERNAL_ERROR, `Invalid AST: ${stmt.kind} node is null`);\n                    return;\n                }\n\n                switch (stmt.kind) {\n                    case 'Block':\n                        this.handleBlockStmt(stmt.getBlock()!, currentScope, moduleName);\n                        break;\n                    case 'Test':\n                        this.handleTestStmt(stmt.getTest()!, currentScope, moduleName);\n                        break;\n                    case 'Use':\n                        this.handleUseStmt(stmt.getUse()!, currentScope, moduleName);\n                        break;\n                    case 'Def':\n                        this.handleDefStmt(stmt.getDef()!, currentScope, moduleName);\n                        break;\n                    case 'Let':\n                        this.handleLetStmt(stmt.getLet()!, currentScope, moduleName);\n                        break;\n                    case 'Func':\n                        this.handleFuncStmt(stmt.getFunc()!, currentScope, moduleName);\n                        break;\n                    case 'While':\n                    case 'Do':\n                    case 'For':\n                        this.handleLoopStmt(stmt, currentScope, moduleName);\n                        break;\n                    case 'Return':\n                    case 'Defer':\n                    case 'Throw':\n                        this.handleControlflowStmt(stmt, currentScope, moduleName);\n                        break;\n                    case 'Expression':\n                        this.resolveExprStmt(stmt.getExpr()!);\n                        break;\n                }\n            }\n\n            private getNodeGetter(stmt: AST.StmtNode): (() => any) | null {\n                switch (stmt.kind) {\n                    case 'Def'          : return () => stmt.getDef();\n                    case 'Use'          : return () => stmt.getUse();\n                    case 'Let'          : return () => stmt.getLet();\n                    case 'Func'         : return () => stmt.getFunc();\n                    case 'Block'        : return () => stmt.getBlock();\n                    case 'Return'       : return () => stmt.getReturn();\n                    case 'Defer'        : return () => stmt.getDefer();\n                    case 'Throw'        : return () => stmt.getThrow();\n                    case 'Expression'   : return () => stmt.getExpr();\n                    case 'While'        :\n                    case 'Do'           :\n                    case 'For'          : return () => stmt.getLoop();\n                    case 'Break'        : return () => stmt.getBreak();\n                    case 'Continue'     : return () => stmt.getContinue();\n                    case 'Test'         : return () => stmt.getTest();\n                    default             : return null;\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────── [3.1] BLOCK ─────────────────────────────┐\n\n            private handleBlockStmt(blockNode: AST.BlockStmtNode, scope?: Scope, moduleName?: string): void {\n                this.resolveBlockStmt(blockNode);\n            }\n\n            private resolveBlockStmt(block: AST.BlockStmtNode): void {\n                this.log('symbols', 'Resolving block');\n\n                const blockScope = this.config.services.scopeManager.findChildScopeByName('block', ScopeKind.Block);\n                if (blockScope) {\n                    this.config.services.contextTracker.withSavedState(() => {\n                        this.config.services.contextTracker.setScope(blockScope.id);\n\n                        this.config.services.scopeManager.withScope(blockScope.id, () => {\n                            for (const stmt of block.stmts) {\n                                this.resolveStmt(stmt, blockScope);\n                            }\n                        });\n                    });\n                }\n            }\n\n            private handleTestStmt(testNode: AST.TestStmtNode, scope?: Scope, moduleName?: string): void {\n                this.resolveBlockStmt(testNode.block);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.2] USE ──────────────────────────────┐\n\n            private handleUseStmt(useNode: AST.UseStmtNode, scope?: Scope, moduleName?: string): void {\n                this.resolveUseStmt(useNode);\n            }\n\n            private resolveUseStmt(useNode: AST.UseStmtNode): void {\n                this.log('symbols', 'Resolving use statement');\n                this.config.services.contextTracker.pushContextSpan(useNode.span);\n\n                try {\n                    if (useNode.path) {\n                        this.resolveModuleImport(useNode);\n                    } else {\n                        this.resolveLocalUse(useNode);\n                    }\n                    this.stats.importResolutions++;\n                } catch (error) {\n                    this.reportError(DiagCode.ANALYSIS_ERROR, `Failed to resolve use statement: ${error}`, useNode.span);\n                } finally {\n                    this.config.services.contextTracker.popContextSpan();\n                }\n            }\n\n            private resolveModuleImport(useNode: AST.UseStmtNode): void {\n                if (!this.config.program || !useNode.path) {\n                    this.reportError(DiagCode.MODULE_NOT_FOUND, 'Invalid import: missing path', useNode.span);\n                    return;\n                }\n\n                const currentModule = this.config.program.modules.get(this.resolutionCtx.currentModule);\n                const currentModulePath = currentModule?.metadata?.path as string | undefined;\n\n                // ✅ Handle wildcard import\n                if (!useNode.targetArr) {\n                    if (!useNode.alias) {\n                        this.reportError(\n                            DiagCode.ANALYSIS_ERROR,\n                            `Wildcard import requires an alias`,\n                            useNode.span\n                        );\n                        return;\n                    }\n\n                    const symbolName = useNode.alias.name;\n                    const existingSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(symbolName);\n\n                    if (!existingSymbol || existingSymbol.kind !== SymbolKind.Use) {\n                        return;\n                    }\n\n                    if (!PathUtils.validatePath(this.config.program, useNode.path, currentModulePath)) {\n                        return;\n                    }\n\n                    const resolvedPath = PathUtils.resolveModulePath(this.config.program, useNode.path, currentModulePath);\n                    const targetModuleName = PathUtils.findModuleNameByPath(this.config.program, resolvedPath);\n\n                    if (!targetModuleName) {\n                        this.reportError(DiagCode.MODULE_NOT_FOUND, `Could not resolve module name for path: ${useNode.path}`, useNode.span);\n                        return;\n                    }\n\n                    const targetModuleScope = this.findModuleScope(targetModuleName);\n                    if (!targetModuleScope) {\n                        this.reportError(DiagCode.MODULE_SCOPE_NOT_FOUND, `Could not find scope for module: ${targetModuleName}`, useNode.span);\n                        return;\n                    }\n\n                    // Mark as declared and resolved\n                    existingSymbol.declared = true;\n                    existingSymbol.type = AST.TypeNode.asIdentifier(useNode.span, targetModuleName);\n\n                    this.log('verbose', `Resolved wildcard import from '${targetModuleName}' as '${symbolName}'`);\n                    return;\n                }\n\n                // Only report MODULE_NOT_FOUND if it wasn't already reported in collection phase\n                const symbolName = useNode.alias ? useNode.alias.name : useNode.targetArr[useNode.targetArr.length - 1].name;\n                const existingSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(symbolName);\n\n                if (!existingSymbol || existingSymbol.kind !== SymbolKind.Use) {\n                    // Symbol wasn't collected, so module wasn't found in collection phase\n                    // Don't report duplicate error\n                    return;\n                }\n\n                if (!PathUtils.validatePath(this.config.program, useNode.path, currentModulePath)) {\n                    // Only report if this is a new error case\n                    if (!existingSymbol.importSource) {\n                        this.reportError(DiagCode.MODULE_NOT_FOUND, `Module not found: ${useNode.path}`, useNode.span);\n                    }\n                    return;\n                }\n\n                const resolvedPath = PathUtils.resolveModulePath(this.config.program, useNode.path, currentModulePath);\n                const targetModuleName = PathUtils.findModuleNameByPath(this.config.program, resolvedPath);\n\n                if (!targetModuleName) {\n                    this.reportError(DiagCode.MODULE_NOT_FOUND, `Could not resolve module name for path: ${useNode.path}`, useNode.span);\n                    return;\n                }\n\n                const targetModuleScope = this.findModuleScope(targetModuleName);\n                if (!targetModuleScope) {\n                    this.reportError(DiagCode.MODULE_SCOPE_NOT_FOUND, `Could not find scope for module: ${targetModuleName}`, useNode.span);\n                    return;\n                }\n\n                this.resolveModuleWithScope(useNode, targetModuleName, targetModuleScope);\n            }\n\n            private resolveModuleWithScope(useNode: AST.UseStmtNode, targetModuleName: string, targetModuleScope: Scope): void {\n                const originalScope = this.config.services.scopeManager.getCurrentScope();\n                const originalContext = this.saveModuleContext();\n\n                try {\n                    this.switchToTargetModule(targetModuleName, targetModuleScope);\n                    const targetSymbol = this.resolveImportTarget(useNode);\n                    if (targetSymbol) {\n                        this.propagateImportType(useNode, targetSymbol, originalScope);\n                    }\n                } finally {\n                    this.restoreModuleContext(originalContext, originalScope);\n                }\n            }\n\n            private resolveLocalUse(useNode: AST.UseStmtNode): void {\n                // ✅ Wildcard local use doesn't make sense\n                if (!useNode.targetArr) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Wildcard import only supported for module imports (use * as x from \"...\")`,\n                        useNode.span\n                    );\n                    return;\n                }\n\n                const targetName = useNode.targetArr[0].name;\n                const targetSymbol = this.config.services.scopeManager.lookupSymbol(targetName);\n\n                if (targetSymbol && !targetSymbol.declared) {\n                    this.reportError(\n                        DiagCode.USED_BEFORE_DECLARED,\n                        `Symbol '${targetName}' used before declaration`,\n                        useNode.targetArr[0].span\n                    );\n                    return;\n                }\n\n                this.resolveExprStmt(this.identOrMemberAccess(useNode.targetArr));\n                if (useNode.alias) {\n                    this.markAliasAsDeclared(useNode.alias);\n                }\n            }\n\n            private identOrMemberAccess(nodes: AST.IdentNode[]): AST.ExprNode {\n                // ✅ Safety check for empty array\n                if (nodes.length === 0) {\n                    throw new Error('Cannot create identifier expression from empty array');\n                }\n\n                const base = AST.ExprNode.asIdent(nodes[0].span, nodes[0].name, nodes[0].builtin);\n                if (nodes.length === 1) return base;\n                return AST.ExprNode.asMemberAccess(nodes[0].span, base, this.identOrMemberAccess(nodes.slice(1)));\n            }\n\n            private saveModuleContext() {\n                return {\n                    moduleName: this.config.services.contextTracker.getModuleName(),\n                    modulePath: this.config.services.contextTracker.getModulePath()\n                };\n            }\n\n            private switchToTargetModule(targetModule: string, targetModuleScope: Scope): void {\n                this.config.services.scopeManager.setCurrentScope(targetModuleScope.id);\n                this.config.services.contextTracker.setModuleName(targetModule);\n                const targetModulePath = this.config.program!.modules.get(targetModule)?.metadata?.path;\n                if (targetModulePath) {\n                    this.config.services.contextTracker.setModulePath(targetModulePath as string);\n                }\n            }\n\n            private restoreModuleContext(originalContext: any, originalScope: Scope): void {\n                this.config.services.contextTracker.setModuleName(originalContext.moduleName);\n                this.config.services.contextTracker.setModulePath(originalContext.modulePath);\n                this.config.services.scopeManager.setCurrentScope(originalScope.id);\n            }\n\n            private resolveImportTarget(useNode: AST.UseStmtNode): Symbol | null {\n                // ✅ Handle wildcard import\n                if (!useNode.targetArr) {\n                    // For wildcard, just check module exists (already validated in resolveModuleImport)\n                    if (!useNode.alias) {\n                        this.reportError(\n                            DiagCode.ANALYSIS_ERROR,\n                            'Wildcard import requires an alias',\n                            useNode.span\n                        );\n                        return null;\n                    }\n\n                    // Return a synthetic \"module namespace\" symbol\n                    // The actual exported symbols are validated during member access\n                    const moduleSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(useNode.alias.name);\n                    if (moduleSymbol) {\n                        moduleSymbol.declared = true;\n                    }\n                    return moduleSymbol;\n                }\n\n                const targetName = useNode.targetArr[0].name;\n                if (!targetName) return null;\n\n                const targetSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(targetName);\n                if (targetSymbol) {\n                    targetSymbol.declared = true;\n\n                    if (useNode.targetArr.length > 1) {\n                        let currentSymbol: Symbol | null = targetSymbol;\n\n                        for (let i = 1; i < useNode.targetArr.length; i++) {\n                            const memberName = useNode.targetArr[i].name;\n\n                            if (!currentSymbol || !currentSymbol.type) {\n                                this.reportError(\n                                    DiagCode.SYMBOL_NOT_FOUND,\n                                    `Cannot resolve member path: ${useNode.targetArr.slice(0, i + 1).map((t:AST.IdentNode) => t.name).join('.')}`,\n                                    useNode.targetArr[i].span\n                                );\n                                return null;\n                            }\n\n                            const memberSymbol = this.resolveMemberInType(currentSymbol.type, memberName);\n                            if (!memberSymbol) {\n                                this.reportError(\n                                    DiagCode.SYMBOL_NOT_FOUND,\n                                    `Member '${memberName}' not found in type`,\n                                    useNode.targetArr[i].span\n                                );\n                                return null;\n                            }\n\n                            currentSymbol = memberSymbol;\n                            currentSymbol.used = true;\n                        }\n\n                        return currentSymbol;\n                    }\n\n                    return targetSymbol;\n                }\n                return null;\n            }\n\n            private resolveMemberInType(type: AST.TypeNode, memberName: string): Symbol | null {\n                // Unwrap optional types first\n                if (type.kind === 'optional') {\n                    const optional = type.getOptional()!;\n                    return this.resolveMemberInType(optional.target, memberName);\n                }\n\n                // Handle struct types - IMPROVED\n                if (type.kind === 'struct') {\n                    const struct = type.getStruct()!;\n                    const scopeId = struct.metadata?.scopeId as number | undefined;\n                    if (scopeId !== undefined) {\n                        const typeScope = this.config.services.scopeManager.getScope(scopeId);\n                        // First check for fields\n                        const fieldSymbol = typeScope.symbols.get(memberName);\n                        if (fieldSymbol && fieldSymbol.kind === SymbolKind.StructField) {\n                            return fieldSymbol;\n                        }\n\n                        // Then check for methods\n                        const methodSymbol = typeScope.symbols.get(memberName);\n                        if (methodSymbol && methodSymbol.kind === SymbolKind.Function) {\n                            return methodSymbol;\n                        }\n                    }\n                    return null;\n                }\n\n                // Handle enum types\n                if (type.kind === 'enum') {\n                    const enumType = type.getEnum()!;\n                    const scopeId = enumType.metadata?.scopeId as number | undefined;\n                    if (scopeId !== undefined) {\n                        const typeScope = this.config.services.scopeManager.getScope(scopeId);\n                        const variantSymbol = typeScope.symbols.get(memberName);\n                        if (variantSymbol && variantSymbol.kind === SymbolKind.EnumVariant) {\n                            return variantSymbol;\n                        }\n                    }\n                    return null;\n                }\n\n                // Handle identifier types (type aliases)\n                if (type.kind === 'ident') {\n                    const ident = type.getIdent()!;\n                    const typeSymbol = this.config.services.scopeManager.lookupSymbol(ident.name);\n                    if (typeSymbol?.type) {\n                        return this.resolveMemberInType(typeSymbol.type, memberName);\n                    }\n                }\n\n                return null;\n            }\n\n            private propagateImportType(useNode: AST.UseStmtNode, targetSymbol: Symbol, originalScope: Scope): void {\n                // ✅ Handle both wildcard and specific imports\n                const importName = useNode.alias \n                    ? useNode.alias.name \n                    : useNode.targetArr \n                        ? useNode.targetArr[useNode.targetArr.length - 1].name\n                        : '<invalid>';\n                \n                if (!importName || importName === '<invalid>') return;\n\n                const importSymbol = originalScope.symbols.get(importName);\n                if (importSymbol) {\n                    // ✅ For wildcard, type points to the module itself (as identifier)\n                    // For specific imports, type is the actual symbol type\n                    importSymbol.type = targetSymbol.type;\n                    importSymbol.declared = true;\n                }\n            }\n\n            private markAliasAsDeclared(alias: AST.IdentNode): void {\n                const aliasSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(alias.name);\n                if (aliasSymbol) {\n                    aliasSymbol.declared = true;\n                    this.config.services.contextTracker.startDeclaration(alias.name, aliasSymbol.id, 'let', alias.span, this.config.services.scopeManager.getCurrentScope().id);\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.3] DEF ──────────────────────────────┐\n\n            private handleDefStmt(defNode: AST.DefStmtNode, scope?: Scope, moduleName?: string): void {\n                this.resolveDefStmt(defNode);\n            }\n\n            private resolveDefStmt(defNode: AST.DefStmtNode): void {\n                this.log('symbols', `Resolving definition '${defNode.ident.name}'`);\n\n                const symbol = this.config.services.scopeManager.getSymbolInCurrentScope(defNode.ident.name);\n                if (!symbol) {\n                    this.reportError(DiagCode.INTERNAL_ERROR, `Definition symbol '${defNode.ident.name}' not found in current scope`, defNode.ident.span);\n                    return;\n                }\n\n                this.config.services.contextTracker.startDeclaration(defNode.ident.name, symbol.id, 'def', defNode.span, this.config.services.scopeManager.getCurrentScope().id);\n                symbol.declared = true;\n                this.resolveType(defNode.type, symbol);\n                this.config.services.contextTracker.completeDeclaration(symbol.id);\n                this.stats.resolvedSymbols++;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.4] LET ──────────────────────────────┐\n\n            private handleLetStmt(letNode: AST.LetStmtNode, scope?: Scope, moduleName?: string): void {\n                this.resolveLetStmt(letNode);\n            }\n\n            private resolveLetStmt(letNode: AST.LetStmtNode): void {\n                this.log('symbols', `Resolving let '${letNode.field.ident.name}'`);\n\n                const symbol = this.config.services.scopeManager.getSymbolInCurrentScope(letNode.field.ident.name);\n                if (!symbol) {\n                    this.reportError(DiagCode.INTERNAL_ERROR, `Variable symbol '${letNode.field.ident.name}' not found in current scope`, letNode.field.ident.span);\n                    return;\n                }\n\n                this.config.services.contextTracker.startDeclaration(letNode.field.ident.name, symbol.id, 'let', letNode.field.span, this.config.services.scopeManager.getCurrentScope().id);\n\n                if (letNode.field.initializer) {\n                    if (this.isConstructorExpression(letNode.field.initializer)) {\n                        const primary = letNode.field.initializer.getPrimary()!;\n                        const obj = primary.getObject()!;\n                        const constructorName = obj.ident!.name;\n\n                        const constructorSymbol = this.config.services.scopeManager.lookupSymbol(constructorName);\n                        if (constructorSymbol && constructorSymbol.type) {\n                            // ✅ Validate constructor fields\n                            const isValid = this.validateConstructorFields(obj, constructorSymbol.type);\n\n                            if (isValid) {\n                                // Set type only if validation passed\n                                symbol.type = constructorSymbol.type;\n                                letNode.field.type = constructorSymbol.type;\n                            } else {\n                                // Validation failed - abort\n                                this.config.services.contextTracker.completeDeclaration(symbol.id);\n                                return;\n                            }\n                        }\n                    } else if (letNode.field.initializer.kind === 'Primary') {\n                        const primary = letNode.field.initializer.getPrimary();\n                        if (primary && primary.kind === 'Type') {\n                            const anonType = primary.getType()!;\n                            this.resolveType(anonType, symbol);\n                            symbol.type = anonType;\n                            letNode.field.type = anonType;\n                            this.stats.anonymousTypesResolved++;\n                        }\n                    }\n\n                    // Resolve initializer expressions\n                    this.resolveVariableInitializer(letNode, symbol);\n                }\n\n                symbol.declared = true;\n\n                if (letNode.field.type && !this.resolveType(letNode.field.type, symbol, letNode.field.span)) {\n                    return;\n                }\n\n                this.config.services.contextTracker.completeDeclaration(symbol.id);\n                this.stats.resolvedSymbols++;\n            }\n\n            private isConstructorExpression(expr: AST.ExprNode): boolean {\n                if (expr.kind !== 'Primary') {\n                    return false;\n                }\n\n                const primary = expr.getPrimary();\n                if (!primary || primary.kind !== 'Object') {\n                    return false;\n                }\n\n                const obj = primary.getObject();\n                if (!obj) {\n                    return false;\n                }\n\n                // ✅ An Object is a constructor if it has an ident (the type name)\n                // Example: Point { x: 10, y: 20 }\n                //          ^^^^^              ← This is obj.ident\n                const hasConstructorName =\n                    obj.ident !== null &&\n                    obj.ident !== undefined &&\n                    typeof obj.ident.name === 'string' &&\n                    obj.ident.name.length > 0;\n\n                return hasConstructorName;\n            }\n\n            private validateConstructorFields(obj: AST.ObjectNode, type: AST.TypeNode): boolean {\n                if (type.kind !== 'struct') return true;\n\n                const struct = type.getStruct()!;\n                const scopeId = struct.metadata?.scopeId as number | undefined;\n\n                if (scopeId === undefined) {\n                    this.log('verbose', 'Cannot validate constructor: struct has no scope');\n                    return true; // Can't validate without scope\n                }\n\n                const typeScope = this.config.services.scopeManager.getScope(scopeId);\n                const providedFields = new Set<string>();\n                let hasError = false;\n\n                // ============================================================================\n                // STEP 1: Check for INVALID fields (fields that don't exist in struct)\n                // ============================================================================\n                for (const prop of obj.props) {\n                    const fieldName = prop.key.name;\n                    providedFields.add(fieldName);\n\n                    const fieldSymbol = typeScope.symbols.get(fieldName);\n\n                    if (!fieldSymbol || fieldSymbol.kind !== SymbolKind.StructField) {\n                        this.reportError(\n                            DiagCode.SYMBOL_NOT_FOUND,\n                            `Member '${fieldName}' not found in struct`,\n                            prop.key.span\n                        );\n                        hasError = true; // ✅ Mark error\n                        // ✅ Continue checking other fields to report all errors\n                    } else {\n                        // Field exists - resolve its value expression\n                        if (prop.val) {\n                            this.resolveExprStmt(prop.val);\n                        }\n                    }\n                }\n\n                // ============================================================================\n                // STEP 2: Check for MISSING required fields\n                // ============================================================================\n                for (const [fieldName, fieldSymbol] of typeScope.symbols) {\n                    // Only check struct fields (not methods)\n                    if (fieldSymbol.kind === SymbolKind.StructField) {\n                        // Field is required if: not provided AND has no default value\n                        const isRequired = !providedFields.has(fieldName) && !fieldSymbol.initialized;\n\n                        if (isRequired) {\n                            this.reportError(\n                                DiagCode.SYMBOL_NOT_FOUND,\n                                `Required field '${fieldName}' not provided in constructor`,\n                                obj.span\n                            );\n                            hasError = true; // ✅ Mark error\n                        }\n                    }\n                }\n\n                // ✅ Return false if ANY error was found\n                return !hasError;\n            }\n\n            private resolveVariableInitializer(varNode: AST.LetStmtNode, symbol: Symbol): boolean {\n                this.config.services.contextTracker.startInitialization(symbol.id);\n                this.config.services.contextTracker.enterExpression(ExpressionContext.VariableInitializer, varNode.field.initializer!.span, symbol.id);\n                this.resolveExprStmt(varNode.field.initializer!, undefined, undefined, symbol!);\n                this.config.services.contextTracker.exitExpression();\n                return true;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.5] FUNC ─────────────────────────────┐\n\n            private handleFuncStmt(funcNode: AST.FuncStmtNode, scope?: Scope, moduleName?: string): void {\n                this.resolveFuncStmt(funcNode);\n            }\n\n            private resolveFuncStmt(funcNode: AST.FuncStmtNode): void {\n                this.log('symbols', `Resolving function '${funcNode.ident.name}'`);\n\n                const funcSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(funcNode.ident.name);\n                if (!funcSymbol) {\n                    this.reportError(\n                        DiagCode.CANNOT_INFER_TYPE,\n                        `Function '${funcNode.ident.name}' symbol not found`,\n                        funcNode.span\n                    );\n                    return;\n                }\n\n                const funcScope = this.config.services.scopeManager.findChildScopeByName(funcNode.ident.name, ScopeKind.Function);\n                if (!funcScope) {\n                    this.reportError(\n                        DiagCode.CANNOT_INFER_TYPE,\n                        `Function scope for '${funcNode.ident.name}' not found`,\n                        funcNode.span\n                    );\n                    return;\n                }\n\n                this.config.services.contextTracker.startDeclaration(\n                    funcNode.ident.name,\n                    funcSymbol.id,\n                    'fn',\n                    funcNode.span,\n                    this.config.services.scopeManager.getCurrentScope().id\n                );\n                funcSymbol.declared = true;\n\n                // ✅ FIXED: Get the scope where the function is defined to check if it's in a struct\n                const funcSymbolScope = this.config.services.scopeManager.getScope(funcSymbol.scope);\n                const parentScope = funcSymbolScope.parent !== null \n                    ? this.config.services.scopeManager.getScope(funcSymbolScope.parent) \n                    : null;\n\n                const isStaticMethod = parentScope?.kind === ScopeKind.Type &&\n                                    parentScope.metadata?.typeKind === 'Struct' &&\n                                    funcNode.visibility.kind === 'Static';\n\n                // Store context for validation\n                const previousIsStaticMethod = this.currentIsStaticMethod;\n                const previousStructScope = this.currentStructScope;\n\n                this.currentIsStaticMethod = isStaticMethod;\n                this.currentStructScope = isStaticMethod ? parentScope : null;\n\n                const isStructMethod = parentScope?.kind === ScopeKind.Type &&\n                                    parentScope.metadata?.typeKind === 'Struct' &&\n                                    !(funcNode.visibility.kind === 'Static');\n\n                try {\n                    this.config.services.contextTracker.withSavedState(() => {\n                        this.config.services.scopeManager.withScope(funcScope.id, () => {\n                            // Resolve self parameter if struct method\n                            if (isStructMethod) {\n                                this.resolveSelfParameter(funcScope, parentScope!);\n                            }\n\n                            // Validate parameters\n                            this.resolveParameters(funcNode.parameters);\n\n                            // ✅ Build parameter types INCLUDING self for struct methods\n                            const paramTypes: AST.TypeNode[] = [];\n\n                            // ✅ Add self parameter type FIRST for struct methods\n                            if (isStructMethod) {\n                                const selfSymbol = funcScope.symbols.get('self');\n                                if (selfSymbol?.type) {\n                                    paramTypes.push(selfSymbol.type);\n                                } else {\n                                    // Self should always exist for struct methods\n                                    this.reportError(\n                                        DiagCode.INTERNAL_ERROR,\n                                        `Struct method '${funcNode.ident.name}' missing 'self' parameter`,\n                                        funcNode.span\n                                    );\n                                }\n                            }\n\n                            // Then add explicit parameters\n                            for (const param of funcNode.parameters) {\n                                if (param.type) {\n                                    paramTypes.push(param.type);\n                                } else {\n                                    const paramSymbol = funcScope.symbols.get(param.ident.name);\n                                    if (paramSymbol?.type) {\n                                        paramTypes.push(paramSymbol.type);\n                                    } else {\n                                        this.reportError(\n                                            DiagCode.CANNOT_INFER_TYPE,\n                                            `Cannot infer type for parameter '${param.ident.name}'`,\n                                            param.span\n                                        );\n                                        paramTypes.push(AST.TypeNode.asUndefined(param.span));\n                                    }\n                                }\n                            }\n\n                            // Resolve return type\n                            let returnType: AST.TypeNode | null = null;\n                            if (funcNode.returnType) {\n                                const tempReturnSymbol: Symbol = {\n                                    id: -1,\n                                    name: '<return-type>',\n                                    kind: SymbolKind.Variable,\n                                    type: null,\n                                    scope: funcScope.id,\n                                    contextSpan: funcNode.returnType.span,\n                                    declared: true,\n                                    initialized: true,\n                                    used: false,\n                                    isTypeChecked: false,\n                                    visibility: { kind: 'Private' },\n                                    mutability: { kind: 'Immutable' },\n                                    isExported: false\n                                };\n                                this.resolveType(funcNode.returnType, tempReturnSymbol);\n                                returnType = funcNode.returnType;\n                            }\n\n                            // Resolve and validate error type\n                            if (funcNode.errorType) {\n                                const tempErrorSymbol: Symbol = {\n                                    id: -1,\n                                    name: '<func-error-type>',\n                                    kind: SymbolKind.Variable,\n                                    type: null,\n                                    scope: funcScope.id,\n                                    contextSpan: funcNode.errorType.span,\n                                    declared: true,\n                                    initialized: true,\n                                    used: false,\n                                    isTypeChecked: false,\n                                    visibility: { kind: 'Private' },\n                                    mutability: { kind: 'Immutable' },\n                                    isExported: false\n                                };\n\n                                if (!this.resolveType(funcNode.errorType, tempErrorSymbol, funcNode.span)) {\n                                    funcSymbol.isTypeChecked = true;\n                                    return; // Exit if error type resolution fails\n                                }\n\n                                // Validate the error type identifier exists and is an error type\n                                if (funcNode.errorType.isIdent()) {\n                                    const errorIdent = funcNode.errorType.getIdent()!;\n\n                                    if (!errorIdent.builtin) {\n                                        const errorSymbol = this.config.services.scopeManager.lookupSymbol(errorIdent.name);\n\n                                        if (!errorSymbol) {\n                                            this.reportError(\n                                                DiagCode.UNDEFINED_IDENTIFIER,\n                                                `Error type '${errorIdent.name}' is not defined`,\n                                                funcNode.errorType.span\n                                            );\n                                            funcSymbol.isTypeChecked = true;\n                                            return;\n                                        }\n\n                                        // Validate it's actually an error type\n                                        if (errorSymbol.type && !errorSymbol.type.isErrset()) {\n                                            this.reportError(\n                                                DiagCode.TYPE_MISMATCH,\n                                                `'${errorIdent.name}' is not an error type`,\n                                                funcNode.errorType.span\n                                            );\n                                            funcSymbol.isTypeChecked = true;\n                                            return;\n                                        }\n                                    }\n                                }\n                            }\n\n                            // Build complete function type\n                            funcSymbol.type = AST.TypeNode.asFunction(\n                                funcNode.span,\n                                paramTypes,\n                                returnType || AST.TypeNode.asVoid(funcNode.span),\n                                funcNode.errorType\n                            );\n\n                            // Resolve function body\n                            if (funcNode.body) {\n                                this.config.services.contextTracker.enterExpression(\n                                    ExpressionContext.FunctionBody,\n                                    funcNode.body.span\n                                );\n                                this.resolveStmt(funcNode.body, funcScope);\n                                this.config.services.contextTracker.exitExpression();\n                            }\n                        });\n                    });\n\n                    if (isStructMethod) {\n                        this.stats.structMethodsResolved++;\n                    }\n                } finally {\n                    this.config.services.contextTracker.completeDeclaration(funcSymbol.id);\n                    // Restore context\n                    this.currentIsStaticMethod = previousIsStaticMethod;\n                    this.currentStructScope = previousStructScope;\n                }\n\n                funcSymbol.isTypeChecked = true;\n                this.stats.resolvedSymbols++;\n            }\n\n            private resolveSelfParameter(funcScope: Scope, structScope: Scope): void {\n                const selfSymbol = funcScope.symbols.get('self');\n                if (!selfSymbol) {\n                    this.log('verbose', `Warning: Expected 'self' parameter in struct method but not found`);\n                    return;\n                }\n\n                // Mark self as declared and used in resolution phase\n                selfSymbol.declared = true;\n\n                // Resolve self's type (should point to parent struct)\n                if (selfSymbol.type) {\n                    // Validate that the type references the correct struct\n                    if (selfSymbol.type.kind === 'ident') {\n                        const typeIdent = selfSymbol.type.getIdent()!;\n                        if (typeIdent.name !== structScope.name) {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                `Self type mismatch: expected '${structScope.name}', got '${typeIdent.name}'`,\n                                selfSymbol.contextSpan\n                            );\n                        }\n                    }\n                }\n\n                this.log('symbols', `Resolved 'self' parameter in struct method`);\n            }\n\n            // ───── PARAMS ─────\n\n            private resolveParameters(parameters: AST.FieldNode[]): void {\n                const fieldInfo = parameters.map((param, index) => ({ name: param.ident.name, index }));\n                for (let i = 0; i < parameters.length; i++) {\n                    this.resolveParameter(parameters[i], i, fieldInfo);\n                }\n            }\n\n            private resolveParameter(param: AST.FieldNode, index: number, fieldInfo: Array<{ name: string; index: number }>): void {\n                const paramSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(param.ident.name);\n                if (!paramSymbol) return;\n\n                this.config.services.contextTracker.startDeclaration(param.ident.name, paramSymbol.id, 'Param', param.span, this.config.services.scopeManager.getCurrentScope().id);\n                paramSymbol.declared = true;\n\n                if (param.type) {\n                    this.resolveType(param.type, paramSymbol);\n                }\n\n                if (param.initializer) {\n                    this.resolveParameterInitializer(param, index, fieldInfo);\n                }\n\n                this.config.services.contextTracker.completeDeclaration(paramSymbol.id);\n                this.stats.resolvedSymbols++;\n            }\n\n            private resolveParameterInitializer(param: AST.FieldNode, currentFieldIndex: number, fieldInfo: Array<{ name: string; index: number }>): void {\n                const paramSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(param.ident.name)!;\n                this.config.services.contextTracker.startInitialization(paramSymbol.id);\n                this.config.services.contextTracker.enterExpression(ExpressionContext.ParameterInitializer, param.initializer!.span, paramSymbol.id);\n\n                const parameterContext: FieldContext = { currentFieldIndex, parameters: fieldInfo };\n                this.resolveExprStmt(param.initializer!, param.span, parameterContext, paramSymbol);\n                this.config.services.contextTracker.exitExpression();\n            }\n\n            // ───── FIELDS ─────\n\n            private resolveFields(fields: AST.FieldNode[]): void {\n                const fieldInfo = fields.map((field, index) => ({ name: field.ident.name, index }));\n                for (let i = 0; i < fields.length; i++) {\n                    this.resolveField(fields[i], i, fieldInfo);\n                }\n            }\n\n            private resolveField(field: AST.FieldNode, index: number, fieldInfo: Array<{ name: string; index: number }>): void {\n                const fieldSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(field.ident.name);\n                if (!fieldSymbol) return;\n\n                this.config.services.contextTracker.startDeclaration(field.ident.name, fieldSymbol.id, 'Param', field.span, this.config.services.scopeManager.getCurrentScope().id);\n                fieldSymbol.declared = true;\n\n                if (field.type) {\n                    this.resolveType(field.type, fieldSymbol);\n                }\n\n                if (field.initializer) {\n                    this.resolveFieldInitializer(field, index, fieldInfo);\n                }\n\n                this.config.services.contextTracker.completeDeclaration(fieldSymbol.id);\n                this.stats.resolvedSymbols++;\n            }\n\n            private resolveFieldInitializer(field: AST.FieldNode, currentFieldIndex: number, fieldInfo: Array<{ name: string; index: number }>): void {\n                const fieldSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(field.ident.name)!;\n                this.config.services.contextTracker.startInitialization(fieldSymbol.id);\n                this.config.services.contextTracker.enterExpression(ExpressionContext.ParameterInitializer, field.initializer!.span, fieldSymbol.id);\n\n                const fieldContext: FieldContext = { currentFieldIndex, parameters: fieldInfo };\n                this.resolveExprStmt(field.initializer!, field.span, fieldContext, fieldSymbol);\n                this.config.services.contextTracker.exitExpression();\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌───────────────────────────── [3.6] LOOP ─────────────────────────────┐\n\n            private handleLoopStmt(stmt: AST.StmtNode, scope?: Scope, moduleName?: string): void {\n                if(stmt.getLoop === undefined) {\n                    const data = stmt;\n                    switch (stmt.kind) {\n                        case 'While' : {\n                            const src = data.source as AST.LoopStmtNode;\n                            const loop = AST.LoopStmtNode.createWhile(data.span, src.expr, src.stmt);\n                            this.resolveLoopStmt(loop);\n                            break;\n                        }\n                        case 'Do' : {\n                            const src = data.source as AST.LoopStmtNode;\n                            const loop = AST.LoopStmtNode.createDo(data.span, src.expr, src.stmt);\n                            this.resolveLoopStmt(loop);\n                            break;\n                        }\n                        case 'For' : {\n                            const src = data.source as AST.LoopStmtNode;\n                            const loop = AST.LoopStmtNode.createFor(data.span, src.expr, src.stmt);\n                            this.resolveLoopStmt(loop);\n                            break;\n                        }\n                    }\n                } else {\n                    this.resolveLoopStmt(stmt.getLoop()!);\n                }\n            }\n\n            private resolveLoopStmt(loopStmt: AST.LoopStmtNode): void {\n                this.log('symbols', 'Resolving loop statement');\n\n                const loopScope = this.config.services.scopeManager.findChildScopeByName('loop', ScopeKind.Loop);\n                if (loopScope) {\n                    this.config.services.contextTracker.withSavedState(() => {\n                        this.config.services.contextTracker.setScope(loopScope.id);\n\n                        this.config.services.scopeManager.withScope(loopScope.id, () => {\n                            if (loopStmt.kind === 'While') {\n                                if (loopStmt.expr) this.resolveExprStmt(loopStmt.expr);\n                                if (loopStmt.stmt) this.resolveStmt(loopStmt.stmt, loopScope);\n                            } else if (loopStmt.kind === 'Do') {\n                                if (loopStmt.stmt) this.resolveStmt(loopStmt.stmt, loopScope);\n                                if (loopStmt.expr) this.resolveExprStmt(loopStmt.expr);\n                            } else if (loopStmt.kind === 'For') {\n                                if (loopStmt.expr) this.resolveExprStmt(loopStmt.expr);\n                                if (loopStmt.stmt) this.resolveStmt(loopStmt.stmt, loopScope);\n                            }\n                        });\n                    });\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────── [3.7] CTRLFLOW ──────────────────────────┐\n\n            private handleControlflowStmt(stmt: AST.StmtNode, scope?: Scope, moduleName?: string): void {\n                if(stmt.getCtrlflow === undefined) {\n                    const data = stmt;\n                    switch (stmt.kind) {\n                        case 'Return' : {\n                            const src = data.source as AST.ControlFlowStmtNode;\n                            const res = AST.ControlFlowStmtNode.asReturn(data.span, src.value);\n                            this.resolveReturnStmt(res);\n                            break;\n                        }\n                        case 'Defer' : {\n                            const src = data.source as AST.ControlFlowStmtNode;\n                            const res = AST.ControlFlowStmtNode.asDefer(data.span, src.value);\n                            this.resolveDeferStmt(res);\n                            break;\n                        }\n                        case 'Throw' : {\n                            const src = data.source as AST.ControlFlowStmtNode;\n                            const res = AST.ControlFlowStmtNode.asThrow(data.span, src.value);\n                            this.resolveThrowStmt(res);\n                            break;\n                        }\n                    }\n                } else {\n                    switch (stmt.getCtrlflow()!.kind) {\n                        case 'return' : {\n                            this.resolveReturnStmt(stmt.getCtrlflow()!);\n                            break;\n                        }\n                        case 'defer' : {\n                            this.resolveDeferStmt(stmt.getCtrlflow()!);\n                            break;\n                        }\n                        case 'throw' : {\n                            this.resolveThrowStmt(stmt.getCtrlflow()!);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            private resolveReturnStmt(returnNode: AST.ControlFlowStmtNode): void {\n                this.log('symbols', 'Resolving return statement');\n                if (returnNode.value) {\n                    this.config.services.contextTracker.enterExpression(ExpressionContext.ReturnExpression, returnNode.value.span);\n                    this.resolveExprStmt(returnNode.value);\n                    this.config.services.contextTracker.exitExpression();\n                }\n            }\n\n            private resolveDeferStmt(deferNode: AST.ControlFlowStmtNode): void {\n                this.log('symbols', 'Resolving defer statement');\n                if (deferNode.value) {\n                    this.config.services.contextTracker.enterExpression(ExpressionContext.DeferExpression, deferNode.value.span);\n                    this.resolveExprStmt(deferNode.value);\n                    this.config.services.contextTracker.exitExpression();\n                }\n            }\n\n            private resolveThrowStmt(throwNode: AST.ControlFlowStmtNode): void {\n                this.log('symbols', 'Resolving throw statement');\n                if (throwNode.value) {\n                    this.config.services.contextTracker.enterExpression(ExpressionContext.ThrowExpression, throwNode.value.span);\n                    this.resolveExprStmt(throwNode.value);\n                    this.config.services.contextTracker.exitExpression();\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [4] EXPR Level ───────────────────────────┐\n\n            private resolveExprStmt(expr: AST.ExprNode, contextSpan?: AST.Span, parameterContext?: FieldContext, symbol?: Symbol): void {\n                if (!expr) return;\n\n                this.log('symbols', `Resolving expression of type ${expr.kind}`);\n                this.config.services.contextTracker.pushContextSpan(expr.span);\n\n                try {\n                    switch (expr.kind) {\n                        case 'Primary':\n                            this.resolvePrimary(expr.getPrimary()!, contextSpan, parameterContext, symbol);\n                            break;\n                        case 'Binary':\n                            this.resolveBinary(expr.getBinary()!, contextSpan, parameterContext);\n                            break;\n                        case 'Prefix':\n                            this.resolvePrefix(expr.getPrefix()!, contextSpan, parameterContext);\n                            break;\n                        case 'Postfix':\n                            this.resolvePostfix(expr.getPostfix()!, contextSpan, parameterContext);\n                            break;\n                        case 'As':\n                            this.resolveAs(expr.getAs()!, contextSpan, parameterContext);\n                            break;\n                        case 'Typeof':\n                            return this.resolveExprStmt(expr.getTypeof()!.expr, contextSpan, parameterContext);\n                        case 'Sizeof':\n                            return this.resolveExprStmt(expr.getSizeof()!.expr, contextSpan, parameterContext);\n                        case 'Orelse':\n                            this.resolveOrelse(expr.getOrelse()!, contextSpan, parameterContext);\n                            break;\n                        case 'Range':\n                            this.resolveRange(expr.getRange()!, contextSpan, parameterContext);\n                            break;\n                        case 'Try':\n                            this.resolveTry(expr.getTry()!, contextSpan, parameterContext);\n                            break;\n                        case 'Catch':\n                            this.resolveCatch(expr.getCatch()!, contextSpan, parameterContext);\n                            break;\n                        case 'If':\n                            this.resolveIf(expr.getIf()!, contextSpan, parameterContext);\n                            break;\n                        case 'Switch':\n                            this.resolveSwitch(expr.getSwitch()!, contextSpan, parameterContext);\n                            break;\n                        default:\n                            this.log('verbose', `Unhandled expression type: ${expr.kind}`);\n                            break;\n                    }\n                } finally {\n                    this.config.services.contextTracker.popContextSpan();\n                }\n            }\n\n            private resolvePrimary(primary: AST.PrimaryNode, contextSpan?: AST.Span, fieldContext?: FieldContext, symbol?: Symbol): void {\n                switch (primary.kind) {\n                    case 'Ident':\n                        this.resolveIdentifier(primary.getIdent()!, contextSpan, fieldContext);\n                        break;\n                    case 'Paren': {\n                        const paren = primary.getParen()!;\n                        if (paren.source) {\n                            this.resolveExprStmt(paren.source, contextSpan, fieldContext, symbol);\n                        }\n                        break;\n                    }\n                    case 'Literal':\n                        break;\n                    case 'Tuple':\n                        this.resolveTuple(primary.getTuple()!, contextSpan, fieldContext);\n                        break;\n                    case 'Object':\n                        this.resolveObject(primary.getObject()!, contextSpan, fieldContext);\n                        break;\n                    case 'Type': {\n                        const type = primary.getType()!;\n                        const tempSymbol: Symbol = {\n                            id: -1,\n                            name: symbol?.name ?? fieldContext?.parameters[fieldContext?.currentFieldIndex].name ?? type.getIdent()?.name ?? '<type-expr>',\n                            kind: SymbolKind.Variable,\n                            type: null,\n                            scope: this.config.services.scopeManager.getCurrentScope().id,\n                            contextSpan: type.span,\n                            declared: true,\n                            initialized: true,\n                            used: false,\n                            isTypeChecked: false,\n                            visibility: { kind: 'Private' },\n                            mutability: { kind: 'Immutable' },\n                            isExported: false\n                        };\n                        this.resolveType(type, tempSymbol, contextSpan);\n                        break;\n                    }\n                    default:\n                        this.log('verbose', `Unhandled primary type: ${primary.kind}`);\n                        break;\n                }\n            }\n\n            private resolveTuple(tuple: AST.ExprTupleNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                for (const field of tuple.fields) {\n                    this.resolveExprStmt(field, contextSpan, parameterContext);\n                }\n            }\n\n            private resolveObject(obj: AST.ObjectNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                if(obj.ident) this.resolveIdentifier(obj.ident, contextSpan, parameterContext);\n\n                for (const prop of obj.props) {\n                    if (prop.val) {\n                        this.resolveExprStmt(prop.val, contextSpan, parameterContext);\n                    }\n                }\n            }\n\n            private resolveBinary(binary: AST.BinaryNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                if (binary.left) {\n                    this.resolveExprStmt(binary.left, contextSpan, parameterContext);\n                }\n                if (binary.right) {\n                    this.resolveExprStmt(binary.right, contextSpan, parameterContext);\n                }\n            }\n\n            private resolvePrefix(prefix: AST.PrefixNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                if (prefix.expr) {\n                    this.resolveExprStmt(prefix.expr, contextSpan, parameterContext);\n                }\n            }\n\n            private resolvePostfix(postfix: AST.PostfixNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                switch (postfix.kind) {\n                    case 'Call':\n                        this.resolvePostfixCall(postfix.getCall()!, contextSpan, parameterContext);\n                        break;\n                    case 'ArrayAccess':\n                        this.resolvePostfixArrayAccess(postfix.getArrayAccess()!, contextSpan, parameterContext);\n                        break;\n                    case 'MemberAccess':\n                        this.resolvePostfixMemberAccess(postfix.getMemberAccess()!, contextSpan, parameterContext);\n                        break;\n                    case 'Increment':\n                    case 'Decrement':\n                    case 'Dereference':\n                        this.resolveExprStmt(postfix.getAsExprNode()!, contextSpan, parameterContext);\n                        break;\n                    default:\n                        this.log('verbose', `Unhandled postfix type: ${postfix.kind}`);\n                        break;\n                }\n            }\n\n            private resolvePostfixCall(call: AST.CallNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.log('symbols', 'Resolving call expression');\n                this.config.services.contextTracker.enterExpression(ExpressionContext.FunctionCall, call.span);\n\n                try {\n                    this.resolveExprStmt(call.base, call.span, parameterContext);\n\n                    const baseSymbol = this.findCallTargetSymbol(call.base);\n                    if (baseSymbol) {\n                        this.validateCallableSymbol(baseSymbol, call.base.span);\n                        baseSymbol.used = true;\n                        this.log('symbols', `Marked function '${baseSymbol.name}' as used`);\n                    }\n\n                    for (let i = 0; i < call.args.length; i++) {\n                        const arg = call.args[i];\n                        this.config.services.contextTracker.enterExpression(ExpressionContext.CallArgument, arg.span);\n                        try {\n                            this.resolveExprStmt(arg, arg.span, parameterContext);\n                        } finally {\n                            this.config.services.contextTracker.exitExpression();\n                        }\n                    }\n                } finally {\n                    this.config.services.contextTracker.exitExpression();\n                }\n            }\n\n            private resolvePostfixArrayAccess(arrayAccess: AST.ArrayAccessNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.log('symbols', 'Resolving array access');\n                this.resolveExprStmt(arrayAccess.base, contextSpan, parameterContext);\n                this.resolveExprStmt(arrayAccess.index, contextSpan, parameterContext);\n            }\n\n            private resolvePostfixMemberAccess(memberAccess: AST.MemberAccessNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.log('symbols', 'Resolving member access');\n\n                // ✅ SPECIAL CASE: 'self.member' in static method\n                if (memberAccess.base.is('Primary')) {\n                    const primary = memberAccess.base.getPrimary();\n                    if (primary?.is('Ident')) {\n                        const ident = primary.getIdent();\n                        if (ident?.name === 'self') {\n                            // ✅ In static methods, 'self' refers to the TYPE\n                            // Resolve the target member in the struct scope\n                            // The actual validation (static vs instance) happens in TypeValidator\n                            this.resolveExprStmt(memberAccess.target, contextSpan, parameterContext);\n\n                            // Mark the member as resolved for statistics\n                            this.stats.memberAccessResolved++;\n                            return;\n                        }\n                    }\n                }\n\n                // Resolve base first\n                this.resolveExprStmt(memberAccess.base, contextSpan, parameterContext);\n\n                // Get base symbol\n                const baseSymbol = this.findMemberAccessBaseSymbol(memberAccess.base);\n\n                if (!baseSymbol) {\n                    // ✅ Special check: if base is 'self' in static method, allow it\n                    // The error will be reported in TypeValidator with proper context\n                    if (memberAccess.base.is('Primary')) {\n                        const primary = memberAccess.base.getPrimary();\n                        if (primary?.is('Ident')) {\n                            const ident = primary.getIdent();\n                            if (ident?.name === 'self' && this.currentIsStaticMethod) {\n                                // Don't report error here - let TypeValidator handle it\n                                this.stats.memberAccessResolved++;\n                                return;\n                            }\n                        }\n                    }\n\n                    this.reportError(\n                        DiagCode.TYPE_INFERENCE_FAILED,\n                        `Cannot resolve base for member access`,\n                        memberAccess.base.span\n                    );\n                    return;\n                }\n\n                this.stats.memberAccessResolved++;\n            }\n\n            private findMemberAccessBaseSymbol(baseExpr: AST.ExprNode): Symbol | null {\n                // Handle identifier base\n                if (baseExpr.kind === 'Primary') {\n                    const primary = baseExpr.getPrimary();\n                    if (primary && primary.kind === 'Ident') {\n                        const ident = primary.getIdent();\n                        if (ident) {\n                            return this.config.services.scopeManager.lookupSymbol(ident.name);\n                        }\n                    }\n                }\n\n                // Handle postfix expressions (member access, dereference, etc.)\n                if (baseExpr.kind === 'Postfix') {\n                    const postfix = baseExpr.getPostfix();\n                    if (!postfix) return null;\n\n                    // ✅ Handle dereference - recurse on the dereferenced expression\n                    if (postfix.kind === 'Dereference') {\n                        const derefExpr = postfix.getAsExprNode();\n                        if (derefExpr) {\n                            return this.findMemberAccessBaseSymbol(derefExpr);\n                        }\n                    }\n\n                    // Handle nested member access\n                    if (postfix.kind === 'MemberAccess') {\n                        const member = postfix.getMemberAccess()!;\n                        return this.findMemberAccessBaseSymbol(member.base);\n                    }\n                }\n\n                return null;\n            }\n\n            private resolveSelfMemberAccess(memberAccess: AST.MemberAccessNode, selfSymbol: Symbol): void {\n                // Get the FUNCTION scope (where self lives)\n                let currentScope = this.config.services.scopeManager.getCurrentScope();\n\n                // Walk up to find the function scope\n                while (currentScope && currentScope.kind !== ScopeKind.Function) {\n                    const parent = this.config.services.scopeManager.getScopeParent(currentScope.id);\n                    if (!parent) break;\n                    currentScope = parent;\n                }\n\n                if (!currentScope || currentScope.kind !== ScopeKind.Function) {\n                    this.reportError(DiagCode.UNDEFINED_IDENTIFIER, \"Cannot use 'self' outside of method context\", memberAccess.span);\n                    return;\n                }\n\n                // Get parent struct scope\n                const parentScope = this.config.services.scopeManager.getScopeParent(currentScope.id);\n                if (!parentScope || parentScope.kind !== ScopeKind.Type) {\n                    this.reportError(DiagCode.UNDEFINED_IDENTIFIER, \"Cannot use 'self' outside of struct method\", memberAccess.span);\n                    return;\n                }\n\n                // Resolve member in struct scope\n                if (memberAccess.target.isIdent()) {\n                    const memberIdent = memberAccess.target.getIdent()!;\n                    const memberSymbol = parentScope.symbols.get(memberIdent.name);\n\n                    if (!memberSymbol) {\n                        this.reportError(\n                            DiagCode.SYMBOL_NOT_FOUND,\n                            `Member '${memberIdent.name}' not found in struct '${parentScope.name}'`,\n                            memberIdent.span\n                        );\n                        return;\n                    }\n\n                    if (memberSymbol.kind !== SymbolKind.StructField) {\n                        this.reportError(\n                            DiagCode.SYMBOL_NOT_FOUND,\n                            `'${memberIdent.name}' is not a field`,\n                            memberIdent.span\n                        );\n                        return;\n                    }\n\n                    memberSymbol.used = true;\n                    this.log('symbols', `Resolved self.${memberIdent.name} in struct method`);\n                }\n            }\n\n            private resolveAs(asNode: AST.AsNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.resolveExprStmt(asNode.base, contextSpan, parameterContext);\n                const tempSymbol: Symbol = {\n                    id: -1,\n                    name: '<as-expr>',\n                    kind: SymbolKind.Variable,\n                    type: null,\n                    scope: this.config.services.scopeManager.getCurrentScope().id,\n                    contextSpan: asNode.span,\n                    declared: true,\n                    initialized: true,\n                    used: false,\n                    isTypeChecked: false,\n                    visibility: { kind: 'Private' },\n                    mutability: { kind: 'Immutable' },\n                    isExported: false\n                };\n                this.resolveType(asNode.type, tempSymbol, contextSpan);\n            }\n\n            private resolveOrelse(orelse: AST.OrelseNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.resolveExprStmt(orelse.left, contextSpan, parameterContext);\n                this.resolveExprStmt(orelse.right, contextSpan, parameterContext);\n            }\n\n            private resolveRange(range: AST.RangeNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                if (range.leftExpr) this.resolveExprStmt(range.leftExpr, contextSpan, parameterContext);\n                if (range.rightExpr) this.resolveExprStmt(range.rightExpr, contextSpan, parameterContext);\n            }\n\n            private resolveTry(tryNode: AST.TryNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.resolveExprStmt(tryNode.expr, contextSpan, parameterContext);\n            }\n\n            private resolveCatch(catchNode: AST.CatchNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.resolveExprStmt(catchNode.leftExpr, contextSpan, parameterContext);\n\n                const exprScope = this.config.services.scopeManager.findChildScopeByName('expr', ScopeKind.Expression);\n                if (exprScope) {\n                    this.config.services.contextTracker.withSavedState(() => {\n                        this.config.services.contextTracker.setScope(exprScope.id);\n\n                        this.config.services.scopeManager.withScope(exprScope.id, () => {\n                            this.resolveStmt(catchNode.rightStmt, exprScope);\n                        });\n                    });\n                } else {\n                    this.resolveStmt(catchNode.rightStmt, this.config.services.scopeManager.getCurrentScope());\n                }\n            }\n\n            private resolveIf(ifNode: AST.IfNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.config.services.contextTracker.enterExpression(ExpressionContext.ConditionExpression, ifNode.condExpr.span);\n                this.resolveExprStmt(ifNode.condExpr, contextSpan, parameterContext);\n                this.config.services.contextTracker.exitExpression();\n\n                const currentScope = this.config.services.scopeManager.getCurrentScope();\n                this.resolveStmt(ifNode.thenStmt, currentScope);\n                if (ifNode.elseStmt) {\n                    this.resolveStmt(ifNode.elseStmt, currentScope);\n                }\n            }\n\n            private resolveSwitch(switchNode: AST.SwitchNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.config.services.contextTracker.enterExpression(ExpressionContext.ConditionExpression, switchNode.condExpr.span);\n                this.resolveExprStmt(switchNode.condExpr, contextSpan, parameterContext);\n                this.config.services.contextTracker.exitExpression();\n\n                const currentScope = this.config.services.scopeManager.getCurrentScope();\n                for (const switchCase of switchNode.cases) {\n                    if (switchCase.expr) {\n                        this.resolveExprStmt(switchCase.expr, contextSpan, parameterContext);\n                    }\n                    if (switchCase.stmt) {\n                        this.resolveStmt(switchCase.stmt, currentScope);\n                    }\n                }\n\n                if (switchNode.defCase) {\n                    this.resolveStmt(switchNode.defCase.stmt, currentScope);\n                }\n            }\n\n            private findCallTargetSymbol(baseExpr: AST.ExprNode): Symbol | null {\n                if (baseExpr.kind === 'Primary') {\n                    const primary = baseExpr.getPrimary();\n                    if (primary && primary.kind === 'Ident') {\n                        const ident = primary.getIdent();\n                        if (ident) {\n                            return this.config.services.scopeManager.lookupSymbol(ident.name);\n                        }\n                    }\n                }\n                return null;\n            }\n\n            private validateCallableSymbol(symbol: Symbol, span?: AST.Span): void {\n                if (symbol.kind === SymbolKind.Function || (symbol.metadata as any)?.callable === true) {\n                    return;\n                }\n\n                if (symbol.type?.kind === 'function') {\n                    return;\n                }\n\n                if (symbol.kind === SymbolKind.Use && symbol.importSource) {\n                    const sourceModuleScope = this.config.services.scopeManager.findScopeByName(symbol.importSource, ScopeKind.Module);\n                    if (sourceModuleScope) {\n                        let sourceSymbol = sourceModuleScope.symbols.get(symbol.name);\n\n                        if (!sourceSymbol) {\n                            for (const [_, potentialSource] of sourceModuleScope.symbols) {\n                                if (potentialSource.kind === SymbolKind.Function ||\n                                    (potentialSource.metadata as any)?.callable === true) {\n                                    sourceSymbol = potentialSource;\n                                    break;\n                                }\n                            }\n                        }\n\n                        if (sourceSymbol) {\n                            if (sourceSymbol.kind === SymbolKind.Function ||\n                                (sourceSymbol.metadata as any)?.callable === true ||\n                                sourceSymbol.type?.kind === 'function') {\n                                return;\n                            }\n                        }\n                    }\n                }\n\n                this.reportError(\n                    DiagCode.NOT_A_FUNCTION,\n                    `Cannot call value of non-function type. '${symbol.name}' is a ${symbol.kind.toLowerCase()}`,\n                    span\n                );\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [5] Ident Level ──────────────────────────┐\n\n            private resolveIdentifier(ident: AST.IdentNode, contextSpan?: AST.Span, parameterContext?: FieldContext): void {\n                this.log('symbols', `Resolving identifier '${ident.name}'`);\n                this.config.services.contextTracker.pushContextSpan(ident.span);\n\n                try {\n                    if (parameterContext) {\n                        if (this.checkParameterForwardReference(ident, parameterContext)) {\n                            return;\n                        }\n                    }\n\n                    if (this.checkSelfReference(ident)) {\n                        return;\n                    }\n\n                    if (ident.builtin) {\n                        this.resolveBuiltinFunction(ident);\n                        return;\n                    }\n\n                    // ✅ Handle 'self' FIRST, before standard lookup\n                    if (ident.name === 'self') {\n                        // In static methods, 'self' is allowed (refers to the TYPE)\n                        if (this.currentIsStaticMethod && this.currentStructScope) {\n                            // Don't lookup symbol - it doesn't exist for static methods\n                            // Just mark as resolved, validation happens in TypeValidator\n                            this.stats.resolvedSymbols++;\n                            this.config.services.contextTracker.popContextSpan();\n                            return;\n                        }\n\n                        // In instance methods, lookup the injected 'self' parameter\n                        const selfSymbol = this.config.services.scopeManager.lookupSymbol('self');\n                        if (selfSymbol && selfSymbol.metadata?.isSelf) {\n                            selfSymbol.used = true;\n                            this.stats.resolvedSymbols++;\n                            this.config.services.contextTracker.popContextSpan();\n                            return;\n                        }\n\n                        // // In static methods, 'self' is allowed (refers to the TYPE)\n                        // if (this.currentStructScope) {\n                        //     // Don't lookup symbol - it doesn't exist for static methods\n                        //     // Just mark as resolved, validation happens in TypeValidator\n                        //     this.stats.resolvedSymbols++;\n                        //     this.config.services.contextTracker.popContextSpan();\n                        //     return;\n                        // }\n\n                        // If neither, it's an error\n                        this.reportError(\n                            DiagCode.UNDEFINED_IDENTIFIER,\n                            \"self can only be used in non-static struct methods\",\n                            ident.span\n                        );\n                        this.config.services.contextTracker.popContextSpan();\n                        return;\n                    }\n\n                    // ✅ Check direct field access in static methods (without self)\n                    if (this.currentIsStaticMethod && this.currentStructScope) {\n                        const fieldSymbol = this.currentStructScope.symbols.get(ident.name);\n\n                        if (fieldSymbol && fieldSymbol.kind === SymbolKind.StructField) {\n                            const isStaticField = fieldSymbol.visibility.kind === 'Static';\n\n                            if (!isStaticField) {\n                                this.reportError(\n                                    DiagCode.INVALID_STATIC_ACCESS,\n                                    `Cannot access instance field '${ident.name}' in static method. Static methods can only access static fields.`,\n                                    ident.span\n                                );\n                                return;  // ✅ Stop processing and don't mark as used/resolved\n                            }\n                        }\n                    }\n\n                    // Check if we're in a struct method and identifier is a struct field\n                    const currentScope = this.config.services.scopeManager.getCurrentScope();\n                    if (currentScope.kind === ScopeKind.Function) {\n                        const parentScope = this.config.services.scopeManager.getScopeParent(currentScope.id);\n                        if (parentScope && parentScope.kind === ScopeKind.Type) {\n                            const fieldSymbol = parentScope.symbols.get(ident.name);\n                            if (fieldSymbol && fieldSymbol.kind === SymbolKind.StructField) {\n                                fieldSymbol.used = true;\n                                this.stats.resolvedSymbols++;\n                                this.log('symbols', `Resolved struct field '${fieldSymbol.name}' as used`);\n                                this.config.services.contextTracker.popContextSpan();\n                                return;\n                            }\n                        }\n                    }\n\n                    this.resolveStandardIdentifier(ident, contextSpan);\n                } finally {\n                    this.config.services.contextTracker.popContextSpan();\n                }\n            }\n\n            private resolveBuiltinFunction(ident: AST.IdentNode): void {\n                const globalScope = this.config.services.scopeManager.getAllScopes().find(s => s.kind === ScopeKind.Global);\n                if (!globalScope) {\n                    throw new Error('Global scope not found');\n                }\n\n                const builtinName = `@${ident.name}`;\n                const builtinSymbol = globalScope.symbols.get(builtinName);\n\n                if (!builtinSymbol) {\n                    this.reportError(\n                        DiagCode.UNDEFINED_BUILTIN,\n                        `Undefined builtin function '${builtinName}'`,\n                        ident.span\n                    );\n                    return;\n                }\n\n                builtinSymbol.used = true;\n                this.stats.resolvedSymbols++;\n            }\n\n            private resolveStandardIdentifier(ident: AST.IdentNode, contextSpan?: AST.Span): void {\n                this.log('symbols', `Resolving standard identifier '${ident.name}'`);\n                const cacheKey = this.createCacheKey(ident);\n\n                let symbol = this.resolutionCtx.cache.get(cacheKey);\n                if (symbol !== undefined) {\n                    this.stats.cachedResolutions++;\n                    if (symbol) {\n                        symbol.used = true;\n                        this.log('symbols', `Used cached symbol '${symbol.name}'`);\n                    }\n                    return;\n                }\n\n                symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\n                this.resolutionCtx.cache.set(cacheKey, symbol || null);\n\n                if (!symbol) {\n                    this.config.services.contextTracker.recordPendingReference(ident.name, ident.span);\n                    this.reportError(\n                        DiagCode.UNDEFINED_IDENTIFIER,\n                        `Undefined identifier '${ident.name}'`,\n                        ident.span\n                    );\n                    return;\n                }\n\n                this.validateSymbolUsage(symbol, ident, contextSpan);\n                symbol.used = true;\n                this.config.services.contextTracker.resolvePendingReferences(ident.name);\n                this.stats.resolvedSymbols++;\n                this.log('symbols', `Resolved and marked '${symbol.name}' as used`);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [6] Type Level ───────────────────────────┐\n\n            private resolveType(typeNode: AST.TypeNode, symbol: Symbol, contextSpan?: AST.Span): boolean {\n                this.log('symbols', `Resolving type for symbol '${symbol.name}', typeNode: ${typeNode.toString()}`);\n\n                switch (typeNode.kind) {\n                    case 'ident': {\n                        const identNode = typeNode.getIdent()!;\n\n                        if (!identNode.builtin) {\n                            const typeSymbol = this.config.services.scopeManager.lookupSymbol(identNode.name);\n\n                            if (!typeSymbol) {\n                                this.reportError(\n                                    DiagCode.UNDEFINED_IDENTIFIER,\n                                    `Undefined type '${identNode.name}'`,\n                                    identNode.span\n                                );\n                                return false;\n                            }\n\n                            if (!typeSymbol.declared) {\n                                this.reportError(\n                                    DiagCode.USED_BEFORE_DECLARED,\n                                    `Symbol '${identNode.name}' used before declaration`,\n                                    identNode.span\n                                );\n                                return false;\n                            }\n\n                            typeSymbol.used = true;\n                        }\n\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'optional': {\n                        const optional = typeNode.getOptional()!;\n                        if (!this.resolveType(optional.target, symbol, contextSpan)) return false;\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'pointer': {\n                        const pointer = typeNode.getPointer()!;\n\n                        // ✅ ADDED: Validate pointer target is a type identifier, not a variable\n                        if (pointer.target.isIdent()) {\n                            const targetIdent = pointer.target.getIdent()!;\n\n                            if (!targetIdent.builtin) {\n                                const targetSymbol = this.config.services.scopeManager.lookupSymbol(targetIdent.name);\n\n                                // If target is a variable/parameter (not a type), this is likely a syntax error\n                                if (targetSymbol &&\n                                    (targetSymbol.kind === SymbolKind.Variable ||\n                                    targetSymbol.kind === SymbolKind.Parameter)) {\n                                    this.reportError(\n                                        DiagCode.TYPE_MISMATCH,\n                                        `Cannot use pointer syntax with variable '${targetIdent.name}'. Did you mean to dereference using '.*' postfix operator?`,\n                                        typeNode.span\n                                    );\n                                    return false;\n                                }\n                            }\n                        }\n\n                        if (!this.resolveType(pointer.target, symbol, contextSpan)) return false;\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'array': {\n                        const array = typeNode.getArray()!;\n                        if (!this.resolveType(array.target, symbol, contextSpan)) return false;\n                        if (array.size) this.resolveExprStmt(array.size, contextSpan, undefined, symbol);\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'tuple': {\n                        const tuple = typeNode.getTuple()!;\n                        for (const field of tuple.fields) {\n                            if (!this.resolveType(field, symbol, contextSpan)) return false;\n                        }\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'struct': {\n                        const struct = typeNode.getStruct()!;\n\n                        let typeScope: Scope | null = null;\n\n                        if (struct.metadata?.scopeId !== undefined) {\n                            try {\n                                typeScope = this.config.services.scopeManager.getScope(struct.metadata.scopeId as number);\n                            } catch {\n                                typeScope = null;\n                            }\n                        }\n\n                        if (!typeScope && struct.name && struct.name !== 'Anonymous') {\n                            typeScope = this.config.services.scopeManager.findChildScopeByName(struct.name, ScopeKind.Type);\n                        }\n\n                        if (!typeScope) {\n                            typeScope = this.config.services.scopeManager.findChildScopeByNameFromId(\n                                symbol.name,\n                                symbol.scope,\n                                ScopeKind.Type\n                            );\n                        }\n\n                        if (!typeScope) {\n                            const parentScope = this.config.services.scopeManager.getScope(symbol.scope);\n                            for (const childId of parentScope.children) {\n                                const child = this.config.services.scopeManager.getScope(childId);\n                                if (child.kind === ScopeKind.Type) {\n                                    if (this.scopeMatchesStruct(child, struct)) {\n                                        typeScope = child;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n\n                        if (typeScope) {\n                            this.config.services.contextTracker.withSavedState(() => {\n                                this.config.services.contextTracker.setScope(typeScope!.id);\n\n                                this.config.services.scopeManager.withScope(typeScope!.id, () => {\n                                    const fields: AST.FieldNode[] = [];\n                                    const methods: AST.FuncStmtNode[] = [];\n\n                                    for (const member of struct.members) {\n                                        if (member.isField()) {\n                                            fields.push(member.getField()!);\n                                        } else if (member.isMethod()) {\n                                            methods.push(member.getMethod()!);\n                                        }\n                                    }\n\n                                    this.resolveFields(fields);\n\n                                    for (const m of methods) {\n                                        this.resolveFuncStmt(m);\n                                    }\n                                });\n                            });\n                        } else {\n                            this.reportError(\n                                DiagCode.INTERNAL_ERROR,\n                                `Cannot find type scope for struct '${struct.name || '<anonymous>'}'`,\n                                typeNode.span\n                            );\n                            return false;\n                        }\n\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'enum': {\n                        const enumType = typeNode.getEnum()!;\n\n                        let typeScope: Scope | null = null;\n\n                        if (enumType.metadata?.scopeId !== undefined) {\n                            try {\n                                typeScope = this.config.services.scopeManager.getScope(enumType.metadata.scopeId as number);\n                            } catch {\n                                typeScope = null;\n                            }\n                        }\n\n                        if (!typeScope && symbol.name) {\n                            typeScope = this.config.services.scopeManager.findChildScopeByName(symbol.name, ScopeKind.Type);\n                        }\n\n                        if (typeScope) {\n                            enumType.metadata = { ...enumType.metadata, scopeId: typeScope.id };\n\n                            this.config.services.contextTracker.withSavedState(() => {\n                                this.config.services.contextTracker.setScope(typeScope!.id);\n                                this.config.services.scopeManager.withScope(typeScope!.id, () => {\n                                    for (const variant of enumType.variants) {\n                                        // Mark variant as resolved\n                                        const variantSymbol = typeScope!.symbols.get(variant.ident.name);\n                                        if (variantSymbol) {\n                                            variantSymbol.declared = true;\n                                            variantSymbol.used = true;\n                                            this.stats.enumVariantsResolved++;\n                                        }\n\n                                        if (variant.type) {\n                                            if (variant.type.isStruct()) {\n                                                const structType = variant.type.getStruct()!;\n\n                                                let variantScope: Scope | null = null;\n\n                                                if (structType.metadata?.scopeId !== undefined) {\n                                                    try {\n                                                        variantScope = this.config.services.scopeManager.getScope(structType.metadata.scopeId as number);\n                                                    } catch {\n                                                        variantScope = null;\n                                                    }\n                                                }\n\n                                                if (!variantScope) {\n                                                    variantScope = this.config.services.scopeManager.findChildScopeByNameFromId(\n                                                        variant.ident.name,\n                                                        typeScope!.id,\n                                                        ScopeKind.Type\n                                                    );\n                                                }\n\n                                                if (variantScope) {\n                                                    this.config.services.contextTracker.withSavedState(() => {\n                                                        this.config.services.scopeManager.withScope(variantScope!.id, () => {\n                                                            const tempSymbol: Symbol = {\n                                                                id: -1,\n                                                                name: variant.ident.name,\n                                                                kind: SymbolKind.EnumVariant,\n                                                                type: variant.type!,\n                                                                scope: variantScope!.id,\n                                                                contextSpan: variant.type!.span,\n                                                                declared: true,\n                                                                initialized: true,\n                                                                used: false,\n                                                                isTypeChecked: false,\n                                                                visibility: { kind: 'Public'},\n                                                                mutability: { kind: 'Immutable' },\n                                                                isExported: false\n                                                            };\n\n                                                            this.resolveType(variant.type!, tempSymbol, contextSpan);\n                                                        });\n                                                    });\n                                                }\n                                            } else {\n                                                this.resolveType(variant.type, symbol, contextSpan);\n                                            }\n                                        }\n                                    }\n                                });\n                            });\n                        }\n\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'errset':\n                        // Resolve error members - FIXED\n                        const errorType = typeNode.getError()!;\n                        for (const errorMember of errorType.members) {\n                            // Error members are just identifiers - mark them as resolved\n                            const errorSymbol = this.config.services.scopeManager.lookupSymbol(errorMember.name);\n                            if (errorSymbol) {\n                                errorSymbol.used = true;\n                                errorSymbol.declared = true;\n                            }\n                            this.log('symbols', `Resolved error member '${errorMember.name}'`);\n                        }\n                        symbol.type = typeNode;\n                        return true;\n\n                    case 'function': {\n                        const func = typeNode.getFunction()!;\n\n                        // Resolve parameters\n                        for (const param of func.params) {\n                            const tempParamSymbol: Symbol = {\n                                id: -1,\n                                name: '<func-param-type>',\n                                kind: SymbolKind.Variable,\n                                type: null,\n                                scope: this.config.services.scopeManager.getCurrentScope().id,\n                                contextSpan: param.span,\n                                declared: true,\n                                initialized: true,\n                                used: false,\n                                isTypeChecked: false,\n                                visibility: { kind: 'Private' },\n                                mutability: { kind: 'Immutable' },\n                                isExported: false\n                            };\n                            if (!this.resolveType(param, tempParamSymbol, contextSpan)) return false;\n                        }\n\n                        // Resolve return type\n                        if (func.returnType) {\n                            const tempReturnSymbol: Symbol = {\n                                id: -1,\n                                name: '<func-return-type>',\n                                kind: SymbolKind.Variable,\n                                type: null,\n                                scope: this.config.services.scopeManager.getCurrentScope().id,\n                                contextSpan: func.returnType.span,\n                                declared: true,\n                                initialized: true,\n                                used: false,\n                                isTypeChecked: false,\n                                visibility: { kind: 'Private' },\n                                mutability: { kind: 'Immutable' },\n                                isExported: false\n                            };\n                            if (!this.resolveType(func.returnType, tempReturnSymbol, contextSpan)) return false;\n                        }\n\n                        // Resolve and validate error type\n                        if (func.errorType) {\n                            // First, recursively resolve the error type structure\n                            const tempErrorSymbol: Symbol = {\n                                id: -1,\n                                name: '<func-error-type>',\n                                kind: SymbolKind.Variable,\n                                type: null,\n                                scope: this.config.services.scopeManager.getCurrentScope().id,\n                                contextSpan: func.errorType.span,\n                                declared: true,\n                                initialized: true,\n                                used: false,\n                                isTypeChecked: false,\n                                visibility: { kind: 'Private' },\n                                mutability: { kind: 'Immutable' },\n                                isExported: false\n                            };\n                            if (!this.resolveType(func.errorType, tempErrorSymbol, contextSpan)) return false;\n\n                            // Then validate the error type identifier exists and is an error type\n                            if (func.errorType.isIdent()) {\n                                const errorIdent = func.errorType.getIdent()!;\n\n                                if (!errorIdent.builtin) {\n                                    const errorSymbol = this.config.services.scopeManager.lookupSymbol(errorIdent.name);\n\n                                    if (!errorSymbol) {\n                                        this.reportError(\n                                            DiagCode.UNDEFINED_IDENTIFIER,\n                                            `Error type '${errorIdent.name}' is not defined`,\n                                            func.errorType.span\n                                        );\n                                        return false;\n                                    }\n\n                                    // Validate it's actually an error type\n                                    if (errorSymbol.type && !errorSymbol.type.isErrset()) {\n                                        this.reportError(\n                                            DiagCode.TYPE_MISMATCH,\n                                            `'${errorIdent.name}' is not an error type`,\n                                            func.errorType.span\n                                        );\n                                        return false;\n                                    }\n                                }\n                            }\n                        }\n\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'union': {\n                        const union = typeNode.getUnion()!;\n                        for (const variantType of union.types) {\n                            const tempVariantSymbol: Symbol = {\n                                id: -1,\n                                name: '<union-variant>',\n                                kind: SymbolKind.Variable,\n                                type: null,\n                                scope: this.config.services.scopeManager.getCurrentScope().id,\n                                contextSpan: variantType.span,\n                                declared: true,\n                                initialized: true,\n                                used: false,\n                                isTypeChecked: false,\n                                visibility: { kind: 'Private' },\n                                mutability: { kind: 'Immutable' },\n                                isExported: false\n                            };\n                            if (!this.resolveType(variantType, tempVariantSymbol, contextSpan)) return false;\n                        }\n                        symbol.type = typeNode;\n                        return true;\n                    }\n\n                    case 'paren': {\n                        return this.resolveType(typeNode.getParen()!.type, symbol, contextSpan);\n                    }\n\n                    case 'primitive':\n                        symbol.type = typeNode;\n                        return true;\n\n                    default:\n                        this.config.services.diagnosticManager.reportError(DiagCode.UNSUPPORTED_TYPE, `Unsupported type kind: ${typeNode.kind}`, typeNode.span);\n                        return false;\n                }\n            }\n\n            private scopeMatchesStruct(scope: Scope, struct: AST.StructTypeNode): boolean {\n                const structFields = struct.members.filter((m: AST.StructMemberNode) => m.isField());\n                const scopeFields = Array.from(scope.symbols.values())\n                    .filter(s => s.kind === SymbolKind.StructField);\n\n                if (scopeFields.length !== structFields.length) {\n                    return false;\n                }\n\n                for (const member of structFields) {\n                    const field = member.source as AST.FieldNode;\n                    const fieldName = field.ident.name;\n\n                    if (!scope.symbols.has(fieldName)) {\n                        return false;\n                    }\n\n                    const scopeSymbol = scope.symbols.get(fieldName)!;\n                    if (scopeSymbol.kind !== SymbolKind.StructField) {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌─────────────────────────── [x] VALIDATION ───────────────────────────┐\n\n            private checkParameterForwardReference(ident: AST.IdentNode, parameterContext: FieldContext): boolean {\n                const forwardRefResult = this.config.services.contextTracker.checkParameterForwardReference(\n                    ident.name,\n                    parameterContext.currentFieldIndex,\n                    parameterContext.parameters\n                );\n\n                if (forwardRefResult.isForwardReference) {\n                    this.reportError(\n                        DiagCode.PARAMETER_FORWARD_REFERENCE,\n                        `Parameter '${parameterContext.parameters[parameterContext.currentFieldIndex].name}' default value refers to parameter '${ident.name}' which is not yet declared`,\n                        ident.span\n                    );\n                    this.stats.forwardReferences++;\n                    return true;\n                }\n                return false;\n            }\n\n            private checkSelfReference(ident: AST.IdentNode): boolean {\n                const selfRefResult = this.config.services.contextTracker.checkSelfReference(ident.name, ident.span);\n\n                if (selfRefResult.isSelfReference) {\n                    const errorCode = selfRefResult.errorType === 'VARIABLE_SELF_INIT' ?\n                        DiagCode.VARIABLE_SELF_INIT : DiagCode.PARAMETER_SELF_INIT;\n\n                    const symbolType = selfRefResult.declarationContext?.symbolKind;\n                    this.reportError(\n                        errorCode,\n                        `${symbolType} '${ident.name}' cannot be initialized using itself`,\n                        ident.span\n                    );\n                    this.stats.selfReferences++;\n                    return true;\n                }\n                return false;\n            }\n\n            private validateSymbolUsage(symbol: Symbol, ident: AST.IdentNode, contextSpan?: AST.Span): void {\n                this.log('symbols', `Validating usage of symbol '${symbol.name}'`);\n\n                if (contextSpan) {\n                    this.config.services.contextTracker.pushContextSpan(contextSpan);\n                }\n\n                if (!symbol.declared) {\n                    this.reportError(\n                        DiagCode.USED_BEFORE_DECLARED,\n                        `Symbol '${ident.name}' used before declaration`,\n                        ident.span\n                    );\n                }\n\n                if (symbol.kind === SymbolKind.Variable && !symbol.initialized) {\n                    this.reportError(\n                        DiagCode.USED_BEFORE_INITIALIZED,\n                        `Variable '${ident.name}' used before initialization`,\n                        ident.span\n                    );\n                }\n\n                if (contextSpan) {\n                    this.config.services.contextTracker.popContextSpan();\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private init(): boolean {\n                this.config.services.contextTracker.reset();\n                this.config.services.contextTracker.setPhase(AnalysisPhase.Resolution);\n                this.stats.totalSymbols = Array.from(this.config.services.scopeManager.getAllSymbols()).length;\n\n                const globalScope = this.config.services.scopeManager.getGlobalScope();\n                this.config.services.scopeManager.setCurrentScope(globalScope.id);\n                this.config.services.contextTracker.setScope(globalScope.id);\n\n                this.log('verbose', `Resolution initialized: ${this.stats.totalSymbols} symbols to resolve`);\n                return true;\n            }\n\n            private initStats(): ResolutionStats {\n                return {\n                    totalSymbols            : 0,\n                    resolvedSymbols         : 0,\n                    cachedResolutions       : 0,\n                    forwardReferences       : 0,\n                    selfReferences          : 0,\n                    importResolutions       : 0,\n                    structMethodsResolved   : 0,\n                    enumVariantsResolved    : 0,\n                    memberAccessResolved    : 0,\n                    anonymousTypesResolved  : 0,\n                    visibilityChecks        : 0,\n                    errors                  : 0,\n                    modulesProcessed        : 0,\n                    startTime               : Date.now()\n                };\n            }\n\n            private initResolutionContext(): ResolutionContext {\n                return {\n                    currentModule: '',\n                    moduleStack: [],\n                    cache: new Map(),\n                };\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private createCacheKey(ident: AST.IdentNode): string {\n                    const scope = this.config.services.scopeManager.getCurrentScope();\n                    const moduleName = this.resolutionCtx.currentModule;\n                    return `${moduleName}:${ident.name}:${ident.span.start}:${ident.span.end}`;\n                }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            logStatistics(): void {\n                const duration = Date.now() - this.stats.startTime;\n                this.log('verbose',\n                    `Resolution Statistics      :\\n` +\n                    `  Duration                 : ${duration}ms\\n` +\n                    `  Total symbols            : ${this.stats.totalSymbols}\\n` +\n                    `  Resolved symbols         : ${this.stats.resolvedSymbols}\\n` +\n                    `  Cached resolutions       : ${this.stats.cachedResolutions}\\n` +\n                    `  Forward references       : ${this.stats.forwardReferences}\\n` +\n                    `  Self references          : ${this.stats.selfReferences}\\n` +\n                    `  Import resolutions       : ${this.stats.importResolutions}\\n` +\n                    `  Struct methods resolved  : ${this.stats.structMethodsResolved}\\n` +\n                    `  Enum variants resolved   : ${this.stats.enumVariantsResolved}\\n` +\n                    `  Member access resolved   : ${this.stats.memberAccessResolved}\\n` +\n                    `  Anonymous types resolved : ${this.stats.anonymousTypesResolved}\\n` +\n                    `  Visibility checks        : ${this.stats.visibilityChecks}\\n` +\n                    `  Errors                   : ${this.stats.errors}`\n                );\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// TypeValidator.ts — Complete type validation Phase\r\n//\r\n// Developed with ❤️ by Maysara.\r\n\r\n\r\n\r\n// ╔═══════════════════════════════════════ PACK ════════════════════════════════════════╗\r\n\r\n    import * as AST                 from '@je-es/ast';\r\n    import { AnalysisPhase }        from '../components/ContextTracker';\r\n    import { DiagCode }             from '../components/DiagnosticManager';\r\n    import { PhaseBase }            from '../interfaces/PhaseBase';\r\n    import { AnalysisConfig }       from '../ast-analyzer';\r\n    import { Scope, Symbol, SymbolKind, ScopeKind } from '../components/ScopeManager';\r\n    import { ExpressionEvaluator }  from '../components/ExpressionEvaluator';\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔═══════════════════════════════════════ TYPES ═══════════════════════════════════════╗\r\n\r\n    interface TypeValidatorContext {\r\n        currentModule               : string;\r\n        moduleStack                 : string[];\r\n        typeCache                   : Map<string, AST.TypeNode | null>;\r\n    }\r\n\r\n    interface TypeValidationStats {\r\n        modulesProcessed            : number;\r\n        typesInferred               : number;\r\n        typesCached                 : number;\r\n        compatibilityChecks         : number;\r\n        callsValidated              : number;\r\n        memberAccessValidated       : number;\r\n        assignmentsValidated        : number;\r\n        returnsValidated            : number;\r\n        errors                      : number;\r\n        startTime                   : number;\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔═══════════════════════════════════════ CORE ════════════════════════════════════════╗\r\n\r\n    export class TypeValidator extends PhaseBase {\r\n\r\n        // ┌──────────────────────────────── INIT ─────────────────────────────────┐\r\n\r\n            private stats                       : TypeValidationStats   = this.initStats();\r\n\r\n            private typeCtx                     : TypeValidatorContext  = this.initTypeValidatorContext();\r\n            private ExpressionEvaluator         : ExpressionEvaluator;\r\n\r\n            private inferenceStack              : Set<string>           = new Set();\r\n            private circularTypeDetectionStack  : Set<string>           = new Set();\r\n\r\n            private currentFunctionReturnType   : AST.TypeNode | null   = null;\r\n            private hasReturnStatement          : boolean               = false;\r\n\r\n            private currentFunctionErrorType    : AST.TypeNode | null   = null;\r\n            private hasThrowStatement           : boolean               = false;\r\n            private currentIsStaticMethod       : boolean               = false;\r\n            private currentStructScope          : Scope | null          = null;\r\n\r\n\r\n            private readonly CACHE_MAX_SIZE     = 10000;\r\n\r\n            constructor( config : AnalysisConfig ) {\r\n                super(AnalysisPhase.TypeValidation, config);\r\n\r\n                this.ExpressionEvaluator = new ExpressionEvaluator(this.config);\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── MAIN ─────────────────────────────────┐\r\n\r\n            handle(): boolean {\r\n                try {\r\n                    this.log('verbose', 'Starting symbol validation phase...');\r\n                    this.stats.startTime = Date.now();\r\n\r\n                    if (!this.init()) return false;\r\n                    if (!this.validateAllModules()) return false;\r\n\r\n                    this.logStatistics();\r\n                    return !this.config.services.diagnosticManager.hasErrors();\r\n\r\n                } catch (error) {\r\n                    this.log('errors', `Fatal error during type validation: ${error}`);\r\n                    this.reportError(DiagCode.INTERNAL_ERROR, `Fatal error during type validation: ${error}`);\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            reset(): void {\r\n                this.inferenceStack.clear();\r\n                this.circularTypeDetectionStack.clear();\r\n                this.stats          = this.initStats();\r\n                this.typeCtx        = this.initTypeValidatorContext();\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌────────────────────────── [1] Program Level ─────────────────────────┐\r\n\r\n            private validateAllModules(): boolean {\r\n                this.log('verbose', 'Validating types from all modules...');\r\n                const globalScope = this.config.services.scopeManager.getCurrentScope();\r\n\r\n                for (const [moduleName, module] of this.config.program!.modules) {\r\n                    this.config.services.contextTracker.pushContextSpan({ start: 0, end: 0 });\r\n                    try {\r\n                        if (!this.validateModule(moduleName, module, globalScope)) {\r\n                            this.log('errors', `Failed to validate module ${moduleName}, continuing...`);\r\n                        }\r\n                        this.stats.modulesProcessed++;\r\n                    } finally {\r\n                        this.config.services.contextTracker.popContextSpan();\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌────────────────────────── [2] Module Level ──────────────────────────┐\r\n\r\n            private validateModule(moduleName: string, module: AST.Module, parentScope: Scope): boolean {\r\n                this.log('symbols', `Validating module '${moduleName}'`);\r\n\r\n                try {\r\n                    this.config.services.contextTracker.setModuleName(moduleName);\r\n\r\n                    if (typeof module.metadata?.path === 'string') {\r\n                        this.config.services.contextTracker.setModulePath(module.metadata.path);\r\n                    }\r\n\r\n                    this.enterModuleContext(moduleName, module);\r\n\r\n                    const moduleScope = this.findModuleScope(moduleName);\r\n                    if (!moduleScope) {\r\n                        this.reportError(DiagCode.MODULE_SCOPE_NOT_FOUND, `Module scope for '${moduleName}' not found`);\r\n                        return false;\r\n                    }\r\n\r\n                    this.config.services.scopeManager.setCurrentScope(moduleScope.id);\r\n                    this.config.services.contextTracker.setScope(moduleScope.id);\r\n\r\n                    for (const statement of module.statements) {\r\n                        this.validateStmt(statement, moduleScope, moduleName);\r\n                    }\r\n\r\n                    this.exitModuleContext();\r\n                    return true;\r\n                } catch (error) {\r\n                    this.reportError(DiagCode.INTERNAL_ERROR, `Failed to validate module '${moduleName}': ${error}`);\r\n                    return false;\r\n                }\r\n            }\r\n\r\n             private enterModuleContext(moduleName: string, module: AST.Module): void {\r\n                this.typeCtx.moduleStack.push(this.typeCtx.currentModule);\r\n                this.typeCtx.currentModule = moduleName;\r\n                this.config.services.contextTracker.setModuleName(moduleName);\r\n                if (typeof module.metadata?.path === 'string') {\r\n                    this.config.services.contextTracker.setModulePath(module.metadata.path);\r\n                }\r\n            }\r\n\r\n            private exitModuleContext(): void {\r\n                const previousModule = this.typeCtx.moduleStack.pop();\r\n                this.typeCtx.currentModule = previousModule || '';\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────────── [3] Stmt Level ───────────────────────────┐\r\n\r\n            private validateStmt(stmt: AST.StmtNode, currentScope?: Scope, moduleName?: string): void {\r\n                if(!currentScope) { currentScope = this.config.services.scopeManager.getCurrentScope(); }\r\n                if (!stmt) {\r\n                    this.reportError(DiagCode.ANALYSIS_ERROR, 'Found null statement during validation');\r\n                    return;\r\n                }\r\n\r\n                this.log('verbose', `Validating ${stmt.kind} statement`);\r\n                this.config.services.contextTracker.pushContextSpan(stmt.span);\r\n\r\n                try {\r\n                    this.config.services.scopeManager.withScope(currentScope.id, () => {\r\n                        this.config.services.contextTracker.withSavedState(() => {\r\n                            this.config.services.contextTracker.setScope(currentScope.id);\r\n                            this.processStmt(stmt, currentScope, moduleName);\r\n                        });\r\n                    });\r\n                } catch (error) {\r\n                    this.reportError(\r\n                        DiagCode.ANALYSIS_ERROR,\r\n                        `Failed to validate ${stmt.kind} statement: ${error}`,\r\n                        stmt.span\r\n                    );\r\n                } finally {\r\n                    this.config.services.contextTracker.popContextSpan();\r\n                }\r\n            }\r\n\r\n            private processStmt(stmt: AST.StmtNode, currentScope: Scope, moduleName?: string): void {\r\n                const nodeGetter = this.getNodeGetter(stmt);\r\n                if (!nodeGetter) {\r\n                    this.reportError(DiagCode.INTERNAL_ERROR, `Invalid AST: ${stmt.kind} node is null`);\r\n                    return;\r\n                }\r\n\r\n                switch (stmt.kind) {\r\n                        case 'Block':\r\n                            this.handleBlockStmt(stmt.getBlock()!, currentScope, moduleName);\r\n                            break;\r\n                        case 'Test':\r\n                            this.handleTestStmt(stmt.getTest()!, currentScope, moduleName);\r\n                            break;\r\n                        case 'Use':\r\n                            break;\r\n                        case 'Def':\r\n                            this.handleDefStmt(stmt.getDef()!, currentScope, moduleName);\r\n                            break;\r\n                        case 'Let':\r\n                            this.handleLetStmt(stmt.getLet()!, currentScope, moduleName);\r\n                            break;\r\n                        case 'Func':\r\n                            this.handleFuncStmt(stmt.getFunc()!, currentScope, moduleName);\r\n                            break;\r\n                        case 'While':\r\n                        case 'Do':\r\n                        case 'For':\r\n                            this.handleLoopStmt(stmt);\r\n                            break;\r\n                        case 'Return':\r\n                        case 'Defer':\r\n                        case 'Throw':\r\n                            this.handleControlflowStmt(stmt);\r\n                            break;\r\n                        case 'Expression': {\r\n                            const expr = stmt.getExpr()!;\r\n\r\n                           // console.log('>>> Processing Expression statement');\r\n                           // console.log('Expression kind:', expr.kind);\r\n\r\n                            if (expr.kind === 'Binary') {\r\n                                const binary = expr.getBinary();\r\n                               // console.log('Binary kind:', binary?.kind);\r\n\r\n                                if (binary && binary.kind === 'Assignment') {\r\n                                   // console.log('>>> Calling validateAssignment');\r\n                                   // console.log('Error count before validateAssignment:', this.config.services.diagnosticManager.length());\r\n\r\n                                    this.validateAssignment(binary);\r\n\r\n                                   // console.log('Error count after validateAssignment:', this.config.services.diagnosticManager.length());\r\n                                   // console.log('Has errors after validateAssignment?', this.config.services.diagnosticManager.hasErrors());\r\n                                }\r\n                            }\r\n\r\n                           // console.log('>>> Calling inferExpressionType');\r\n                            this.inferExpressionType(expr);\r\n\r\n                           // console.log('>>> Expression statement processing complete');\r\n                           // console.log('Final error count:', this.config.services.diagnosticManager.length());\r\n                           // console.log('Final has errors?', this.config.services.diagnosticManager.hasErrors());\r\n                            break;\r\n                        }\r\n                    }\r\n            }\r\n\r\n            private getNodeGetter(stmt: AST.StmtNode): (() => any) | null {\r\n                switch (stmt.kind) {\r\n                    case 'Def'          : return () => stmt.getDef();\r\n                    case 'Use'          : return () => stmt.getUse();\r\n                    case 'Let'          : return () => stmt.getLet();\r\n                    case 'Func'         : return () => stmt.getFunc();\r\n                    case 'Block'        : return () => stmt.getBlock();\r\n                    case 'Return'       :\r\n                    case 'Defer'        :\r\n                    case 'Throw'        : return () => stmt.getCtrlflow();\r\n                    case 'While'        :\r\n                    case 'Do'           :\r\n                    case 'For'          : return () => stmt.getLoop();\r\n                    case 'Expression'   : return () => stmt.getExpr();\r\n                    case 'Test'         : return () => stmt.getTest();\r\n                    default             : return null;\r\n                }\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────── [3.1] BLOCK ─────────────────────────────┐\r\n\r\n            private handleBlockStmt(blockNode: AST.BlockStmtNode, scope?: Scope, moduleName?: string): void {\r\n                this.validateBlockStmt(blockNode);\r\n            }\r\n\r\n            private validateBlockStmt(block: AST.BlockStmtNode, scope?: Scope, moduleName?: string): void {\r\n                this.log('symbols', 'Validating block');\r\n\r\n                const blockScope = this.config.services.scopeManager.findChildScopeByName('block', ScopeKind.Block);\r\n                if (blockScope) {\r\n                    this.config.services.contextTracker.withSavedState(() => {\r\n                        this.config.services.contextTracker.setScope(blockScope.id);\r\n\r\n                        this.config.services.scopeManager.withScope(blockScope.id, () => {\r\n                            for (const stmt of block.stmts) {\r\n                                this.validateStmt(stmt, blockScope);\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n\r\n            private handleTestStmt(testNode: AST.TestStmtNode, scope: Scope, moduleName?: string): void {\r\n                this.validateBlockStmt(testNode.block, scope, moduleName);\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────────────── [3.2] USE ──────────────────────────────┐\r\n\r\n            // Skipped for now.\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────────────── [3.3] DEF ──────────────────────────────┐\r\n\r\n            private handleDefStmt(defNode: AST.DefStmtNode, scope?: Scope, moduleName?: string): void {\r\n                this.validateDefStmt(defNode);\r\n            }\r\n\r\n            private validateDefStmt(defNode: AST.DefStmtNode): void {\r\n                this.log('symbols', `Type checking definition '${defNode.ident.name}'`);\r\n\r\n                const symbol = this.config.services.scopeManager.getSymbolInCurrentScope(defNode.ident.name);\r\n                if (!symbol) return;\r\n\r\n                if (defNode.type) {\r\n                    if (!this.checkCircularTypeDependency(defNode.type, defNode.ident.name, true)) {\r\n                        this.resolveTypeNode(defNode.type);\r\n                    }\r\n                }\r\n\r\n                symbol.isTypeChecked = true;\r\n                symbol.type = defNode.type;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────────────── [3.4] LET ──────────────────────────────┐\r\n\r\n            private handleLetStmt(letNode: AST.LetStmtNode, scope?: Scope, moduleName?: string): void {\r\n                this.validateLetStmt(letNode);\r\n            }\r\n\r\n            private validateLetStmt(letNode: AST.LetStmtNode): void {\r\n                this.log('symbols', `Type checking variable '${letNode.field.ident.name}'`);\r\n\r\n                const symbol = this.config.services.scopeManager.getSymbolInCurrentScope(letNode.field.ident.name);\r\n                if (!symbol) return;\r\n\r\n                const currentScope = this.config.services.scopeManager.getCurrentScope();\r\n                // Static variables only allowed in struct/enum types\r\n                if (letNode.field.visibility.kind === 'Static') {\r\n                    const currentScope = this.config.services.scopeManager.getCurrentScope();\r\n\r\n                    // Static is only valid inside struct/enum type definitions\r\n                    if (currentScope.kind !== ScopeKind.Type) {\r\n                        this.reportError(\r\n                            DiagCode.INVALID_VISIBILITY,\r\n                            `Variable '${letNode.field.ident.name}' cannot be 'static' outside of struct/enum`,\r\n                            letNode.field.ident.span\r\n                        );\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                if (letNode.field.type) {\r\n                    if (this.checkCircularTypeDependency(letNode.field.type, letNode.field.ident.name, false)) {\r\n                        return;\r\n                    }\r\n                    this.resolveTypeNode(letNode.field.type);\r\n                }\r\n\r\n                let initType = null;\r\n                if (letNode.field.initializer) {\r\n                    initType = this.extractTypeFromInitializer(letNode.field.initializer);\r\n\r\n                    if (initType && (initType.isStruct() || initType.isEnum())) {\r\n                        if (initType.isStruct()) {\r\n                            this.validateStructType(initType.getStruct()!, symbol);\r\n                        }\r\n                        symbol.type = initType;\r\n                        symbol.isTypeChecked = true;\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                let structTypeToValidate: AST.TypeNode | null = null;\r\n                let objectNodeToValidate: AST.ObjectNode | null = null;\r\n\r\n                if (letNode.field.type && letNode.field.initializer) {\r\n                    // Check for overflow before compatibility check\r\n                    this.validateValueFitsInType(letNode.field.initializer, letNode.field.type);\r\n\r\n                    let actualType = this.resolveIdentifierType(letNode.field.type);\r\n\r\n                    if (actualType.isStruct()) {\r\n                        if (letNode.field.initializer.is('Primary')) {\r\n                            const primary = letNode.field.initializer.getPrimary();\r\n                            if (primary && primary.is('Object')) {\r\n                                const obj = primary.getObject()!;\r\n                                structTypeToValidate = actualType;\r\n                                objectNodeToValidate = obj;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else if (letNode.field.initializer && !letNode.field.type) {\r\n                    if (letNode.field.initializer.is('Primary')) {\r\n                        const primary = letNode.field.initializer.getPrimary();\r\n                        if (primary && primary.is('Object')) {\r\n                            const obj = primary.getObject()!;\r\n\r\n                            if (obj.ident) {\r\n                                const typeSymbol = this.config.services.scopeManager.lookupSymbol(obj.ident.name);\r\n                                if (typeSymbol && typeSymbol.type) {\r\n                                    let actualType = this.resolveIdentifierType(typeSymbol.type);\r\n\r\n                                    if (actualType.isStruct()) {\r\n                                        structTypeToValidate = actualType;\r\n                                        objectNodeToValidate = obj;\r\n                                        letNode.field.type = typeSymbol.type;\r\n                                        symbol.type = typeSymbol.type;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (structTypeToValidate && objectNodeToValidate) {\r\n                    this.validateStructConstruction(objectNodeToValidate, structTypeToValidate, letNode.field.initializer!.span);\r\n                    symbol.isTypeChecked = true;\r\n                    this.stats.typesInferred++;\r\n                    return;\r\n                }\r\n\r\n                if (letNode.field.initializer) {\r\n                    const initType = this.inferExpressionType(letNode.field.initializer);\r\n\r\n                    if (initType) {\r\n                        if (!letNode.field.type) {\r\n                            letNode.field.type = initType;\r\n                            symbol.type = initType;\r\n                            this.stats.typesInferred++;\r\n                        } else {\r\n                            // Use shared helper for array validation\r\n                            if (!this.validateArrayAssignment(\r\n                                letNode.field.type,\r\n                                initType,\r\n                                letNode.field.initializer.span,\r\n                                `Variable '${letNode.field.ident.name}'`\r\n                            )) {\r\n                                symbol.isTypeChecked = true;\r\n                                return;\r\n                            }\r\n\r\n                            if (!this.isTypeCompatible(letNode.field.type, initType)) {\r\n                                this.reportError(\r\n                                    DiagCode.TYPE_MISMATCH,\r\n                                    `Cannot assign type '${initType.toString()}' to variable of type '${letNode.field.type.toString()}'`,\r\n                                    initType.span\r\n                                );\r\n                            }\r\n                        }\r\n                    }\r\n                } else if (!letNode.field.type) {\r\n                    this.reportError(\r\n                        DiagCode.CANNOT_INFER_TYPE,\r\n                        `Variable '${letNode.field.ident.name}' requires explicit type or initializer`,\r\n                        letNode.field.span\r\n                    );\r\n                }\r\n\r\n                // Check for overflow before compatibility check\r\n                if(letNode.field.initializer) {\r\n                    if(letNode.field.type) {\r\n                        this.validateValueFitsInType(letNode.field.initializer, letNode.field.type);\r\n                    } else if(initType) {\r\n                        this.validateValueFitsInType(letNode.field.initializer, initType);\r\n                    }\r\n                }\r\n\r\n                symbol.isTypeChecked = true;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────────────── [3.5] FUNC ─────────────────────────────┐\r\n\r\n            private handleFuncStmt(funcNode: AST.FuncStmtNode, scope?: Scope, moduleName?: string): void {\r\n                this.validateFuncStmt(funcNode);\r\n            }\r\n\r\n            private validateFuncStmt(funcNode: AST.FuncStmtNode): void {\r\n                this.log('symbols', `Type checking function '${funcNode.ident.name}'`);\r\n\r\n                const funcSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(funcNode.ident.name);\r\n                if (!funcSymbol) {\r\n                    this.reportError(\r\n                        DiagCode.CANNOT_INFER_TYPE,\r\n                        `Function '${funcNode.ident.name}' symbol not found`,\r\n                        funcNode.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                const funcScope = this.config.services.scopeManager.findChildScopeByName(funcNode.ident.name, ScopeKind.Function);\r\n                if (!funcScope) {\r\n                    this.reportError(\r\n                        DiagCode.CANNOT_INFER_TYPE,\r\n                        `Function scope for '${funcNode.ident.name}' not found`,\r\n                        funcNode.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                // ✅ Check if the function is stored IN a Type scope\r\n                const funcSymbolScope = this.config.services.scopeManager.getScope(funcSymbol.scope);\r\n\r\n                // For struct methods, funcSymbol.scope points to the Type scope (Point)\r\n                const parentScope = funcSymbolScope.kind === ScopeKind.Type &&\r\n                                funcSymbolScope.metadata?.typeKind === 'Struct'\r\n                    ? funcSymbolScope\r\n                    : null;\r\n\r\n                const isStaticMethod = parentScope !== null &&\r\n                                    funcNode.visibility.kind === 'Static';\r\n\r\n                const isInstanceMethod = parentScope !== null &&\r\n                                        !(funcNode.visibility.kind === 'Static');\r\n\r\n                // ✅ Save previous context\r\n                const previousIsStaticMethod = this.currentIsStaticMethod;\r\n                const previousStructScope = this.currentStructScope;\r\n\r\n                // ✅ SET CONTEXT BEFORE ENTERING NEW SCOPE - THIS IS CRITICAL\r\n                this.currentIsStaticMethod = isStaticMethod;\r\n                this.currentStructScope = isStaticMethod || isInstanceMethod ? parentScope : null;\r\n\r\n                this.log('symbols', `Function '${funcNode.ident.name}': isStatic=${isStaticMethod}, isInstance=${isInstanceMethod}, structScope=${this.currentStructScope?.name || 'none'}`);\r\n\r\n                // Save and set current function return/error type\r\n                const previousReturnType = this.currentFunctionReturnType;\r\n                const previousHasReturnStmt = this.hasReturnStatement;\r\n                const previousErrorType = this.currentFunctionErrorType;\r\n                const previousHasThrowStmt = this.hasThrowStatement;\r\n\r\n                this.currentFunctionReturnType = funcNode.returnType || null;\r\n                this.hasReturnStatement = false;\r\n                this.currentFunctionErrorType = funcNode.errorType || null;\r\n                this.hasThrowStatement = false;\r\n\r\n                try {\r\n                    this.config.services.contextTracker.withSavedState(() => {\r\n                        this.config.services.scopeManager.withScope(funcScope.id, () => {\r\n                            // ✅ ONLY inject self for instance methods (not static)\r\n                            if (isInstanceMethod) {\r\n                                this.resolveSelfParameter(funcScope, parentScope!);\r\n                            }\r\n\r\n                            // Validate parameters\r\n                            for (const param of funcNode.parameters) {\r\n                                this.validateParameter(param);\r\n                            }\r\n\r\n                            // Build function type\r\n                            const paramTypes: AST.TypeNode[] = [];\r\n                            for (const param of funcNode.parameters) {\r\n                                if (param.type) {\r\n                                    paramTypes.push(param.type);\r\n                                } else {\r\n                                    const paramSymbol = funcScope.symbols.get(param.ident.name);\r\n                                    if (paramSymbol?.type) {\r\n                                        paramTypes.push(paramSymbol.type);\r\n                                    } else {\r\n                                        this.reportError(\r\n                                            DiagCode.CANNOT_INFER_TYPE,\r\n                                            `Cannot infer type for parameter '${param.ident.name}'`,\r\n                                            param.span\r\n                                        );\r\n                                        paramTypes.push(AST.TypeNode.asUndefined(param.span));\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            funcSymbol.type = AST.TypeNode.asFunction(\r\n                                funcNode.span,\r\n                                paramTypes,\r\n                                funcNode.returnType ?? this.currentFunctionReturnType ?? undefined\r\n                            );\r\n\r\n                            funcSymbol.metadata!.errorType = funcNode.errorType ?? this.currentFunctionErrorType ?? undefined;\r\n\r\n                            // Validate body\r\n                            if (funcNode.body) {\r\n                                this.validateStmt(funcNode.body);\r\n\r\n                                const expectedReturnType = funcNode.returnType || this.currentFunctionReturnType;\r\n\r\n                                if (expectedReturnType && !expectedReturnType.isVoid()) {\r\n                                    const hasErrorType = funcNode.errorType || this.currentFunctionErrorType;\r\n\r\n                                    if (!this.hasReturnStatement) {\r\n                                        if (!hasErrorType || !this.hasThrowStatement) {\r\n                                            this.reportError(\r\n                                                DiagCode.MISSING_RETURN_STATEMENT,\r\n                                                `Function '${funcNode.ident.name}' with non-void return type must have at least one return statement`,\r\n                                                funcNode.ident.span\r\n                                            );\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                if (!funcNode.returnType) {\r\n                                    if (this.currentFunctionReturnType) {\r\n                                        funcSymbol.type!.getFunction()!.returnType = this.currentFunctionReturnType;\r\n                                    } else {\r\n                                        funcSymbol.type!.getFunction()!.returnType = AST.TypeNode.asVoid(funcNode.span);\r\n                                    }\r\n                                }\r\n                            }\r\n                        });\r\n                    });\r\n\r\n                    if (isInstanceMethod) {\r\n                        this.stats.memberAccessValidated++;\r\n                    }\r\n                } finally {\r\n                    this.config.services.contextTracker.completeDeclaration(funcSymbol.id);\r\n\r\n                    // ✅ RESTORE context - ALWAYS do this, even on error\r\n                    this.currentIsStaticMethod = previousIsStaticMethod;\r\n                    this.currentStructScope = previousStructScope;\r\n\r\n                    // Restore previous return/error types\r\n                    this.currentFunctionReturnType = previousReturnType;\r\n                    this.hasReturnStatement = previousHasReturnStmt;\r\n                    this.currentFunctionErrorType = previousErrorType;\r\n                    this.hasThrowStatement = previousHasThrowStmt;\r\n                }\r\n\r\n                funcSymbol.isTypeChecked = true;\r\n            }\r\n\r\n            // ───── PARAMS ─────\r\n\r\n            private validateParameter(paramNode: AST.FieldNode): void {\r\n                const paramSymbol = this.config.services.scopeManager.getSymbolInCurrentScope(paramNode.ident.name);\r\n                if (!paramSymbol) return;\r\n\r\n                // Validate parameter visibility\r\n                if (paramNode.visibility.kind === 'Static') {\r\n                    this.reportError(  // Changed from reportWarning\r\n                        DiagCode.INVALID_VISIBILITY,\r\n                        `Parameter '${paramNode.ident.name}' cannot be 'static'`,\r\n                        paramNode.ident.span\r\n                    );\r\n                    return;  // Add early return to prevent further processing\r\n                } else if (paramNode.visibility.kind === 'Public') {\r\n                    this.reportError(  // Changed from reportWarning\r\n                        DiagCode.INVALID_VISIBILITY,\r\n                        `Parameter '${paramNode.ident.name}' cannot be 'public'`,\r\n                        paramNode.ident.span\r\n                    );\r\n                    return;  // Add early return to prevent further processing\r\n                }\r\n\r\n                if (paramNode.initializer) {\r\n                    const initType = this.inferExpressionType(paramNode.initializer);\r\n\r\n                    if (initType) {\r\n                        if (!paramNode.type) {\r\n                            paramNode.type = initType;\r\n                            paramSymbol.type = initType;\r\n                            this.stats.typesInferred++;\r\n                        } else {\r\n                            // Use shared helper for array validation\r\n                            if (!this.validateArrayAssignment(\r\n                                paramNode.type,\r\n                                initType,\r\n                                paramNode.initializer.span,\r\n                                `Parameter '${paramNode.ident.name}' default value`\r\n                            )) {\r\n                                paramSymbol.isTypeChecked = true;\r\n                                return;\r\n                            }\r\n\r\n                            if (!this.isTypeCompatible(paramNode.type, initType)) {\r\n                                this.reportError(\r\n                                    DiagCode.TYPE_MISMATCH,\r\n                                    `Cannot assign type '${initType.toString()}' to parameter of type '${paramNode.type.toString()}'`,\r\n                                    paramNode.initializer.span\r\n                                );\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // Check for overflow before compatibility check\r\n                    if(paramNode.type) {\r\n                        this.validateValueFitsInType(paramNode.initializer, paramNode.type);\r\n                    } else if(initType) {\r\n                        this.validateValueFitsInType(paramNode.initializer, initType);\r\n                    }\r\n                }\r\n\r\n                paramSymbol.isTypeChecked = true;\r\n            }\r\n\r\n            private resolveSelfParameter(funcScope: Scope, structScope: Scope): void {\r\n                const selfSymbol = funcScope.symbols.get('self');\r\n                if (!selfSymbol) {\r\n                    this.log('verbose', `Warning: Expected 'self' parameter in struct method but not found`);\r\n                    return;\r\n                }\r\n\r\n                // Mark self as declared and used in resolution phase\r\n                selfSymbol.declared = true;\r\n                selfSymbol.used = true; // ✅ Mark as used by default since it's implicit\r\n\r\n                if (selfSymbol.type) {\r\n                    if (selfSymbol.type.kind === 'ident') {\r\n                        const typeIdent = selfSymbol.type.getIdent()!;\r\n                        if (typeIdent.name !== structScope.name) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Self type mismatch: expected '${structScope.name}', got '${typeIdent.name}'`,\r\n                                selfSymbol.contextSpan\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this.log('symbols', `Resolved 'self' parameter in struct method`);\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌───────────────────────────── [3.6] LOOP ─────────────────────────────┐\r\n\r\n            private handleLoopStmt(stmt: AST.StmtNode, scope?: Scope, moduleName?: string): void {\r\n                if(stmt.getLoop === undefined) {\r\n                    const data = stmt;\r\n                    switch (stmt.kind) {\r\n                        case 'While' : {\r\n                            const src = data.source as AST.LoopStmtNode;\r\n                            const loop = AST.LoopStmtNode.createWhile(data.span, src.expr, src.stmt);\r\n                            this.validateLoopStmt(loop);\r\n                            break;\r\n                        }\r\n                        case 'Do' : {\r\n                            const src = data.source as AST.LoopStmtNode;\r\n                            const loop = AST.LoopStmtNode.createDo(data.span, src.expr, src.stmt);\r\n                            this.validateLoopStmt(loop);\r\n                            break;\r\n                        }\r\n                        case 'For' : {\r\n                            const src = data.source as AST.LoopStmtNode;\r\n                            const loop = AST.LoopStmtNode.createFor(data.span, src.expr, src.stmt);\r\n                            this.validateLoopStmt(loop);\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.validateLoopStmt(stmt.getLoop()!);\r\n                }\r\n            }\r\n\r\n            private validateLoopStmt(loopStmt: AST.LoopStmtNode): void {\r\n                const loopScope = this.config.services.scopeManager.findChildScopeByName('loop', ScopeKind.Loop);\r\n                if (!loopScope) return;\r\n\r\n                this.config.services.contextTracker.withSavedState(() => {\r\n                    this.config.services.scopeManager.withScope(loopScope.id, () => {\r\n                        if (loopStmt.expr) {\r\n                            const condType = this.inferExpressionType(loopStmt.expr);\r\n\r\n                            if (loopStmt.kind === 'While' && condType && !condType.isBool()) {\r\n                                this.log('verbose', `Loop condition has type ${condType.toString()}, not bool`);\r\n                            }\r\n                        }\r\n\r\n                        if (loopStmt.stmt) {\r\n                            this.validateStmt(loopStmt.stmt);\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────── [3.7] CTRLFLOW ──────────────────────────┐\r\n\r\n            private handleControlflowStmt(stmt: AST.StmtNode, scope?: Scope, moduleName?: string): void {\r\n                if(stmt.getCtrlflow === undefined) {\r\n                    const data = stmt;\r\n                    switch (stmt.kind) {\r\n                        case 'Return' : {\r\n                            const src = data.source as AST.ControlFlowStmtNode;\r\n                            const res = AST.ControlFlowStmtNode.asReturn(data.span, src.value);\r\n                            this.validateReturnStmt(res);\r\n                            break;\r\n                        }\r\n                        case 'Defer' : {\r\n                            const src = data.source as AST.ControlFlowStmtNode;\r\n                            const res = AST.ControlFlowStmtNode.asDefer(data.span, src.value);\r\n                            this.validateDeferStmt(res);\r\n                            break;\r\n                        }\r\n                        case 'Throw' : {\r\n                            const src = data.source as AST.ControlFlowStmtNode;\r\n                            const res = AST.ControlFlowStmtNode.asThrow(data.span, src.value);\r\n                            this.validateThrowStmt(res);\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    switch (stmt.getCtrlflow()!.kind) {\r\n                        case 'return' : {\r\n                            this.validateReturnStmt(stmt.getCtrlflow()!);\r\n                            break;\r\n                        }\r\n                        case 'defer' : {\r\n                            this.validateDeferStmt(stmt.getCtrlflow()!);\r\n                            break;\r\n                        }\r\n                        case 'throw' : {\r\n                            this.validateThrowStmt(stmt.getCtrlflow()!);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            private validateReturnStmt(returnNode: AST.ControlFlowStmtNode): void {\r\n                this.log('symbols', 'Validating return statement');\r\n\r\n                this.stats.returnsValidated++;\r\n                this.hasReturnStatement = true;\r\n\r\n                const isInFunction = this.isInsideFunctionScope();\r\n\r\n                if (returnNode.value) {\r\n                    const isConstructor = this.isConstructorExpression(returnNode.value);\r\n\r\n                    if (!isConstructor && this.isTypeExpression(returnNode.value)) {\r\n                        const functionReturnsType = this.currentFunctionReturnType && this.isTypeType(this.currentFunctionReturnType);\r\n\r\n                        if (!functionReturnsType) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Cannot return a type as a value. Expected a value of type '${this.currentFunctionReturnType?.toString() || 'void'}', got type expression`,\r\n                                returnNode.value.span\r\n                            );\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    this.log('verbose', `Inferring return expression type: ${returnNode.value.kind}`);\r\n                    const returnType = this.inferExpressionType(returnNode.value);\r\n                    this.log('verbose', `Return type inferred: ${returnType?.toString() || 'null'}`);\r\n\r\n                    // ✅ If type inference returned null AND errors were reported, stop here\r\n                    if (!returnType && this.config.services.diagnosticManager.hasErrors()) {\r\n                        this.log('verbose', 'Type inference failed with errors, aborting return validation');\r\n                        return;\r\n                    }\r\n\r\n                    if (isInFunction && this.currentFunctionReturnType) {\r\n                        if (returnType && !this.isTypeCompatible(this.currentFunctionReturnType, returnType)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Return type '${returnType.toString()}' doesn't match function return type '${this.currentFunctionReturnType.toString()}'`,\r\n                                returnNode.value.span\r\n                            );\r\n                        }\r\n                    } else if (!isInFunction) {\r\n                        this.reportError(\r\n                            DiagCode.ANALYSIS_ERROR,\r\n                            `Return statement outside of function`,\r\n                            returnNode.span\r\n                        );\r\n                    }\r\n                } else {\r\n                    if (isInFunction && this.currentFunctionReturnType && !this.currentFunctionReturnType.isVoid()) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Function expects return type '${this.currentFunctionReturnType.toString()}' but got void return`,\r\n                            returnNode.span\r\n                        );\r\n                    } else if (!isInFunction) {\r\n                        this.reportError(\r\n                            DiagCode.ANALYSIS_ERROR,\r\n                            `Return statement outside of function`,\r\n                            returnNode.span\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            // ✅ Helper to detect constructor expressions\r\n            private isConstructorExpression(expr: AST.ExprNode): boolean {\r\n                if (!expr.is('Primary')) return false;\r\n                const primary = expr.getPrimary();\r\n                if (!primary?.is('Object')) return false;\r\n                const obj = primary.getObject();\r\n                // Constructor has a type name: Point { x: 0, y: 0 }\r\n                return obj?.ident !== null && obj?.ident !== undefined;\r\n            }\r\n\r\n            private validateDeferStmt(deferNode: AST.ControlFlowStmtNode): void {\r\n                // this.stats.defersValidated++;\r\n\r\n                // Check if we're in a function scope by walking up the scope chain\r\n                const isInFunction = this.isInsideFunctionScope();\r\n\r\n                if (deferNode.value) {\r\n                    this.inferExpressionType(deferNode.value);\r\n                }\r\n\r\n                if (!isInFunction) {\r\n                    this.reportError(\r\n                        DiagCode.ANALYSIS_ERROR,\r\n                        `Defer statement outside of function`,\r\n                        deferNode.span\r\n                    );\r\n                }\r\n            }\r\n\r\n            private validateThrowStmt(throwNode: AST.ControlFlowStmtNode): void {\r\n                this.log('symbols', 'Validating throw statement');\r\n\r\n                // Mark that we encountered a throw statement\r\n                this.hasThrowStatement = true;\r\n\r\n                // Check if we're in a function scope\r\n                const isInFunction = this.isInsideFunctionScope();\r\n\r\n                if (!isInFunction) {\r\n                    this.reportError(\r\n                        DiagCode.ANALYSIS_ERROR,\r\n                        `Throw statement outside of function`,\r\n                        throwNode.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                // Get the current function's error type\r\n                const functionErrorType = this.getCurrentFunctionErrorType();\r\n\r\n                if (!functionErrorType) {\r\n                    this.reportError(\r\n                        DiagCode.THROW_WITHOUT_ERROR_TYPE,\r\n                        `Cannot throw error in function without error type. Add '!ErrorType' to function signature`,\r\n                        throwNode.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                // Validate the thrown expression\r\n                if (throwNode.value) {\r\n                    const thrownType = this.inferExpressionType(throwNode.value);\r\n\r\n                    if (!thrownType) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_INFERENCE_FAILED,\r\n                            `Cannot infer type of thrown expression`,\r\n                            throwNode.value.span\r\n                        );\r\n                        return;\r\n                    }\r\n\r\n                    // Validate that thrown type matches function's error type\r\n                    this.validateThrowType(thrownType, functionErrorType, throwNode.value.span);\r\n                } else {\r\n                    this.reportError(\r\n                        DiagCode.ANALYSIS_ERROR,\r\n                        `Throw statement must have an error value`,\r\n                        throwNode.span\r\n                    );\r\n                }\r\n            }\r\n\r\n            private validateThrowType(\r\n                thrownType: AST.TypeNode,\r\n                functionErrorType: AST.TypeNode,\r\n                span: AST.Span\r\n            ): void {\r\n                // CASE 1: Function has 'anyerror' - accepts ANY error type\r\n                if (this.isAnyErrorType(functionErrorType)) {\r\n                    if (!this.isErrorType(thrownType)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Cannot throw non-error type '${thrownType.toString()}'. Expected error type`,\r\n                            span\r\n                        );\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                // CASE 2: Specific error type - resolve both sides\r\n                const resolvedFunctionError = this.resolveIdentifierType(functionErrorType);\r\n                const resolvedThrownType = this.resolveIdentifierType(thrownType);\r\n\r\n                // Check if throwing the right error type or member\r\n                if (!this.isValidThrowType(resolvedThrownType, resolvedFunctionError, span)) {\r\n                    this.reportError(\r\n                        DiagCode.THROW_TYPE_MISMATCH,\r\n                        `Thrown error type '${thrownType.toString()}' is not compatible with function error type '${functionErrorType.toString()}'`,\r\n                        span\r\n                    );\r\n                }\r\n            }\r\n\r\n            private getCurrentFunctionErrorType(): AST.TypeNode | null {\r\n                // Check if we're in a function scope\r\n                const isInFunction = this.isInsideFunctionScope();\r\n\r\n                if(isInFunction && this.currentFunctionErrorType) {\r\n                    return this.currentFunctionErrorType;\r\n                }\r\n\r\n                // fallback\r\n                {\r\n                    let currentScope = this.config.services.scopeManager.getCurrentScope();\r\n\r\n                    // Walk up to find function scope\r\n                    while (currentScope && currentScope.kind !== ScopeKind.Function) {\r\n                        const parent = this.config.services.scopeManager.getScopeParent(currentScope.id);\r\n                        if (!parent) break;\r\n                        currentScope = parent;\r\n                    }\r\n\r\n                    if (!currentScope || currentScope.kind !== ScopeKind.Function) {\r\n                        return null;\r\n                    }\r\n\r\n                    // Find the function symbol\r\n                    const parentScope = this.config.services.scopeManager.getScopeParent(currentScope.id);\r\n                    if (!parentScope) return null;\r\n\r\n                    const funcSymbol = parentScope.symbols.get(currentScope.name);\r\n                    if (!funcSymbol || !funcSymbol.type || !funcSymbol.type.isFunction()) {\r\n                        return null;\r\n                    }\r\n\r\n                    const funcType = funcSymbol.type.getFunction()!;\r\n                    return funcType.errorType || null;\r\n                }\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────────── [4] EXPR Level ───────────────────────────┐\r\n\r\n            private inferExpressionType(expr: AST.ExprNode): AST.TypeNode | null {\r\n                if (!expr) return null;\r\n\r\n                const cacheKey = this.createCacheKey(expr);\r\n\r\n                if (this.inferenceStack.has(cacheKey)) {\r\n                    this.log('verbose', `Circular type inference detected for ${cacheKey}`);\r\n                    return null;\r\n                }\r\n\r\n                this.inferenceStack.add(cacheKey);\r\n                try {\r\n                    const inferredType = this.performTypeInference(expr);\r\n                    if (inferredType) {\r\n                        this.cacheType(cacheKey, inferredType);\r\n                        this.stats.typesInferred++;\r\n                    }\r\n                    return inferredType;\r\n                } finally {\r\n                    this.inferenceStack.delete(cacheKey);\r\n                }\r\n            }\r\n\r\n            private performTypeInference(expr: AST.ExprNode): AST.TypeNode | null {\r\n                this.config.services.contextTracker.pushContextSpan(expr.span);\r\n                try {\r\n                    switch (expr.kind) {\r\n                        case 'Primary':\r\n                            return this.inferPrimaryType(expr.getPrimary()!);\r\n                        case 'Binary':\r\n                            return this.inferBinaryType(expr.getBinary()!);\r\n                        case 'Prefix':\r\n                            return this.inferPrefixType(expr.getPrefix()!);\r\n                        case 'Postfix':\r\n                            return this.inferPostfixType(expr.getPostfix()!);\r\n                        case 'As':\r\n                            return this.inferAsType(expr.getAs()!);\r\n                        case 'Typeof': {\r\n                            const typeofNode = expr.getTypeof()!;\r\n                            const innerType = this.inferExpressionType(typeofNode.expr);\r\n\r\n                            if (!innerType) {\r\n                                this.reportError(\r\n                                    DiagCode.TYPE_INFERENCE_FAILED,\r\n                                    'Cannot infer type for typeof expression',\r\n                                    typeofNode.expr.span\r\n                                );\r\n                                return null;\r\n                            }\r\n\r\n                            // ✅ Return the 'type' primitive, NOT the actual type\r\n                            // This makes typeof return a TYPE (not usable in arithmetic)\r\n                            return AST.TypeNode.asPrimitive(expr.span, 'type');\r\n                        }\r\n\r\n                        case 'Sizeof': {\r\n                            const sizeofNode = expr.getSizeof()!;\r\n                            const targetType = this.inferExpressionType(sizeofNode.expr);\r\n\r\n                            if (!targetType) {\r\n                                this.reportError(\r\n                                    DiagCode.TYPE_INFERENCE_FAILED,\r\n                                    'Cannot infer type for sizeof expression',\r\n                                    sizeofNode.expr.span\r\n                                );\r\n                                return null;\r\n                            }\r\n\r\n                            // Compute size at compile time\r\n                            const size = this.computeTypeSize(targetType);\r\n\r\n                            if (size === null) {\r\n                                this.reportError(\r\n                                    DiagCode.INVALID_SIZEOF_TARGET,\r\n                                    `Cannot compute size of type '${targetType.toString()}'`,\r\n                                    sizeofNode.expr.span\r\n                                );\r\n                                return AST.TypeNode.asComptimeInt(expr.span, '0');\r\n                            }\r\n\r\n                            // Return as compile-time integer\r\n                            return AST.TypeNode.asComptimeInt(expr.span, size.toString());\r\n                        }\r\n                        case 'Orelse':\r\n                            return this.inferOrelseType(expr.getOrelse()!);\r\n                        case 'Range':\r\n                            return this.inferRangeType(expr.getRange()!);\r\n                        case 'Try':\r\n                            return this.inferTryType(expr.getTry()!);\r\n                        case 'Catch':\r\n                            return this.inferCatchType(expr.getCatch()!);\r\n                        case 'If':\r\n                            return this.inferIfType(expr.getIf()!);\r\n                        case 'Switch':\r\n                            return this.inferSwitchType(expr.getSwitch()!);\r\n                        default:\r\n                            return null;\r\n                    }\r\n                } finally {\r\n                    this.config.services.contextTracker.popContextSpan();\r\n                }\r\n            }\r\n\r\n            private computeTypeSize(type: AST.TypeNode): number | null {\r\n                // Resolve identifier types first\r\n                const resolved = this.resolveIdentifierType(type);\r\n                return this.ExpressionEvaluator.computeTypeSize(resolved);\r\n            }\r\n\r\n            private resolveTypeNode(typeNode: AST.TypeNode): void {\r\n                switch (typeNode.kind) {\r\n                    case 'struct':\r\n                        const tempSymbol: Symbol = {\r\n                            id: -1,\r\n                            name: '<struct-validation>',\r\n                            kind: SymbolKind.Definition,\r\n                            type: typeNode,\r\n                            scope: this.config.services.scopeManager.getCurrentScope().id,\r\n                            contextSpan: typeNode.span,\r\n                            declared: true,\r\n                            initialized: true,\r\n                            used: false,\r\n                            isTypeChecked: false,\r\n                            visibility: { kind: 'Private' },\r\n                            mutability: { kind: 'Immutable' },\r\n                            isExported: false\r\n                        };\r\n                        this.validateStructType(typeNode.getStruct()!, tempSymbol);\r\n                        break;\r\n\r\n                    case 'enum':\r\n                        const tempSymbol2: Symbol = {\r\n                            id: -1,\r\n                            name: '<enum-validation>',\r\n                            kind: SymbolKind.Definition,\r\n                            type: typeNode,\r\n                            scope: this.config.services.scopeManager.getCurrentScope().id,\r\n                            contextSpan: typeNode.span,\r\n                            declared: true,\r\n                            initialized: true,\r\n                            used: false,\r\n                            isTypeChecked: false,\r\n                            visibility: { kind: 'Private' },\r\n                            mutability: { kind: 'Immutable' },\r\n                            isExported: false\r\n                        };\r\n                        this.validateEnumType(typeNode.getEnum()!, tempSymbol2);\r\n                        break;\r\n\r\n                    case 'array':\r\n                        const arr = typeNode.getArray()!;\r\n                        this.resolveTypeNode(arr.target);\r\n                        if (arr.size) {\r\n                            this.validateArraySize(arr.size);\r\n                        }\r\n                        break;\r\n\r\n                    case 'optional':\r\n                        this.resolveTypeNode(typeNode.getOptional()!.target);\r\n                        break;\r\n\r\n                    case 'pointer':\r\n                        this.resolveTypeNode(typeNode.getPointer()!.target);\r\n                        break;\r\n\r\n                    case 'paren':\r\n                        this.resolveTypeNode(typeNode.getParen()!.type);\r\n                        break;\r\n\r\n                    case 'tuple':\r\n                        for (const field of typeNode.getTuple()!.fields) {\r\n                            this.resolveTypeNode(field);\r\n                        }\r\n                        break;\r\n\r\n                    case 'primitive': {\r\n                        // special case i/u width must be from 0 to 65535\r\n                        const src = typeNode.getPrimitive()!;\r\n\r\n                        if(src.isSigned() || src.isUnsigned()) {\r\n                            const width = src.width!;\r\n                            if(width < 0 || width > 65535) {\r\n                                this.reportError(DiagCode.INVALID_TYPE_WIDTH, `Type width must be from 0 to 65535`, typeNode.span);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // ✅ Helper method to check if expression is a type (not a value)\r\n            private isTypeExpression(expr: AST.ExprNode): boolean {\r\n                if (expr.kind === 'Primary') {\r\n                    const primary = expr.getPrimary();\r\n                    if (!primary) return false;\r\n\r\n                    // ✅ Check for Object FIRST before Type\r\n                    // Constructors are Objects with an ident: Point { x: 0 }\r\n                    if (primary.kind === 'Object') {\r\n                        const obj = primary.getObject();\r\n                        // If it has an ident, it's a constructor, NOT a type expression\r\n                        if (obj && obj.ident) {\r\n                            return false; // This is Point { x: 0 }, not a type\r\n                        }\r\n                        // If no ident, it's an anonymous object literal, also not a type\r\n                        return false;\r\n                    }\r\n\r\n                    // Direct type expression: return i32, return struct{}, etc.\r\n                    if (primary.kind === 'Type') {\r\n                        return true;\r\n                    }\r\n\r\n                    // Check if it's an identifier that refers to a type definition\r\n                    if (primary.kind === 'Ident') {\r\n                        const ident = primary.getIdent();\r\n                        if (!ident) return false;\r\n\r\n                        // Look up the symbol to check if it's a type definition\r\n                        const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                        if (symbol && symbol.kind === SymbolKind.Definition) {\r\n                            // It's a type definition (like returning `Point` instead of an instance)\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n            // ✅ Check if expression is the 'type' type\r\n            private isTypeType(typeNode: AST.TypeNode): boolean {\r\n                if (!typeNode.isPrimitive()) return false;\r\n                const prim = typeNode.getPrimitive();\r\n                return prim?.kind === 'type';\r\n            }\r\n\r\n            // ===== PRIMARY OPERATIONS =====\r\n\r\n            private inferPrimaryType(primary: AST.PrimaryNode): AST.TypeNode | null {\r\n                switch (primary.kind) {\r\n                    case 'Literal':\r\n                        return this.inferLiteralType(primary.getLiteral()!);\r\n                    case 'Ident':\r\n                        return this.inferIdentifierType(primary.getIdent()!);\r\n                    case 'Paren':\r\n                        const paren = primary.getParen()!;\r\n                        return paren.source ? this.inferExpressionType(paren.source) : null;\r\n                    case 'Tuple':\r\n                        return this.inferTupleType(primary.getTuple()!);\r\n                    case 'Object':\r\n                        return this.inferObjectType(primary.getObject()!);\r\n                    case 'Type':\r\n                        return primary.getType();\r\n                    default:\r\n                        return null;\r\n                }\r\n            }\r\n\r\n            private inferLiteralType(literal: AST.LiteralNode): AST.TypeNode {\r\n                switch (literal.kind) {\r\n                    case 'String':\r\n                        const str = literal.value as string;\r\n                        const sizeExpr = AST.ExprNode.asInteger(literal.span, str.length);\r\n                        return AST.TypeNode.asArray(literal.span, AST.TypeNode.asUnsigned(literal.span, 'u8', 8), sizeExpr);\r\n\r\n                    case 'Integer':\r\n                        return AST.TypeNode.asComptimeInt(literal.span, literal.value as string);\r\n\r\n                    case 'Float':\r\n                        return AST.TypeNode.asComptimeFloat(literal.span, literal.value as string);\r\n\r\n                    case 'Character':\r\n                        return AST.TypeNode.asUnsigned(literal.span, 'u8', 8);\r\n\r\n                    case 'Bool':\r\n                        return AST.TypeNode.asBool(literal.span);\r\n\r\n                    case 'Null':\r\n                        return AST.TypeNode.asNull(literal.span);\r\n\r\n                    case 'Undefined':\r\n                        return AST.TypeNode.asUndefined(literal.span);\r\n\r\n                    case 'Array':\r\n                        return this.inferArrayLiteralType(literal);\r\n\r\n                    default:\r\n                        return AST.TypeNode.asUndefined(literal.span);\r\n                }\r\n            }\r\n\r\n            private inferArrayLiteralType(literal: AST.LiteralNode): AST.TypeNode {\r\n                const elements = literal.value as AST.ExprNode[];\r\n\r\n                if (elements.length === 0) {\r\n                    const sizeExpr = AST.ExprNode.asInteger(literal.span, 0);\r\n                    return AST.TypeNode.asArray(literal.span, AST.TypeNode.asUndefined(literal.span), sizeExpr);\r\n                }\r\n\r\n                const firstType = this.inferExpressionType(elements[0]);\r\n                if (!firstType) {\r\n                    const sizeExpr = AST.ExprNode.asInteger(literal.span, elements.length);\r\n                    return AST.TypeNode.asArray(literal.span, AST.TypeNode.asUndefined(literal.span), sizeExpr);\r\n                }\r\n\r\n                for (let i = 1; i < elements.length; i++) {\r\n                    const elemType = this.inferExpressionType(elements[i]);\r\n                    if (!elemType || !this.isTypeCompatible(firstType, elemType)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            'Array elements have incompatible types',\r\n                            elements[i].span\r\n                        );\r\n                    }\r\n                }\r\n\r\n                const sizeExpr = AST.ExprNode.asInteger(literal.span, elements.length);\r\n                return AST.TypeNode.asArray(literal.span, firstType, sizeExpr);\r\n            }\r\n\r\n            private inferIdentifierType(ident: AST.IdentNode): AST.TypeNode | null {\r\n                // ✅ Handle 'self' - distinguish static vs instance context\r\n                if (ident.name === 'self') {\r\n                    // // ✅ In static methods, using 'self' alone is an error\r\n                    // if (this.currentIsStaticMethod && this.currentStructScope) {\r\n                    //     this.reportError(\r\n                    //         DiagCode.INVALID_STATIC_ACCESS,\r\n                    //         `Cannot use 'self' in static method. Use '${this.currentStructScope.name}' to access static members.`,\r\n                    //         ident.span\r\n                    //     );\r\n                    //     return null;\r\n                    // }\r\n\r\n                    // ✅ In instance methods, 'self' refers to the instance\r\n                    const selfSymbol = this.config.services.scopeManager.lookupSymbol('self');\r\n                    if (selfSymbol && selfSymbol.metadata?.isSelf) {\r\n                        selfSymbol.used = true; // ✅ Mark as used to prevent false warning\r\n                        return selfSymbol.type;\r\n                    }\r\n                }\r\n\r\n                // ✅ SECOND: Check direct field access in static method (without self)\r\n                if (this.currentIsStaticMethod && this.currentStructScope) {\r\n                    const fieldSymbol = this.currentStructScope.symbols.get(ident.name);\r\n\r\n                    if (fieldSymbol) {\r\n                        // Check if it's a struct field OR method\r\n                        if (fieldSymbol.kind === SymbolKind.StructField ||\r\n                            fieldSymbol.kind === SymbolKind.Function) {\r\n\r\n                            const isStatic = fieldSymbol.visibility.kind === 'Static';\r\n\r\n                            if (!isStatic) {\r\n                                const memberType = fieldSymbol.kind === SymbolKind.Function ? 'method' : 'field';\r\n                                this.reportError(\r\n                                    DiagCode.INVALID_STATIC_ACCESS,\r\n                                    `Cannot access instance ${memberType} '${ident.name}' in static method. Static methods can only access static ${memberType}s.`,\r\n                                    ident.span\r\n                                );\r\n                                return null;  // ✅ Stop processing and don't mark as used/resolved\r\n                            }\r\n\r\n                            // ✅ Valid static member - mark as used and continue\r\n                            fieldSymbol.used = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                if (!symbol) return null;\r\n\r\n                // Handle regular 'self' in instance methods\r\n                if (ident.name === 'self' && symbol.metadata?.isSelf) {\r\n                    symbol.used = true;\r\n                    return symbol.type;\r\n                }\r\n\r\n                if (symbol.type) return symbol.type;\r\n\r\n                if (symbol.kind === SymbolKind.Function && symbol.metadata) {\r\n                    const metadata = symbol.metadata as any;\r\n\r\n                    const paramTypes: AST.TypeNode[] = [];\r\n                    if (metadata.params && Array.isArray(metadata.params)) {\r\n                        for (const param of metadata.params) {\r\n                            if (param.type) {\r\n                                paramTypes.push(param.type);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    const returnType = metadata.returnType || null;\r\n\r\n                    const funcType = AST.TypeNode.asFunction(\r\n                        symbol.contextSpan || ident.span,\r\n                        paramTypes,\r\n                        returnType\r\n                    );\r\n\r\n                    symbol.type = funcType;\r\n                    return funcType;\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n            private validateMethodCallContext(\r\n                call: AST.CallNode,\r\n                methodSymbol: Symbol,\r\n                isStaticAccess: boolean,\r\n                baseExpr: AST.ExprNode\r\n            ): void {\r\n                const isStaticMethod = methodSymbol.visibility.kind === 'Static';\r\n\r\n                // ✅ CASE 1: Calling instance method on TYPE (Error)\r\n                if (isStaticAccess && !isStaticMethod) {\r\n                    this.reportError(\r\n                        DiagCode.INVALID_STATIC_ACCESS,\r\n                        `Cannot call instance method '${methodSymbol.name}' on type. Create an instance first.`,\r\n                        call.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                // ✅ CASE 2: Calling static method on INSTANCE (Error)\r\n                if (!isStaticAccess && isStaticMethod) {\r\n                    // // Get struct name from method's parent scope\r\n                    // const methodScope = this.config.services.scopeManager.getScope(methodSymbol.scope);\r\n                    // const structName = methodScope.name;\r\n\r\n                    // this.reportError(\r\n                    //     DiagCode.INVALID_STATIC_ACCESS,\r\n                    //     `Cannot call static method '${methodSymbol.name}' on instance. Use '${structName}.${methodSymbol.name}()' instead.`,\r\n                    //     call.span\r\n                    // );\r\n\r\n                    // Just continue - this is valid\r\n                    return;\r\n                }\r\n            }\r\n\r\n            private inferObjectType(obj: AST.ObjectNode): AST.TypeNode | null {\r\n                // CASE 1: Named constructor (MyStruct { ... })\r\n                if (obj.ident) {\r\n                    const typeSymbol = this.config.services.scopeManager.lookupSymbol(obj.ident.name);\r\n\r\n                    if (!typeSymbol) {\r\n                        this.reportError(\r\n                            DiagCode.UNDEFINED_IDENTIFIER,\r\n                            `Type '${obj.ident.name}' not found`,\r\n                            obj.span\r\n                        );\r\n                        return null;\r\n                    }\r\n\r\n                    if (!typeSymbol.type) {\r\n                        this.reportError(\r\n                            DiagCode.SYMBOL_NOT_FOUND,\r\n                            `Symbol '${obj.ident.name}' has no type`,\r\n                            obj.span\r\n                        );\r\n                        return null;\r\n                    }\r\n\r\n                    let actualType = typeSymbol.type;\r\n                    if (actualType.isIdent()) {\r\n                        const typeIdent = actualType.getIdent()!;\r\n                        const resolvedSymbol = this.config.services.scopeManager.lookupSymbol(typeIdent.name);\r\n                        if (resolvedSymbol && resolvedSymbol.type) {\r\n                            actualType = resolvedSymbol.type;\r\n                        }\r\n                    }\r\n\r\n                    if (actualType.isStruct()) {\r\n                        this.validateStructConstruction(obj, actualType, obj.span);\r\n                        return typeSymbol.type;\r\n                    } else {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `'${obj.ident.name}' is not a struct type`,\r\n                            obj.span\r\n                        );\r\n                        return null;\r\n                    }\r\n                }\r\n\r\n                // CASE 2: Anonymous object literal\r\n                const fields: AST.TypeNode[] = [];\r\n                const fieldNodes: AST.FieldNode[] = [];\r\n\r\n                for (const prop of obj.props) {\r\n                    const fieldType = prop.val\r\n                        ? this.inferExpressionType(prop.val)\r\n                        : AST.TypeNode.asUndefined(prop.key.span);\r\n\r\n                    if (!fieldType) {\r\n                        this.reportError(\r\n                            DiagCode.CANNOT_INFER_TYPE,\r\n                            `Cannot infer type for property '${prop.key.name}'`,\r\n                            prop.key.span\r\n                        );\r\n                        return null;\r\n                    }\r\n\r\n                    fields.push(fieldType);\r\n\r\n                    const fieldNode = AST.FieldNode.create(\r\n                        prop.key.span,\r\n                        { kind: 'Private' },\r\n                        { kind: 'Runtime' },\r\n                        { kind: 'Immutable' },\r\n                        prop.key,\r\n                        fieldType,\r\n                        prop.val || undefined\r\n                    );\r\n                    fieldNodes.push(fieldNode);\r\n                }\r\n\r\n                const members = fieldNodes.map(f => AST.StructMemberNode.createField(f.span, f));\r\n                return AST.TypeNode.asStruct(obj.span, members, 'Anonymous');\r\n            }\r\n\r\n            private inferTupleType(tuple: AST.ExprTupleNode): AST.TypeNode | null {\r\n                const fieldTypes: AST.TypeNode[] = [];\r\n\r\n                for (const field of tuple.fields) {\r\n                    const fieldType = this.inferExpressionType(field);\r\n                    if (!fieldType) return null;\r\n                    fieldTypes.push(fieldType);\r\n                }\r\n\r\n                return AST.TypeNode.asTuple(tuple.span, fieldTypes);\r\n            }\r\n\r\n            // ===== BINARY OPERATIONS =====\r\n\r\n            private inferBinaryType(binary: AST.BinaryNode): AST.TypeNode | null {\r\n                if (!binary.left || !binary.right) return null;\r\n\r\n               // console.log('>>> inferBinaryType called, kind:', binary.kind);\r\n\r\n                // ✅ Handle Assignment FIRST, before inferring operand types\r\n                if (binary.kind === 'Assignment') {\r\n                   // console.log('>>> ASSIGNMENT DETECTED in inferBinaryType');\r\n                    this.validateAssignment(binary);\r\n                    \r\n                    // Assignment expression evaluates to the right-hand side value\r\n                    return this.inferExpressionType(binary.right);\r\n                }\r\n\r\n                const leftType = this.inferExpressionType(binary.left);\r\n                const rightType = this.inferExpressionType(binary.right);\r\n\r\n                if (!leftType || !rightType) return null;\r\n\r\n                // ✅ Reject 'type' in arithmetic\r\n                if (this.isTypeType(leftType) || this.isTypeType(rightType)) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Cannot perform ${binary.kind} operation on type values`,\r\n                        binary.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                switch (binary.kind) {\r\n                    case 'Additive':\r\n                    case 'Multiplicative':\r\n                    case 'Power':\r\n                        // ✅ Validate operands are numeric\r\n                        if (!this.isNumericType(leftType) || !this.isNumericType(rightType)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Cannot perform ${binary.kind} operation on non-numeric types '${leftType.toString()}' and '${rightType.toString()}'`,\r\n                                binary.span\r\n                            );\r\n                            return null;\r\n                        }\r\n                        return this.promoteNumericTypes(leftType, rightType, binary.span);\r\n\r\n                    case 'Shift':\r\n                    case 'BitwiseAnd':\r\n                    case 'BitwiseXor':\r\n                    case 'BitwiseOr':\r\n                        // ✅ Validate operands are integers\r\n                        if (!this.isIntegerType(leftType) || !this.isIntegerType(rightType)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Bitwise operations require integer types, got '${leftType.toString()}' and '${rightType.toString()}'`,\r\n                                binary.span\r\n                            );\r\n                            return null;\r\n                        }\r\n                        return this.promoteNumericTypes(leftType, rightType, binary.span);\r\n\r\n                    case 'Equality':\r\n                    case 'Relational':\r\n                        return AST.TypeNode.asBool(binary.span);\r\n\r\n                    case 'LogicalAnd':\r\n                    case 'LogicalOr':\r\n                        return AST.TypeNode.asBool(binary.span);\r\n\r\n                    default:\r\n                        return null;\r\n                }\r\n            }\r\n\r\n            private validateAssignment(binary: AST.BinaryNode): void {\r\n                if (binary.kind !== 'Assignment') return;\r\n\r\n               // console.log('=== validateAssignment START ===');\r\n                this.stats.assignmentsValidated++;\r\n\r\n                const leftSymbol = this.extractSymbolFromExpression(binary.left);\r\n               // console.log('Assignment left symbol:', leftSymbol?.name, 'mutability:', leftSymbol?.mutability.kind);\r\n               // console.log('Left symbol kind:', leftSymbol?.kind);\r\n               // console.log('Left symbol scope:', leftSymbol?.scope);\r\n\r\n                if (leftSymbol) {\r\n                    // ✅ Check if the LEFT SIDE SYMBOL is immutable\r\n                    if (leftSymbol.mutability.kind === 'Immutable') {\r\n                        let symbolType = 'variable';\r\n                        if (leftSymbol.kind === SymbolKind.Parameter) {\r\n                            symbolType = 'parameter';\r\n                        } else if (leftSymbol.kind === SymbolKind.StructField) {\r\n                            symbolType = 'field';\r\n                        }\r\n\r\n                       // console.log('>>> MUTABILITY ERROR DETECTED <<<');\r\n                       // console.log('Symbol type:', symbolType);\r\n                       // console.log('Symbol name:', leftSymbol.name);\r\n                       // console.log('Error count before:', this.config.services.diagnosticManager.length());\r\n\r\n                        this.reportError(\r\n                            DiagCode.MUTABILITY_MISMATCH,\r\n                            `Cannot assign to immutable ${symbolType} '${leftSymbol.name}'`,\r\n                            binary.left.span\r\n                        );\r\n\r\n                       // console.log('Error count after:', this.config.services.diagnosticManager.length());\r\n                       // console.log('Has errors?', this.config.services.diagnosticManager.hasErrors());\r\n                       // console.log('=== validateAssignment EARLY RETURN ===');\r\n                        return; // ✅ Stop here - don't continue validation\r\n                    }\r\n                }\r\n\r\n               // console.log('Continuing with type compatibility check...');\r\n\r\n                // ✅ Type compatibility check\r\n                const leftType = this.inferExpressionType(binary.left);\r\n                const rightType = this.inferExpressionType(binary.right);\r\n\r\n                if (leftType && rightType && !this.isTypeCompatible(leftType, rightType)) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Cannot assign type '${rightType.toString()}' to '${leftType.toString()}'`,\r\n                        binary.right.span\r\n                    );\r\n                }\r\n\r\n                // ✅ Check for overflow\r\n                if (leftType) {\r\n                    this.validateValueFitsInType(binary.right, leftType);\r\n                }\r\n\r\n               // console.log('=== validateAssignment END ===');\r\n            }\r\n\r\n            private resolveStructFieldSymbol(structType: AST.TypeNode, fieldName: string): Symbol | null {\r\n                const struct = structType.getStruct()!;\r\n                const scopeId = struct.metadata?.scopeId as number | undefined;\r\n\r\n                if (scopeId !== undefined) {\r\n                    try {\r\n                        const typeScope = this.config.services.scopeManager.getScope(scopeId);\r\n                        return typeScope.symbols.get(fieldName) || null;\r\n                    } catch {\r\n                        return null;\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n\r\n            // ===== PREFIX OPERATIONS =====\r\n\r\n            private inferPrefixType(prefix: AST.PrefixNode): AST.TypeNode | null {\r\n                const exprType = this.inferExpressionType(prefix.expr);\r\n                if (!exprType) return null;\r\n\r\n                switch (prefix.kind) {\r\n                    case 'UnaryPlus':\r\n                    case 'UnaryMinus':\r\n                        if (!this.isNumericType(exprType)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Unary '${prefix.kind === 'UnaryMinus' ? '-' : '+'}' requires a numeric operand, got '${exprType.toString()}'`,\r\n                                prefix.expr.span\r\n                            );\r\n                            return null;\r\n                        }\r\n                        return this.computeUnaryResultType(exprType, prefix.kind === 'UnaryMinus', prefix.span);\r\n\r\n                    case 'Increment':\r\n                    case 'Decrement':\r\n                        if (!this.isNumericType(exprType)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `${prefix.kind} requires a numeric operand`,\r\n                                prefix.expr.span\r\n                            );\r\n                            return null;\r\n                        }\r\n                        return exprType;\r\n\r\n                    case 'LogicalNot':\r\n                        return AST.TypeNode.asBool(prefix.span);\r\n\r\n                    case 'BitwiseNot':\r\n                        if (!this.isIntegerType(exprType)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Bitwise not requires integer type, got '${exprType.toString()}'`,\r\n                                prefix.expr.span\r\n                            );\r\n                            return null;\r\n                        }\r\n                        return exprType;\r\n\r\n                    case 'Reference':\r\n                    // Check if the referenced variable is mutable\r\n                    // &mut_var should produce *mut T, &immut_var should produce *T\r\n                    let isMutablePointer = false;\r\n\r\n                    // Extract the symbol being referenced\r\n                    if (prefix.expr.is('Primary')) {\r\n                        const primary = prefix.expr.getPrimary();\r\n                        if (primary?.is('Ident')) {\r\n                            const ident = primary.getIdent();\r\n                            if (ident) {\r\n                                const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                                // If the variable is mutable, create a mutable pointer\r\n                                if (symbol && symbol.mutability.kind === 'Mutable') {\r\n                                    isMutablePointer = true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    return AST.TypeNode.asPointer(prefix.span, exprType, isMutablePointer);\r\n\r\n                    default:\r\n                        return null;\r\n                }\r\n            }\r\n\r\n            // ===== POSTFIX OPERATIONS =====\r\n\r\n            private inferPostfixType(postfix: AST.PostfixNode): AST.TypeNode | null {\r\n                switch (postfix.kind) {\r\n                    case 'Call':\r\n                        return this.inferCallType(postfix.getCall()!);\r\n\r\n                    case 'ArrayAccess':\r\n                        return this.inferArrayAccessType(postfix.getArrayAccess()!);\r\n\r\n                    case 'MemberAccess':\r\n                        return this.inferMemberAccessType(postfix.getMemberAccess()!);\r\n\r\n                    case 'Increment':\r\n                    case 'Decrement':\r\n                        const exprType = this.inferExpressionType(postfix.getAsExprNode()!);\r\n                        if (exprType && !this.isNumericType(exprType)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `${postfix.kind} requires numeric type`,\r\n                                postfix.span\r\n                            );\r\n                            return null;\r\n                        }\r\n                        return exprType;\r\n\r\n                    case 'Dereference':\r\n                        const ptrType = this.inferExpressionType(postfix.getAsExprNode()!);\r\n\r\n                        if (!ptrType) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_INFERENCE_FAILED,\r\n                                'Cannot infer type for dereference operation',\r\n                                postfix.span\r\n                            );\r\n                            return null;\r\n                        }\r\n\r\n                        // Must be a pointer type\r\n                        if (!ptrType.isPointer()) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Cannot dereference non-pointer type '${ptrType.toString()}'`,\r\n                                postfix.span\r\n                            );\r\n                            return null;\r\n                        }\r\n\r\n                        return ptrType.getPointer()!.target;\r\n\r\n                    default:\r\n                        return null;\r\n                }\r\n            }\r\n\r\n            private inferCallType(call: AST.CallNode): AST.TypeNode | null {\r\n                this.stats.callsValidated++;\r\n\r\n                // Check builtins FIRST\r\n                if (this.isBuiltinFunction(call.base)) {\r\n                    return this.validateBuiltinCall(call);\r\n                }\r\n\r\n                // ✅ Check if method call and validate context\r\n                if (call.base.is('Postfix')) {\r\n                    const postfix = call.base.getPostfix();\r\n                    if (postfix?.kind === 'MemberAccess') {\r\n                        const access = postfix.getMemberAccess()!;\r\n                        const baseType = this.inferExpressionType(access.base);\r\n\r\n                        if (baseType) {\r\n                            const resolvedBase = this.resolveIdentifierType(baseType);\r\n\r\n                            if (resolvedBase.isStruct()) {\r\n                                const memberName = this.extractMemberName(access.target);\r\n                                if (memberName) {\r\n                                    const struct = resolvedBase.getStruct()!;\r\n                                    const scopeId = struct.metadata?.scopeId as number | undefined;\r\n\r\n                                    if (scopeId !== undefined) {\r\n                                        const structScope = this.config.services.scopeManager.getScope(scopeId);\r\n                                        const methodSymbol = structScope.symbols.get(memberName);\r\n\r\n                                        if (methodSymbol && methodSymbol.kind === SymbolKind.Function) {\r\n                                            // ✅ Validate call context (static vs instance)\r\n                                            const isStaticAccess = this.isStaticMemberAccess(access.base);\r\n                                            this.validateMethodCallContext(call, methodSymbol, isStaticAccess, access.base);\r\n\r\n                                            // ✅ Validate visibility\r\n                                            this.validateMemberVisibility(methodSymbol, structScope, access.target.span);\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                return this.validateStructMethodCall(call, access, resolvedBase);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Regular function call...\r\n                const calleeSymbol = this.findCallTargetSymbol(call.base);\r\n                let calleeType = calleeSymbol ? calleeSymbol.type : this.inferExpressionType(call.base);\r\n\r\n                if (!calleeType) {\r\n                    return null;\r\n                }\r\n\r\n                if (calleeType.isFunction()) {\r\n                    return this.validateCallArgumentsWithContext(call, calleeType);\r\n                }\r\n\r\n                this.reportError(\r\n                    DiagCode.TYPE_MISMATCH,\r\n                    `Cannot call value of non-function type`,\r\n                    call.base.span\r\n                );\r\n                return null;\r\n            }\r\n\r\n            private validateMemberVisibility(\r\n                memberSymbol: Symbol,\r\n                structScope: Scope,\r\n                accessSpan: AST.Span\r\n            ): void {\r\n                // ✅ Public members are always accessible - skip check\r\n                if (memberSymbol.visibility.kind === 'Public') {\r\n                    return;\r\n                }\r\n\r\n                // ✅ Check if member is private and being accessed from outside\r\n                if (memberSymbol.visibility.kind === 'Private') {\r\n                    const currentScope = this.config.services.scopeManager.getCurrentScope();\r\n\r\n                    // Walk up to find if we're inside the same struct\r\n                    let isInsideStruct = false;\r\n                    let checkScope: Scope | null = currentScope;\r\n\r\n                    while (checkScope) {\r\n                        if (checkScope.id === structScope.id) {\r\n                            isInsideStruct = true;\r\n                            break;\r\n                        }\r\n\r\n                        if (checkScope.parent !== null) {\r\n                            checkScope = this.config.services.scopeManager.getScope(checkScope.parent);\r\n                        } else {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (!isInsideStruct) {\r\n                        this.reportError(\r\n                            DiagCode.SYMBOL_NOT_ACCESSIBLE,\r\n                            `Cannot access private ${memberSymbol.kind === SymbolKind.Function ? 'method' : 'field'} '${memberSymbol.name}' from outside struct`,\r\n                            accessSpan\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            private validateBuiltinCall(call: AST.CallNode): AST.TypeNode | null {\r\n                const builtinName = this.extractBuiltinName(call.base);\r\n                if (!builtinName) {\r\n                    this.reportError(\r\n                        DiagCode.INTERNAL_ERROR,\r\n                        'Failed to extract builtin name',\r\n                        call.base.span\r\n                    );\r\n                    return AST.TypeNode.asVoid(call.span);\r\n                }\r\n\r\n                // Look up builtin in global scope\r\n                const globalScope = this.config.services.scopeManager.getGlobalScope();\r\n                const builtinSymbol = globalScope.symbols.get(builtinName);\r\n\r\n                if (!builtinSymbol || !builtinSymbol.type) {\r\n                    this.reportError(\r\n                        DiagCode.UNDEFINED_BUILTIN,\r\n                        `Unknown builtin function '${builtinName}'`,\r\n                        call.base.span\r\n                    );\r\n                    return AST.TypeNode.asVoid(call.span);\r\n                }\r\n\r\n                const funcType = builtinSymbol.type;\r\n                if (!funcType.isFunction()) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `'${builtinName}' is not callable`,\r\n                        call.base.span\r\n                    );\r\n                    return AST.TypeNode.asVoid(call.span);\r\n                }\r\n\r\n                const func = funcType.getFunction()!;\r\n\r\n                // Check argument count\r\n                if (func.params.length !== call.args.length) {\r\n                    const code = func.params.length > call.args.length\r\n                        ? DiagCode.TOO_FEW_ARGUMENTS\r\n                        : DiagCode.TOO_MANY_ARGUMENTS;\r\n\r\n                    this.reportError(\r\n                        code,\r\n                        `Builtin '${builtinName}' expects ${func.params.length} argument(s), but got ${call.args.length}`,\r\n                        call.args.length ? { start: call.args[0].span.start, end: call.args[call.args.length-1].span.end } : call.span\r\n                    );\r\n                    return func.returnType || AST.TypeNode.asVoid(call.span);\r\n                }\r\n\r\n                // Validate argument types\r\n                for (let i = 0; i < func.params.length; i++) {\r\n                    const paramType = func.params[i];\r\n                    const arg = call.args[i];\r\n                    const argType = this.inferExpressionType(arg);\r\n\r\n                    if (!argType) continue;\r\n\r\n                    if (!this.isTypeCompatible(paramType, argType)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Argument type '${argType.toString()}' is not compatible with parameter type '${paramType.toString()}'`,\r\n                            arg.span\r\n                        );\r\n                    }\r\n                }\r\n\r\n                return func.returnType || AST.TypeNode.asVoid(call.span);\r\n            }\r\n\r\n            private validateStructMethodCall(\r\n                call: AST.CallNode,\r\n                access: AST.MemberAccessNode,\r\n                structType: AST.TypeNode\r\n            ): AST.TypeNode | null {\r\n                const methodName = this.extractMemberName(access.target);\r\n                if (!methodName) return null;\r\n\r\n                // Get the struct scope\r\n                const struct = structType.getStruct()!;\r\n                const scopeId = struct.metadata?.scopeId as number | undefined;\r\n\r\n                if (scopeId === undefined) {\r\n                    this.reportError(\r\n                        DiagCode.INTERNAL_ERROR,\r\n                        `Cannot find scope for struct method call`,\r\n                        call.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                const structScope = this.config.services.scopeManager.getScope(scopeId);\r\n\r\n                // Find the method symbol\r\n                const methodSymbol = structScope.symbols.get(methodName);\r\n                if (!methodSymbol || methodSymbol.kind !== SymbolKind.Function) {\r\n                    this.reportError(\r\n                        DiagCode.SYMBOL_NOT_FOUND,\r\n                        `Method '${methodName}' not found in struct`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                if (!methodSymbol.type || !methodSymbol.type.isFunction()) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `'${methodName}' is not a callable method`,\r\n                        call.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Actually validate the call arguments!\r\n                return this.validateMethodCall(call, methodSymbol, structScope, access.base);\r\n            }\r\n\r\n            private validateCallArgumentsWithContext(call: AST.CallNode, funcType: AST.TypeNode): AST.TypeNode | null {\r\n                const func = funcType.getFunction()!;\r\n\r\n                if (func.params.length !== call.args.length) {\r\n                    const code = func.params.length > call.args.length ?\r\n                        DiagCode.TOO_FEW_ARGUMENTS : DiagCode.TOO_MANY_ARGUMENTS;\r\n\r\n                    this.reportError(\r\n                        code,\r\n                        `Expected ${func.params.length} arguments, but got ${call.args.length}`,\r\n                        call.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                for (let i = 0; i < func.params.length; i++) {\r\n                    const paramType = func.params[i];\r\n                    const arg = call.args[i];\r\n\r\n                    let argType = this.inferExpressionTypeWithContext(arg, paramType);\r\n\r\n                    // Don't allow undefined/null argument types to pass\r\n                    if (!argType) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_INFERENCE_FAILED,\r\n                            `Cannot infer type for argument ${i + 1}`,\r\n                            arg.span\r\n                        );\r\n                        continue; // Skip to next argument\r\n                    }\r\n\r\n                    // Check compatibility BEFORE reporting error\r\n                    if (!this.isTypeCompatible(paramType, argType)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Argument type '${argType.toString()}' is not assignable to parameter type '${paramType.toString()}'`,\r\n                            arg.span\r\n                        );\r\n                    }\r\n                }\r\n\r\n                return func.returnType || AST.TypeNode.asVoid(call.span);\r\n            }\r\n\r\n            private inferExpressionTypeWithContext(expr: AST.ExprNode, expectedType?: AST.TypeNode): AST.TypeNode | null {\r\n                if (expectedType && expr.is('Primary')) {\r\n                    const primary = expr.getPrimary();\r\n                    if (primary && primary.is('Object')) {\r\n                        const obj = primary.getObject()!;\r\n\r\n                        if (!obj.ident) {\r\n                            const resolvedExpected = this.resolveIdentifierType(expectedType);\r\n\r\n                            if (resolvedExpected.isStruct()) {\r\n                                this.validateStructConstruction(obj, resolvedExpected, expr.span);\r\n                                return expectedType;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return this.inferExpressionType(expr);\r\n            }\r\n\r\n            private inferArrayAccessType(access: AST.ArrayAccessNode): AST.TypeNode | null {\r\n                const baseType = this.inferExpressionType(access.base);\r\n                const indexType = this.inferExpressionType(access.index);\r\n\r\n                if (!baseType) return null;\r\n\r\n                if (indexType && !this.isIntegerType(indexType)) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Array index must be integer type, got '${indexType.toString()}'`,\r\n                        access.index.span\r\n                    );\r\n                }\r\n\r\n                if (baseType.isArray()) {\r\n                    return baseType.getArray()!.target;\r\n                }\r\n\r\n                if (this.isStringType(baseType)) {\r\n                    return AST.TypeNode.asUnsigned(access.span, 'u8', 8);\r\n                }\r\n\r\n                this.reportError(\r\n                    DiagCode.TYPE_MISMATCH,\r\n                    `Cannot index non-array type '${baseType.toString()}'`,\r\n                    access.base.span\r\n                );\r\n                return null;\r\n            }\r\n\r\n            private inferMemberAccessType(access: AST.MemberAccessNode): AST.TypeNode | null {\r\n                // ✅ DEBUG: Log the current context\r\n                this.log('verbose', `inferMemberAccessType: currentIsStaticMethod=${this.currentIsStaticMethod}, currentStructScope=${this.currentStructScope?.name || 'null'}`);\r\n\r\n                // ✅ CRITICAL: Check wildcard imports FIRST, before inferring base type\r\n                if (access.base.is('Primary')) {\r\n                    const primary = access.base.getPrimary();\r\n                    if (primary?.is('Ident')) {\r\n                        const ident = primary.getIdent()!;\r\n\r\n                        if (ident?.name === 'self') {\r\n                            // ✅ In static methods, 'self.member' should error\r\n                            if (this.currentIsStaticMethod && this.currentStructScope) {\r\n                                const memberName = this.extractMemberName(access.target);\r\n                                if (!memberName) {\r\n                                    this.reportError(DiagCode.INTERNAL_ERROR, `Could not resolve member access on self`, access.target.span);\r\n                                    return null;\r\n                                }\r\n\r\n                                const memberSymbol = this.currentStructScope.symbols.get(memberName);\r\n\r\n                                if (!memberSymbol) {\r\n                                    this.reportError(DiagCode.SYMBOL_NOT_FOUND, `Member '${memberName}' not found in struct`, access.target.span);\r\n                                    return null;\r\n                                }\r\n\r\n                                const isStaticMember = memberSymbol.visibility.kind === 'Static';\r\n\r\n                                if (!isStaticMember) {\r\n                                    const memberType = memberSymbol.kind === SymbolKind.Function ? 'method' : 'field';\r\n                                    this.reportError(\r\n                                        DiagCode.INVALID_STATIC_ACCESS,\r\n                                        `Cannot access instance ${memberType} '${memberName}' via 'self' in static method. Static methods can only access static members.`,\r\n                                        access.target.span\r\n                                    );\r\n                                    return null;\r\n                                }\r\n\r\n                                // Valid static member access via self\r\n                                memberSymbol.used = true;\r\n                                return memberSymbol.type || null;\r\n                            }\r\n\r\n                            // ✅ Instance method - resolve self normally\r\n                            const selfSymbol = this.config.services.scopeManager.lookupSymbol('self');\r\n                            if (selfSymbol && selfSymbol.metadata?.isSelf) {\r\n                                selfSymbol.used = true;\r\n                                const selfType = selfSymbol.type;\r\n                                if (selfType) {\r\n                                    return this.resolveMemberOnUnwrappedType(selfType, access, null, false);\r\n                                }\r\n                            }\r\n\r\n                            return null;\r\n                        }\r\n\r\n                        const baseSymbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n\r\n                        // ✅ Handle wildcard import member access\r\n                        if (baseSymbol && baseSymbol.kind === SymbolKind.Use &&\r\n                            baseSymbol.metadata?.isWildcardImport) {\r\n\r\n                            return this.resolveWildcardMemberAccess(access, baseSymbol);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Continue with normal resolution...\r\n                let baseType = this.inferExpressionType(access.base);\r\n                if (!baseType) {\r\n                    return null;\r\n                }\r\n\r\n                // Handle dereference in base expression\r\n                if (access.base.is('Postfix')) {\r\n                    const postfix = access.base.getPostfix();\r\n                    if (postfix?.kind === 'Dereference') {\r\n                        if (baseType.isIdent()) {\r\n                            const ident = baseType.getIdent()!;\r\n                            const typeSymbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                            if (typeSymbol?.type) {\r\n                                baseType = typeSymbol.type;\r\n                            }\r\n                        }\r\n                        return this.resolveMemberOnUnwrappedType(baseType, access, null);\r\n                    }\r\n                }\r\n\r\n                let unwrappedType = baseType;\r\n                let optionalDepth = 0;\r\n\r\n                while (unwrappedType.isOptional()) {\r\n                    unwrappedType = unwrappedType.getOptional()!.target;\r\n                    optionalDepth++;\r\n                }\r\n\r\n                if (unwrappedType.isIdent()) {\r\n                    const ident = unwrappedType.getIdent()!;\r\n                    const typeSymbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                    if (typeSymbol?.type) {\r\n                        unwrappedType = typeSymbol.type;\r\n                    }\r\n                }\r\n\r\n                // ✅ Check if accessing static member on type identifier\r\n                const isStaticAccess = this.isStaticMemberAccess(access.base);\r\n\r\n                const memberType = this.resolveMemberOnUnwrappedType(\r\n                    unwrappedType,\r\n                    access,\r\n                    null,\r\n                    isStaticAccess\r\n                );\r\n\r\n                if (optionalDepth > 0 && memberType) {\r\n                    return AST.TypeNode.asOptional(access.span, memberType);\r\n                }\r\n\r\n                return memberType;\r\n            }\r\n\r\n            private resolveWildcardMemberAccess(\r\n                access: AST.MemberAccessNode,\r\n                wildcardSymbol: Symbol\r\n            ): AST.TypeNode | null {\r\n                const memberName = this.extractMemberName(access.target);\r\n                if (!memberName) {\r\n                    this.reportError(\r\n                        DiagCode.INTERNAL_ERROR,\r\n                        `Cannot extract member name from wildcard access`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                const targetModuleName = wildcardSymbol.importSource;\r\n                if (!targetModuleName) {\r\n                    this.reportError(\r\n                        DiagCode.INTERNAL_ERROR,\r\n                        `Wildcard import has no source module`,\r\n                        access.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Find target module scope\r\n                const targetModuleScope = this.findModuleScope(targetModuleName);\r\n                if (!targetModuleScope) {\r\n                    this.reportError(\r\n                        DiagCode.MODULE_SCOPE_NOT_FOUND,\r\n                        `Cannot find scope for module '${targetModuleName}'`,\r\n                        access.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Look up the member in the target module\r\n                const memberSymbol = targetModuleScope.symbols.get(memberName);\r\n                if (!memberSymbol) {\r\n                    // ✅ THIS IS THE ERROR THAT SHOULD FIRE\r\n                    this.reportError(\r\n                        DiagCode.SYMBOL_NOT_FOUND,\r\n                        `Module '${targetModuleName}' has no exported symbol '${memberName}'`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Check if symbol is exported\r\n                if (!memberSymbol.isExported) {\r\n                    this.reportError(\r\n                        DiagCode.SYMBOL_NOT_EXPORTED,\r\n                        `Symbol '${memberName}' is not exported from module '${targetModuleName}'`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Mark as used\r\n                memberSymbol.used = true;\r\n                wildcardSymbol.used = true;\r\n\r\n                // this.stats.memberAccessResolved++;\r\n\r\n                return memberSymbol.type;\r\n            }\r\n\r\n            private getFunctionNode(methodName: string, structScope: Scope): AST.FuncStmtNode | null {\r\n                const methodSymbol = structScope.symbols.get(methodName);\r\n                if (!methodSymbol || methodSymbol.kind !== SymbolKind.Function) {\r\n                    return null;\r\n                }\r\n\r\n                // The function node should be stored in metadata or we need to look it up\r\n                // For now, we'll rely on the visibility info from the symbol's metadata\r\n                return methodSymbol.metadata?.funcNode as AST.FuncStmtNode | null || null;\r\n            }\r\n\r\n            // ✅ Detect if base is a type identifier (for static access)\r\n            private isStaticMemberAccess(baseExpr: AST.ExprNode): boolean {\r\n                if (!baseExpr.is('Primary')) return false;\r\n\r\n                const primary = baseExpr.getPrimary();\r\n                if (!primary?.is('Ident')) return false;\r\n\r\n                const ident = primary.getIdent();\r\n                if (!ident) return false;\r\n\r\n                const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n\r\n                // Static access if it's a type definition (not an instance)\r\n                return symbol?.kind === SymbolKind.Definition;\r\n            }\r\n\r\n            // ✅ Add static flag parameter\r\n            private resolveMemberOnUnwrappedType(\r\n                type: AST.TypeNode,\r\n                access: AST.MemberAccessNode,\r\n                symbol?: Symbol | null,\r\n                isStaticAccess: boolean = false  // ✅ NEW parameter\r\n            ): AST.TypeNode | null {\r\n                if (type.isStruct()) {\r\n                    return this.resolveStructMember(type, access, symbol || null, isStaticAccess);\r\n                }\r\n\r\n                if (type.isEnum()) {\r\n                    return this.resolveEnumMember(type, access);\r\n                }\r\n\r\n                if (type.isErrset()) {\r\n                    return this.resolveEnumMember(type, access);\r\n                }\r\n\r\n                if (type.isOptional()) {\r\n                    const inner = type.getOptional()!.target;\r\n                    const result = this.resolveMemberOnUnwrappedType(inner, access, symbol, isStaticAccess);\r\n                    return result ? AST.TypeNode.asOptional(access.span, result) : null;\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n            // ✅ Enhanced struct member resolution with static checks\r\n            private resolveStructMember(\r\n                structType: AST.TypeNode,\r\n                access: AST.MemberAccessNode,\r\n                baseSymbol: Symbol | null,\r\n                isStaticAccess: boolean = false\r\n            ): AST.TypeNode | null {\r\n                const struct = structType.getStruct()!;\r\n                const memberName = this.extractMemberName(access.target);\r\n                if (!memberName) return null;\r\n\r\n                let structScope: Scope | null = null;\r\n\r\n                // ✅ PRIORITY 1: Use metadata scopeId (most reliable - unique per struct)\r\n                if (struct.metadata?.scopeId !== undefined) {\r\n                    try {\r\n                        structScope = this.config.services.scopeManager.getScope(struct.metadata.scopeId as number);\r\n                    } catch {\r\n                        structScope = null;\r\n                    }\r\n                }\r\n\r\n                // ✅ PRIORITY 2: Search by name only if metadata is missing\r\n                if (!structScope && struct.name && struct.name !== 'Anonymous') {\r\n                    // Search in CURRENT scope's children first (to find local Point, not imported Point)\r\n                    const currentScope = this.config.services.scopeManager.getCurrentScope();\r\n                    structScope = this.config.services.scopeManager.findChildScopeByNameFromId(\r\n                        struct.name,\r\n                        currentScope.id,\r\n                        ScopeKind.Type\r\n                    );\r\n\r\n                    // Fall back to global search if not found locally\r\n                    if (!structScope) {\r\n                        structScope = this.config.services.scopeManager.findScopeByName(struct.name, ScopeKind.Type);\r\n                    }\r\n                }\r\n\r\n                if (!structScope) {\r\n                    this.reportError(\r\n                        DiagCode.SYMBOL_NOT_FOUND,\r\n                        `Cannot find scope for struct type`,\r\n                        access.base.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // ✅ Look up the member symbol from the struct scope (where visibility was collected)\r\n                const memberSymbol = structScope.symbols.get(memberName);\r\n\r\n                if (!memberSymbol) {\r\n                    this.reportError(\r\n                        DiagCode.SYMBOL_NOT_FOUND,\r\n                        `Struct has no member '${memberName}'`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // ✅ Check visibility using the COLLECTED symbol, not the AST\r\n                if (memberSymbol.visibility.kind === 'Private') {\r\n                    this.reportError(\r\n                        DiagCode.SYMBOL_NOT_ACCESSIBLE,\r\n                        `Cannot access private ${memberSymbol.kind === SymbolKind.Function ? 'method' : 'field'} '${memberName}' from outside struct`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // ✅ Handle static vs instance access\r\n                const isStaticField = memberSymbol.visibility.kind === 'Static';\r\n\r\n                if (isStaticAccess && !isStaticField && memberSymbol.kind === SymbolKind.StructField) {\r\n                    this.reportError(\r\n                        DiagCode.INVALID_STATIC_ACCESS,\r\n                        `Cannot access instance field '${memberName}' on type. Use an instance instead.`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                if (!isStaticAccess && isStaticField && memberSymbol.kind === SymbolKind.StructField) {\r\n                    this.reportError(\r\n                        DiagCode.INVALID_STATIC_ACCESS,\r\n                        `Cannot access static field '${memberName}' on instance. Use '${struct.name}.${memberName}' instead.`,\r\n                        access.target.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                return memberSymbol.type || null;\r\n            }\r\n\r\n            private validateMethodCall(\r\n                call: AST.CallNode,\r\n                methodSymbol: Symbol,\r\n                structScope: Scope,\r\n                baseExpr: AST.ExprNode\r\n            ): AST.TypeNode | null {\r\n                this.log('symbols', `Validating method call '${methodSymbol.name}' on struct instance`);\r\n\r\n                if (!methodSymbol.type || !methodSymbol.type.isFunction()) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `'${methodSymbol.name}' is not a callable method`,\r\n                        call.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                const funcType = methodSymbol.type.getFunction()!;\r\n\r\n                if (funcType.params.length !== call.args.length) {\r\n                    const code = funcType.params.length > call.args.length ?\r\n                        DiagCode.TOO_FEW_ARGUMENTS : DiagCode.TOO_MANY_ARGUMENTS;\r\n\r\n                    this.reportError(\r\n                        code,\r\n                        `Expected ${funcType.params.length} arguments, but got ${call.args.length}`,\r\n                        call.span\r\n                    );\r\n                    return null;\r\n                }\r\n\r\n                // Validate arguments in CALLER'S scope, not struct scope\r\n                // Arguments are expressions evaluated in the calling context\r\n                for (let i = 0; i < funcType.params.length; i++) {\r\n                    const paramType = funcType.params[i];\r\n                    const arg = call.args[i];\r\n\r\n                    const argType = this.inferExpressionTypeWithContext(arg, paramType);\r\n\r\n                    if (!argType || !this.isTypeCompatible(paramType, argType)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Argument type '${argType?.toString() ?? 'unknown'}' is not assignable to parameter type '${paramType.toString()}'`,\r\n                            arg.span\r\n                        );\r\n                    }\r\n                }\r\n\r\n                return funcType.returnType || AST.TypeNode.asVoid(call.span);\r\n            }\r\n\r\n            private resolveEnumMember(enumType: AST.TypeNode, access: AST.MemberAccessNode): AST.TypeNode | null {\r\n                const memberName = this.extractMemberName(access.target);\r\n                if (!memberName) return null;\r\n\r\n                // Handle enum types\r\n                if (enumType.isEnum()) {\r\n                    const enumDef = enumType.getEnum()!;\r\n                    for (const variant of enumDef.variants) {\r\n                        if (variant.ident.name === memberName) {\r\n                            return variant.type || enumType;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // **FIXED**: Handle error types - use 'members' not 'variants'\r\n                if (enumType.isErrset()) {\r\n                    const errorType = enumType.getError()!;\r\n                    for (const member of errorType.members) {\r\n                        if (member.name === memberName) {\r\n                            // Return an identifier type for the error member\r\n                            return AST.TypeNode.asIdentifier(member.span, member.name);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this.reportError(\r\n                    DiagCode.SYMBOL_NOT_FOUND,\r\n                    `${enumType.isErrset() ? 'Error set' : 'enum'} has no variant '${memberName}'`,\r\n                    access.target.span\r\n                );\r\n                return null;\r\n            }\r\n\r\n            // ===== SPECIAL EXPRESSIONS =====\r\n\r\n            private inferAsType(asNode: AST.AsNode): AST.TypeNode | null {\r\n                const sourceType = this.inferExpressionType(asNode.base);\r\n                if (!sourceType) return null;\r\n\r\n                if (!this.canConvertTypes(sourceType, asNode.type)) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Cannot convert type '${sourceType.toString()}' to type '${asNode.type.toString()}'`,\r\n                        asNode.span\r\n                    );\r\n                }\r\n\r\n                return asNode.type;\r\n            }\r\n\r\n            private inferOrelseType(orelse: AST.OrelseNode): AST.TypeNode | null {\r\n                const leftType = this.inferExpressionType(orelse.left);\r\n                const rightType = this.inferExpressionType(orelse.right);\r\n\r\n                if (!leftType) return rightType;\r\n                if (!rightType) return leftType;\r\n\r\n                // Handle ?T ?? null -> T | null (union type)\r\n                if (leftType.isOptional()) {\r\n                    const unwrapped = leftType.getOptional()!.target;\r\n\r\n                    // If right side is null, return union of unwrapped type and null\r\n                    if (rightType.isNull()) {\r\n                        const result = AST.TypeNode.asUnion(orelse.span, [unwrapped, rightType]);\r\n                        return result;\r\n                    }\r\n\r\n                    return unwrapped;\r\n                }\r\n\r\n                return leftType;\r\n            }\r\n\r\n            private inferRangeType(range: AST.RangeNode): AST.TypeNode | null {\r\n                if (range.leftExpr) {\r\n                    const leftType = this.inferExpressionType(range.leftExpr);\r\n                    if (leftType && !this.isIntegerType(leftType)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Range start must be integer type, got '${leftType.toString()}'`,\r\n                            range.leftExpr.span\r\n                        );\r\n                    }\r\n                }\r\n\r\n                if (range.rightExpr) {\r\n                    const rightType = this.inferExpressionType(range.rightExpr);\r\n                    if (rightType && !this.isIntegerType(rightType)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Range end must be integer type, got '${rightType.toString()}'`,\r\n                            range.rightExpr.span\r\n                        );\r\n                    }\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n            private inferTryType(tryNode: AST.TryNode): AST.TypeNode | null {\r\n                const exprType = this.inferExpressionType(tryNode.expr);\r\n                if (!exprType) return null;\r\n                return exprType;\r\n            }\r\n\r\n            private inferCatchType(catchNode: AST.CatchNode): AST.TypeNode | null {\r\n                const leftType = this.inferExpressionType(catchNode.leftExpr);\r\n\r\n                const exprScope = this.config.services.scopeManager.findChildScopeByName('expr', ScopeKind.Expression);\r\n                if (exprScope) {\r\n                    this.config.services.contextTracker.withSavedState(() => {\r\n                        this.config.services.scopeManager.withScope(exprScope.id, () => {\r\n                            this.validateStmt(catchNode.rightStmt);\r\n                        });\r\n                    });\r\n                }\r\n\r\n                return leftType;\r\n            }\r\n\r\n            private inferIfType(ifNode: AST.IfNode): AST.TypeNode | null {\r\n                const condType = this.inferExpressionType(ifNode.condExpr);\r\n                if (condType && !condType.isBool()) {\r\n                    this.log('verbose', `If condition has type ${condType.toString()}, expected bool`);\r\n                }\r\n\r\n                const exprScope = this.config.services.scopeManager.findChildScopeByName('expr', ScopeKind.Expression);\r\n                if (exprScope) {\r\n                    this.config.services.contextTracker.withSavedState(() => {\r\n                        this.config.services.scopeManager.withScope(exprScope.id, () => {\r\n                            this.validateStmt(ifNode.thenStmt);\r\n                            if (ifNode.elseStmt) {\r\n                                this.validateStmt(ifNode.elseStmt);\r\n                            }\r\n                        });\r\n                    });\r\n                } else {\r\n                    this.validateStmt(ifNode.thenStmt);\r\n                    if (ifNode.elseStmt) {\r\n                        this.validateStmt(ifNode.elseStmt);\r\n                    }\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n            private inferSwitchType(switchNode: AST.SwitchNode): AST.TypeNode | null {\r\n                this.inferExpressionType(switchNode.condExpr);\r\n                this.validateSwitchExhaustiveness(switchNode);\r\n\r\n                const exprScope = this.config.services.scopeManager.findChildScopeByName('expr', ScopeKind.Expression);\r\n\r\n                for (const switchCase of switchNode.cases) {\r\n                    if (switchCase.expr) {\r\n                        this.inferExpressionType(switchCase.expr);\r\n                    }\r\n                    if (switchCase.stmt) {\r\n                        if (exprScope) {\r\n                            this.config.services.contextTracker.withSavedState(() => {\r\n                                this.config.services.scopeManager.withScope(exprScope.id, () => {\r\n                                    this.validateStmt(switchCase.stmt!);\r\n                                });\r\n                            });\r\n                        } else {\r\n                            this.validateStmt(switchCase.stmt);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (switchNode.defCase) {\r\n                    if (exprScope) {\r\n                        this.config.services.contextTracker.withSavedState(() => {\r\n                            this.config.services.scopeManager.withScope(exprScope.id, () => {\r\n                                this.validateStmt(switchNode.defCase!.stmt);\r\n                            });\r\n                        });\r\n                    } else {\r\n                        this.validateStmt(switchNode.defCase.stmt);\r\n                    }\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────────── [5] Ident Level ──────────────────────────┐\r\n\r\n            private resolveIdentifierType(type: AST.TypeNode): AST.TypeNode {\r\n                if (!type.isIdent()) return type;\r\n\r\n                const ident = type.getIdent()!;\r\n                if (ident.builtin) return type;\r\n\r\n                const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                if (symbol && symbol.type) {\r\n                    return this.resolveIdentifierType(symbol.type);\r\n                }\r\n\r\n                return type;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────────── [6] Type Level ───────────────────────────┐\r\n\r\n            private validateStructType(structType: AST.StructTypeNode, symbol: Symbol): void {\r\n                let typeScope: Scope | null = null;\r\n\r\n                if (structType.metadata?.scopeId !== undefined) {\r\n                    try {\r\n                        typeScope = this.config.services.scopeManager.getScope(structType.metadata.scopeId as number);\r\n                    } catch {\r\n                        typeScope = null;\r\n                    }\r\n                }\r\n\r\n                if (!typeScope && structType.name && structType.name !== 'Anonymous') {\r\n                    typeScope = this.config.services.scopeManager.findScopeByName(structType.name, ScopeKind.Type);\r\n                }\r\n\r\n                if (!typeScope) {\r\n                    typeScope = this.config.services.scopeManager.findChildScopeByNameFromId(\r\n                        symbol.name,\r\n                        symbol.scope,\r\n                        ScopeKind.Type\r\n                    );\r\n                }\r\n\r\n                if (!typeScope) {\r\n                    this.reportError(\r\n                        DiagCode.INTERNAL_ERROR,\r\n                        `Cannot find type scope for struct validation`,\r\n                        structType.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                this.config.services.contextTracker.withSavedState(() => {\r\n                    this.config.services.scopeManager.withScope(typeScope!.id, () => {\r\n                        for (const member of structType.members) {\r\n                            if (member.isField()) {\r\n                                const field = member.getField()!;\r\n\r\n                                // Validate field visibility\r\n                                if (field.visibility.kind === 'Static' && field.mutability.kind === 'Mutable') {\r\n                                    this.reportError(  // Changed from reportWarning\r\n                                        DiagCode.INVALID_VISIBILITY,\r\n                                        `Struct field '${field.ident.name}' cannot be 'static'`,\r\n                                        field.span\r\n                                    );\r\n                                    continue;  // Skip this field and continue with next\r\n                                }\r\n\r\n                                // Resolve field type\r\n                                if (field.type) {\r\n                                    this.resolveTypeNode(field.type);\r\n                                }\r\n\r\n                                // Validate field initializer\r\n                                if (field.initializer) {\r\n                                    const initType = this.inferExpressionType(field.initializer);\r\n\r\n                                    if (field.type && initType) {\r\n                                        // Use shared helper for array validation\r\n                                        if (!this.validateArrayAssignment(\r\n                                            field.type,\r\n                                            initType,\r\n                                            field.initializer.span,\r\n                                            `Field '${field.ident.name}' initializer`\r\n                                        )) {\r\n                                            continue; // Skip to next field\r\n                                        }\r\n\r\n                                        if (!this.isTypeCompatible(field.type, initType)) {\r\n                                            this.reportError(\r\n                                                DiagCode.TYPE_MISMATCH,\r\n                                                `Field '${field.ident.name}' initializer type '${initType.toString()}' doesn't match field type '${field.type.toString()}'`,\r\n                                                field.initializer.span\r\n                                            );\r\n                                        }\r\n                                    } else if (!field.type && initType) {\r\n                                        field.type = initType;\r\n                                    }\r\n\r\n                                    // Check for overflow before compatibility check\r\n                                    if(field.type) {\r\n                                        this.validateValueFitsInType(field.initializer, field.type);\r\n                                    } else if(initType) {\r\n                                        this.validateValueFitsInType(field.initializer, initType);\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                const method = member.getMethod()!;\r\n\r\n                                // Validate method visibility\r\n                                // Static methods are valid in structs\r\n                                this.validateFuncStmt(method);\r\n                            }\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n\r\n            private validateStructConstruction(\r\n                objNode: AST.ObjectNode,\r\n                structType: AST.TypeNode,\r\n                initSpan: AST.Span\r\n            ): boolean {\r\n                if (!structType.isStruct()) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Cannot initialize non-struct type with object literal`,\r\n                        initSpan\r\n                    );\r\n                    return false;\r\n                }\r\n\r\n                const struct = structType.getStruct()!;\r\n\r\n                // Validate constructor name matches type name\r\n                if (objNode.ident) {\r\n                    const constructorName = objNode.ident.name;\r\n                    const expectedName = struct.name || this.extractTypeName(structType);\r\n\r\n                    if (expectedName && constructorName !== expectedName) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Constructor '${constructorName}' does not match expected type '${expectedName}'`,\r\n                            objNode.ident.span\r\n                        );\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                // Build map of struct fields\r\n                const structFields = new Map<string, AST.FieldNode>();\r\n                for (const member of struct.members) {\r\n                    if (member.isField()) {\r\n                        const field = member.source as AST.FieldNode;\r\n                        structFields.set(field.ident.name, field);\r\n                    }\r\n                }\r\n\r\n                const providedFields = new Set<string>();\r\n\r\n                // Validate each provided field\r\n                for (const prop of objNode.props) {\r\n                    const fieldName = prop.key.name;\r\n                    providedFields.add(fieldName);\r\n\r\n                    const structField = structFields.get(fieldName);\r\n                    if (!structField) {\r\n                        this.reportError(\r\n                            DiagCode.SYMBOL_NOT_FOUND,\r\n                            `Struct '${struct.name || '<anonymous>'}' has no field '${fieldName}'`,\r\n                            prop.key.span\r\n                        );\r\n                        continue;\r\n                    }\r\n\r\n                    // ✅ Check if trying to initialize static field\r\n                    if (structField.visibility.kind === 'Static') {\r\n                        this.reportError(\r\n                            DiagCode.INVALID_STATIC_ACCESS,\r\n                            `Cannot initialize static field '${fieldName}' in constructor. Static fields belong to the type, not instances.`,\r\n                            prop.key.span\r\n                        );\r\n                        continue;\r\n                    }\r\n\r\n                    // Validate field value type\r\n                    if (prop.val && structField.type) {\r\n                        const valueType = this.inferExpressionType(prop.val);\r\n\r\n                        if (valueType && !this.isTypeCompatible(structField.type, valueType)) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Field '${fieldName}' expects type '${structField.type.toString()}' but got '${valueType.toString()}'`,\r\n                                prop.val.span\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Check for missing required fields (skip static fields)\r\n                let hasMissingFields = false;\r\n                for (const [fieldName, field] of structFields) {\r\n                    // ✅ Skip static fields - they belong to the type, not instances\r\n                    if (field.visibility.kind === 'Static') {\r\n                        continue;\r\n                    }\r\n\r\n                    if (!providedFields.has(fieldName) && !field.initializer) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Missing required field '${fieldName}' in struct initialization`,\r\n                            initSpan\r\n                        );\r\n                        hasMissingFields = true;\r\n                    }\r\n                }\r\n\r\n                return !hasMissingFields;\r\n            }\r\n\r\n            private validateEnumType(enumType: AST.EnumTypeNode, symbol: Symbol): void {\r\n                const typeScope = this.config.services.scopeManager.findChildScopeByName(symbol.name, ScopeKind.Type);\r\n                if (!typeScope) return;\r\n\r\n                this.config.services.contextTracker.withSavedState(() => {\r\n                    this.config.services.scopeManager.withScope(typeScope.id, () => {\r\n                        for (const variant of enumType.variants) {\r\n                            if (variant.type) {\r\n                                this.resolveTypeNode(variant.type);\r\n                            }\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n\r\n            private validateArraySize(sizeExpr: AST.ExprNode): void {\r\n                // Track errors before evaluation\r\n                const errorCountBefore = this.config.services.diagnosticManager.length();\r\n\r\n                // Try to evaluate the expression at compile-time\r\n                const comptimeValue = this.ExpressionEvaluator.evaluateComptimeExpression(sizeExpr);\r\n\r\n                // Check if evaluation added errors (type errors, overflow, etc.)\r\n                const errorCountAfter = this.config.services.diagnosticManager.length();\r\n                const evaluationFailed = errorCountAfter > errorCountBefore;\r\n\r\n                // If evaluation failed (added errors), stop here - don't add more errors\r\n                if (evaluationFailed) {\r\n                    return;\r\n                }\r\n\r\n                // If evaluation returned null but didn't report errors, it's not a constant expression\r\n                if (comptimeValue === null) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        'Array size must be a compile-time constant expression',\r\n                        sizeExpr.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                // Validate the computed size is positive\r\n                if (comptimeValue <= BigInt(0)) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Array size must be positive, got ${comptimeValue}`,\r\n                        sizeExpr.span\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                // Check for reasonable size limits\r\n                const MAX_ARRAY_SIZE = BigInt(2_147_483_647);\r\n                if (comptimeValue > MAX_ARRAY_SIZE) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Array size ${comptimeValue} exceeds maximum allowed size ${MAX_ARRAY_SIZE}`,\r\n                        sizeExpr.span\r\n                    );\r\n                    return;\r\n                }\r\n            }\r\n\r\n            private validateSwitchExhaustiveness(switchNode: AST.SwitchNode): void {\r\n                const condType = this.inferExpressionType(switchNode.condExpr);\r\n                if (!condType) return;\r\n\r\n                // Resolve identifier types first\r\n                let resolvedType = condType;\r\n                if (condType.isIdent()) {\r\n                    const ident = condType.getIdent()!;\r\n                    const typeSymbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                    if (typeSymbol && typeSymbol.type) {\r\n                        resolvedType = typeSymbol.type;\r\n                    }\r\n                }\r\n\r\n                // Handle enum exhaustiveness\r\n                if (resolvedType.isEnum()) {\r\n                    const enumType = resolvedType.getEnum()!;\r\n                    const coveredVariants = new Set<string>();\r\n\r\n                    for (const switchCase of switchNode.cases) {\r\n                        if (switchCase.expr) {\r\n                            const variantName = this.extractEnumVariantName(switchCase.expr);\r\n                            if (variantName) {\r\n                                coveredVariants.add(variantName);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // Check exhaustiveness only if no default case\r\n                    if (!switchNode.defCase) {\r\n                        const missingVariants: string[] = [];\r\n                        for (const variant of enumType.variants) {\r\n                            if (!coveredVariants.has(variant.ident.name)) {\r\n                                missingVariants.push(variant.ident.name);\r\n                            }\r\n                        }\r\n\r\n                        if (missingVariants.length > 0) {\r\n                            this.reportError(\r\n                                DiagCode.TYPE_MISMATCH,\r\n                                `Switch is not exhaustive. Missing variants: ${missingVariants.join(', ')}`,\r\n                                switchNode.span\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Handle boolean exhaustiveness\r\n                if (resolvedType.isBool()) {\r\n                    const hasTrue = switchNode.cases.some((c: AST.CaseNode) => this.isBoolLiteral(c.expr, true));\r\n                    const hasFalse = switchNode.cases.some((c: AST.CaseNode) => this.isBoolLiteral(c.expr, false));\r\n\r\n                    if (!switchNode.defCase && (!hasTrue || !hasFalse)) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            'Switch on boolean must handle both true and false cases or have a default',\r\n                            switchNode.span\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            private validateArrayAssignment(\r\n                declaredType: AST.TypeNode,\r\n                initType: AST.TypeNode,\r\n                initSpan: AST.Span,\r\n                contextName: string\r\n            ): boolean {\r\n                if (!declaredType.isArray() || !initType.isArray()) {\r\n                    return true; // Not an array assignment, validation not applicable\r\n                }\r\n\r\n                const targetArray = declaredType.getArray()!;\r\n                const sourceArray = initType.getArray()!;\r\n\r\n                if (!targetArray.size || !sourceArray.size) {\r\n                    return true; // No size constraints to validate\r\n                }\r\n\r\n                const targetSize = this.ExpressionEvaluator.extractIntegerValue(targetArray.size);\r\n                const sourceSize = this.ExpressionEvaluator.extractIntegerValue(sourceArray.size);\r\n\r\n                if (targetSize === undefined || sourceSize === undefined) {\r\n                    return true; // Cannot extract sizes, skip validation\r\n                }\r\n\r\n                if (targetSize !== sourceSize) {\r\n                    const msg = sourceSize > targetSize\r\n                        ? `Array literal has more elements than the fixed array type`\r\n                        : `Array literal has fewer elements than the fixed array type`;\r\n\r\n                    this.reportError(\r\n                        DiagCode.ARRAY_SIZE_MISMATCH,\r\n                        `${msg}`,\r\n                        initSpan\r\n                    );\r\n                    return false; // Validation failed\r\n                }\r\n\r\n                return true; // Sizes match, validation passed\r\n            }\r\n\r\n            private checkCircularTypeDependency(\r\n                typeNode: AST.TypeNode,\r\n                typeName: string,\r\n                allowIndirection: boolean = false,\r\n                pathHasIndirection: boolean = false\r\n            ): boolean {\r\n                const key = `${typeName}:${typeNode.kind}:${typeNode.span.start}`;\r\n\r\n                if (this.circularTypeDetectionStack.has(key)) {\r\n                    if (!pathHasIndirection) {\r\n                        this.reportError(\r\n                            DiagCode.TYPE_MISMATCH,\r\n                            `Circular type dependency detected for '${typeName}'. Use pointer or optional to break the cycle.`,\r\n                            typeNode.span\r\n                        );\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                }\r\n\r\n                this.circularTypeDetectionStack.add(key);\r\n\r\n                try {\r\n                    switch (typeNode.kind) {\r\n                        case 'ident': {\r\n                            const ident = typeNode.getIdent()!;\r\n                            if (!ident.builtin && ident.name === typeName) {\r\n                                if (!pathHasIndirection) {\r\n                                    this.reportError(\r\n                                        DiagCode.TYPE_MISMATCH,\r\n                                        `Direct self-reference in type '${typeName}'. Use pointer or optional to break the cycle.`,\r\n                                        typeNode.span\r\n                                    );\r\n                                    return true;\r\n                                }\r\n                                return false;\r\n                            }\r\n\r\n                            if (!ident.builtin) {\r\n                                const typeSymbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                                if (typeSymbol && typeSymbol.type && typeSymbol.kind === SymbolKind.Definition) {\r\n                                    return this.checkCircularTypeDependency(\r\n                                        typeSymbol.type,\r\n                                        typeName,\r\n                                        allowIndirection,\r\n                                        pathHasIndirection\r\n                                    );\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        case 'array':\r\n                            return this.checkCircularTypeDependency(\r\n                                typeNode.getArray()!.target,\r\n                                typeName,\r\n                                allowIndirection,\r\n                                pathHasIndirection\r\n                            );\r\n\r\n                        case 'optional':\r\n                        case 'pointer':\r\n                            if (allowIndirection) {\r\n                                return false;\r\n                            }\r\n                            return this.checkCircularTypeDependency(\r\n                                typeNode.kind === 'optional'\r\n                                    ? typeNode.getOptional()!.target\r\n                                    : typeNode.getPointer()!.target,\r\n                                typeName,\r\n                                allowIndirection,\r\n                                true\r\n                            );\r\n\r\n                        case 'tuple':\r\n                            for (const field of typeNode.getTuple()!.fields) {\r\n                                if (this.checkCircularTypeDependency(\r\n                                    field,\r\n                                    typeName,\r\n                                    allowIndirection,\r\n                                    pathHasIndirection\r\n                                )) {\r\n                                    return true;\r\n                                }\r\n                            }\r\n                            break;\r\n\r\n                        case 'struct': {\r\n                            const struct = typeNode.getStruct()!;\r\n                            for (const member of struct.members) {\r\n                                if (member.isField()) {\r\n                                    const field = member.source as AST.FieldNode;\r\n                                    if (field.type && this.checkCircularTypeDependency(\r\n                                        field.type,\r\n                                        typeName,\r\n                                        allowIndirection,\r\n                                        pathHasIndirection\r\n                                    )) {\r\n                                        return true;\r\n                                    }\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        case 'enum': {\r\n                            const enumType = typeNode.getEnum()!;\r\n                            for (const variant of enumType.variants) {\r\n                                if (variant.type && this.checkCircularTypeDependency(\r\n                                    variant.type,\r\n                                    typeName,\r\n                                    allowIndirection,\r\n                                    pathHasIndirection\r\n                                )) {\r\n                                    return true;\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        case 'union': {\r\n                            const unionType = typeNode.getUnion()!;\r\n                            for (const member of unionType.types) {\r\n                                if (this.checkCircularTypeDependency(\r\n                                    member,\r\n                                    typeName,\r\n                                    allowIndirection,\r\n                                    pathHasIndirection\r\n                                )) {\r\n                                    return true;\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        case 'paren': {\r\n                            return this.checkCircularTypeDependency(\r\n                                typeNode.getParen()!.type,\r\n                                typeName,\r\n                                allowIndirection,\r\n                                pathHasIndirection\r\n                            )\r\n                        }\r\n                    }\r\n\r\n                    return false;\r\n                } finally {\r\n                    this.circularTypeDetectionStack.delete(key);\r\n                }\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private isTypeCompatible(target: AST.TypeNode, source: AST.TypeNode): boolean {\r\n                this.stats.compatibilityChecks++;\r\n\r\n                // any accepts everything\r\n                if (this.isAnyType(target)) return true;\r\n\r\n                // ✅ anyerror accepts any error type or error member\r\n                if (this.isAnyErrorType(target)) {\r\n                    // Accept any error type or error member identifier\r\n                    if (this.isErrorType(source)) {\r\n                        return true;\r\n                    }\r\n\r\n                    // ✅ Check if source is an error member (identifier that resolves to error)\r\n                    if (source.isIdent()) {\r\n                        const sourceIdent = source.getIdent()!;\r\n                        const sourceSymbol = this.config.services.scopeManager.lookupSymbol(sourceIdent.name);\r\n\r\n                        // If it's an error member, it's compatible with anyerror\r\n                        if (sourceSymbol && sourceSymbol.kind === SymbolKind.Error) {\r\n                            return true;\r\n                        }\r\n                    }\r\n\r\n                    return false;\r\n                }\r\n\r\n                if (this.isSameType(target, source)) return true;\r\n\r\n                const resolvedTarget = this.resolveIdentifierType(target);\r\n                const resolvedSource = this.resolveIdentifierType(source);\r\n\r\n                if (this.isSameType(resolvedTarget, resolvedSource)) return true;\r\n\r\n                // ✅ Handle error member to anyerror conversion\r\n                if (this.isAnyErrorType(resolvedTarget)) {\r\n                    if (this.isErrorType(resolvedSource)) {\r\n                        return true;\r\n                    }\r\n\r\n                    // Check if resolved source is an error member\r\n                    if (resolvedSource.isIdent()) {\r\n                        const ident = resolvedSource.getIdent()!;\r\n                        const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                        if (symbol && symbol.kind === SymbolKind.Error) {\r\n                            return true;\r\n                        }\r\n                    }\r\n\r\n                    return false;\r\n                }\r\n\r\n                // Bool is NOT compatible with numeric types\r\n                if (resolvedSource.isBool() && this.isNumericType(resolvedTarget)) {\r\n                    return false;\r\n                }\r\n\r\n                if (this.isNumericType(resolvedTarget) && this.isNumericType(resolvedSource)) {\r\n                    return this.areNumericTypesCompatible(resolvedTarget, resolvedSource);\r\n                }\r\n\r\n                // Handle union-to-union compatibility\r\n                if (resolvedTarget.isUnion() && resolvedSource.isUnion()) {\r\n                    const targetUnion = resolvedTarget.getUnion()!;\r\n                    const sourceUnion = resolvedSource.getUnion()!;\r\n\r\n                    // Every type in source must be compatible with at least one type in target\r\n                    return sourceUnion.types.every((sourceType: AST.TypeNode) =>\r\n                        targetUnion.types.some((targetType: AST.TypeNode) =>\r\n                            this.isTypeCompatible(targetType, sourceType)\r\n                        )\r\n                    );\r\n                }\r\n\r\n                if (resolvedTarget.isOptional()) {\r\n                    if (resolvedSource.isNull() || resolvedSource.isUndefined()) return true;\r\n                    const targetInner = resolvedTarget.getOptional()!.target;\r\n                    return this.isTypeCompatible(targetInner, source);\r\n                }\r\n\r\n                if (resolvedTarget.isArray() && resolvedSource.isArray()) {\r\n                    return this.areArrayTypesCompatible(resolvedTarget, resolvedSource);\r\n                }\r\n\r\n                if (resolvedTarget.isPointer()) {\r\n                    if (resolvedSource.isNull()) return true;\r\n                    if (resolvedSource.isPointer()) {\r\n                        return this.arePointerTypesCompatible(resolvedTarget, resolvedSource);\r\n                    }\r\n                }\r\n\r\n                if (resolvedTarget.isTuple() && resolvedSource.isTuple()) {\r\n                    return this.areTupleTypesCompatible(resolvedTarget, resolvedSource);\r\n                }\r\n\r\n                if (resolvedTarget.isStruct() && resolvedSource.isStruct()) {\r\n                    return this.areStructTypesCompatible(resolvedTarget, resolvedSource);\r\n                }\r\n\r\n                if (resolvedTarget.isEnum() && resolvedSource.isEnum()) {\r\n                    return this.isSameType(resolvedTarget, resolvedSource);\r\n                }\r\n\r\n                if (resolvedTarget.isUnion()) {\r\n                    const unionType = resolvedTarget.getUnion()!;\r\n                    return unionType.types.some((type: AST.TypeNode) => this.isTypeCompatible(type, source));\r\n                }\r\n\r\n                // Handle optional-to-union conversion\r\n                // ?T is compatible with T | null\r\n                if (resolvedSource.isOptional()) {\r\n                    const sourceInner = resolvedSource.getOptional()!.target;\r\n\r\n                    // If target is union, check if it contains both the inner type and null\r\n                    if (resolvedTarget.isUnion()) {\r\n                        const unionType = resolvedTarget.getUnion()!;\r\n                        const hasInnerType = unionType.types.some((t: AST.TypeNode) =>\r\n                            this.isTypeCompatible(t, sourceInner)\r\n                        );\r\n                        const hasNull = unionType.types.some((t: AST.TypeNode) => t.isNull());\r\n                        return hasInnerType && hasNull;\r\n                    }\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n            private isNumericType(type: AST.TypeNode): boolean {\r\n                // ✅ Exclude 'type' primitive\r\n                if (this.isTypeType(type)) {\r\n                    return false;\r\n                }\r\n\r\n                return type.isFloat() || type.isSigned() || type.isUnsigned() ||\r\n                       type.isComptimeInt() || type.isComptimeFloat();\r\n            }\r\n\r\n            private isAnyType(type: AST.TypeNode): boolean {\r\n                if (!type.isPrimitive()) return false;\r\n                const prim = type.getPrimitive();\r\n                return prim?.kind === 'any';\r\n            }\r\n\r\n            private isIntegerType(type: AST.TypeNode): boolean {\r\n                return type.isSigned() || type.isUnsigned() || type.isComptimeInt();\r\n            }\r\n\r\n            private isStringType(type: AST.TypeNode): boolean {\r\n                if (!type.isArray()) return false;\r\n                const arrayType = type.getArray()!;\r\n                const elemType = arrayType.target;\r\n                return elemType.isUnsigned() && elemType.getWidth() === 8;\r\n            }\r\n\r\n            private isAnyErrorType(type: AST.TypeNode): boolean {\r\n                if (!type.isPrimitive()) return false;\r\n                const prim = type.getPrimitive();\r\n                return prim?.kind === 'err';\r\n            }\r\n\r\n            private isErrorType(type: AST.TypeNode): boolean {\r\n                // Direct error set: error{A, B, C}\r\n                if (type.isErrset()) {\r\n                    return true;\r\n                }\r\n\r\n                // Error identifier: check if it resolves to an error type\r\n                if (type.isIdent()) {\r\n                    const ident = type.getIdent()!;\r\n\r\n                    // Check if it's anyerror\r\n                    if (ident.name === 'anyerror') {\r\n                        return true;\r\n                    }\r\n\r\n                    // Try to lookup symbol in current scope chain\r\n                    const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\r\n\r\n                    if (symbol) {\r\n                        // Check if it's an Error symbol (member of error set)\r\n                        if (symbol.kind === SymbolKind.Error) {\r\n                            return true;\r\n                        }\r\n\r\n                        // Check if it's an error type definition\r\n                        if (symbol.type && symbol.type.isErrset()) {\r\n                            return true;\r\n                        }\r\n                    }\r\n\r\n                    // ✅ NEW If not found in current scope chain, check ALL scopes\r\n                    // This handles error members that are in their parent error type's scope\r\n                    const allScopes = this.config.services.scopeManager.getAllScopes();\r\n                    for (const scope of allScopes) {\r\n                        const scopeSymbol = scope.symbols.get(ident.name);\r\n                        if (scopeSymbol && scopeSymbol.kind === SymbolKind.Error) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n            private isSameType(type1: AST.TypeNode, type2: AST.TypeNode): boolean {\r\n                if (type1 === type2) return true;\r\n                if (type1.kind !== type2.kind) return false;\r\n\r\n                switch (type1.kind) {\r\n                    case 'primitive':\r\n                        const prim1 = type1.getPrimitive()!;\r\n                        const prim2 = type2.getPrimitive()!;\r\n                        return prim1.kind === prim2.kind && prim1.width === prim2.width;\r\n\r\n                    case 'array':\r\n                        const arr1 = type1.getArray()!;\r\n                        const arr2 = type2.getArray()!;\r\n                        return this.isSameType(arr1.target, arr2.target);\r\n\r\n                    case 'pointer':\r\n                        const ptr1 = type1.getPointer()!;\r\n                        const ptr2 = type2.getPointer()!;\r\n                        return this.isSameType(ptr1.target, ptr2.target) && ptr1.mutable === ptr2.mutable;\r\n\r\n                    case 'paren':\r\n                        return this.isSameType(type1.getParen()!.type, type2.getParen()!.type);\r\n\r\n                    case 'optional':\r\n                        const opt1 = type1.getOptional()!;\r\n                        const opt2 = type2.getOptional()!;\r\n                        return this.isSameType(opt1.target, opt2.target);\r\n\r\n                    case 'tuple':\r\n                        const tup1 = type1.getTuple()!;\r\n                        const tup2 = type2.getTuple()!;\r\n                        if (tup1.fields.length !== tup2.fields.length) return false;\r\n                        return tup1.fields.every((f: AST.TypeNode, i: number) => this.isSameType(f, tup2.fields[i]));\r\n\r\n                    case 'function':\r\n                        const func1 = type1.getFunction()!;\r\n                        const func2 = type2.getFunction()!;\r\n                        if (func1.params.length !== func2.params.length) return false;\r\n                        if (!func1.params.every((p: AST.TypeNode, i: number) => this.isSameType(p, func2.params[i]))) return false;\r\n                        const ret1 = func1.returnType;\r\n                        const ret2 = func2.returnType;\r\n                        if (ret1 && ret2) return this.isSameType(ret1, ret2);\r\n                        return ret1 === ret2;\r\n\r\n                    case 'ident':\r\n                        const id1 = type1.getIdent()!;\r\n                        const id2 = type2.getIdent()!;\r\n                        return id1.name === id2.name;\r\n\r\n                    default:\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            private promoteNumericTypes(type1: AST.TypeNode, type2: AST.TypeNode, span?: AST.Span): AST.TypeNode {\r\n                if (type1.isComptimeInt() && this.isNumericType(type2)) return type2;\r\n                if (type2.isComptimeInt() && this.isNumericType(type1)) return type1;\r\n                if (type1.isComptimeFloat() && type2.isFloat()) return type2;\r\n                if (type2.isComptimeFloat() && type1.isFloat()) return type1;\r\n\r\n                if (type1.isFloat() || type2.isFloat()) {\r\n                    const width1 = type1.getWidth() ?? 32;\r\n                    const width2 = type2.getWidth() ?? 32;\r\n                    const maxWidth = Math.max(width1, width2);\r\n                    return AST.TypeNode.asFloat(span, `f${maxWidth}`, maxWidth);\r\n                }\r\n\r\n                const width1 = type1.getWidth() ?? 32;\r\n                const width2 = type2.getWidth() ?? 32;\r\n                const maxWidth = Math.max(width1, width2);\r\n\r\n                if (type1.isSigned() || type2.isSigned()) {\r\n                    return AST.TypeNode.asSigned(span, `i${maxWidth}`, maxWidth);\r\n                }\r\n\r\n                return AST.TypeNode.asUnsigned(span, `u${maxWidth}`, maxWidth);\r\n            }\r\n\r\n            private computeUnaryResultType(operandType: AST.TypeNode, isNegation: boolean, span?: AST.Span): AST.TypeNode {\r\n                if (operandType.isComptimeInt()) {\r\n                    const prim = operandType.getPrimitive();\r\n                    const txtStr = prim?.text !== undefined ? String(prim.text) : 'cint';\r\n                    const resultText = isNegation ?\r\n                        (txtStr.startsWith('-') ? txtStr.slice(1) : `-${txtStr}`) : txtStr;\r\n                    return AST.TypeNode.asComptimeInt(span, resultText);\r\n                }\r\n\r\n                if (operandType.isUnsigned() && isNegation) {\r\n                    const width = operandType.getWidth() ?? 32;\r\n                    return AST.TypeNode.asSigned(span, `i${width}`, width);\r\n                }\r\n\r\n                return operandType;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private arePointerTypesCompatible(target: AST.TypeNode, source: AST.TypeNode): boolean {\r\n                const targetPtr = target.getPointer()!;\r\n                const sourcePtr = source.getPointer()!;\r\n\r\n                const baseCompatible = targetPtr.target.isOptional() ?\r\n                    this.isSameType(targetPtr.target.getOptional()!.target, sourcePtr.target) :\r\n                    this.isSameType(targetPtr.target, sourcePtr.target);\r\n\r\n                if (!baseCompatible) {\r\n                    this.reportError(\r\n                        DiagCode.TYPE_MISMATCH,\r\n                        `Cannot assign '${source.toString()}' to variable of type '${target.toString()}'`,\r\n                        source.span\r\n                    );\r\n                    return false;\r\n                }\r\n\r\n                if (targetPtr.mutable && !sourcePtr.mutable) {\r\n                    this.reportError(\r\n                        DiagCode.MUTABILITY_MISMATCH,\r\n                        `Cannot assign immutable pointer to mutable pointer variable`,\r\n                        source.span\r\n                    );\r\n                    return false;\r\n                }\r\n\r\n                // Check base type compatibility first\r\n                if (!this.isTypeCompatible(targetPtr.target, sourcePtr.target)) {\r\n                    return false;\r\n                }\r\n\r\n                // Cannot assign immutable pointer to mutable pointer variable\r\n                if (targetPtr.mutable && !sourcePtr.mutable) {\r\n                    // Don't report here - let caller handle error\r\n                    return false;\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            private areTupleTypesCompatible(target: AST.TypeNode, source: AST.TypeNode): boolean {\r\n                const targetTuple = target.getTuple()!;\r\n                const sourceTuple = source.getTuple()!;\r\n\r\n                if (targetTuple.fields.length !== sourceTuple.fields.length) {\r\n                    return false;\r\n                }\r\n\r\n                for (let i = 0; i < targetTuple.fields.length; i++) {\r\n                    if (!this.isTypeCompatible(targetTuple.fields[i], sourceTuple.fields[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            private areStructTypesCompatible(target: AST.TypeNode, source: AST.TypeNode): boolean {\r\n                const targetStruct = target.getStruct()!;\r\n                const sourceStruct = source.getStruct()!;\r\n\r\n                if (targetStruct.metadata?.scopeId !== undefined &&\r\n                    sourceStruct.metadata?.scopeId !== undefined) {\r\n                    return targetStruct.metadata.scopeId === sourceStruct.metadata.scopeId;\r\n                }\r\n\r\n                if (targetStruct.name && targetStruct.name !== 'Anonymous' &&\r\n                    sourceStruct.name && sourceStruct.name !== 'Anonymous') {\r\n                    return targetStruct.name === sourceStruct.name;\r\n                }\r\n\r\n                return this.areStructsStructurallyCompatible(targetStruct, sourceStruct);\r\n            }\r\n\r\n            private areStructsStructurallyCompatible(\r\n                target: AST.StructTypeNode,\r\n                source: AST.StructTypeNode\r\n            ): boolean {\r\n                const targetFields = new Map<string, AST.FieldNode>();\r\n                const sourceFields = new Map<string, AST.FieldNode>();\r\n\r\n                for (const member of target.members) {\r\n                    if (member.isField()) {\r\n                        const field = member.source as AST.FieldNode;\r\n                        targetFields.set(field.ident.name, field);\r\n                    }\r\n                }\r\n\r\n                for (const member of source.members) {\r\n                    if (member.isField()) {\r\n                        const field = member.source as AST.FieldNode;\r\n                        sourceFields.set(field.ident.name, field);\r\n                    }\r\n                }\r\n\r\n                for (const [fieldName, targetField] of targetFields) {\r\n                    const sourceField = sourceFields.get(fieldName);\r\n\r\n                    if (!sourceField) {\r\n                        return false;\r\n                    }\r\n\r\n                    if (targetField.type && sourceField.type) {\r\n                        if (!this.isTypeCompatible(targetField.type, sourceField.type)) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            private areNumericTypesCompatible(target: AST.TypeNode, source: AST.TypeNode): boolean {\r\n                // Booleans are NOT numeric types\r\n                if (source.isBool() || target.isBool()) {\r\n                    return false;\r\n                }\r\n\r\n                if (source.isComptimeInt() && target.isUnsigned()) {\r\n                    const prim = source.getPrimitive();\r\n                    const txtStr = prim?.text !== undefined ? String(prim.text) : '0';\r\n                    try {\r\n                        const value = BigInt(txtStr);\r\n                        if (value < BigInt(0)) {\r\n                            return false;\r\n                        }\r\n                    } catch {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (source.isComptimeInt() || source.isComptimeFloat()) {\r\n                    return true;\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            private areArrayTypesCompatible(target: AST.TypeNode, source: AST.TypeNode): boolean {\r\n                const targetArray = target.getArray()!;\r\n                const sourceArray = source.getArray()!;\r\n\r\n                // Allow empty array to match any type\r\n                if (sourceArray.target.isUndefined()) {\r\n                    return true;\r\n                }\r\n\r\n                // Check element type compatibility\r\n                if (!this.isTypeCompatible(targetArray.target, sourceArray.target)) {\r\n                    return false;\r\n                }\r\n\r\n                // Check size compatibility (don't report error here - done in validateLetStmt)\r\n                if (targetArray.size && sourceArray.size) {\r\n                    const targetSize = this.ExpressionEvaluator.extractIntegerValue(targetArray.size);\r\n                    const sourceSize = this.ExpressionEvaluator.extractIntegerValue(sourceArray.size);\r\n\r\n                    if (targetSize !== undefined && sourceSize !== undefined) {\r\n                        return targetSize === sourceSize;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            private canConvertTypes(source: AST.TypeNode, target: AST.TypeNode): boolean {\r\n                if (source.isIdent()) {\r\n                    const sourceSymbol = this.config.services.scopeManager.lookupSymbol(source.getIdent()!.name);\r\n                    if (sourceSymbol && sourceSymbol.type) {\r\n                        source = sourceSymbol.type;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n                if (target.isIdent()) {\r\n                    const targetSymbol = this.config.services.scopeManager.lookupSymbol(target.getIdent()!.name);\r\n                    if (targetSymbol && targetSymbol.type) {\r\n                        target = targetSymbol.type;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this.isSameType(source, target)) return true;\r\n\r\n                if (this.isNumericType(source) && this.isNumericType(target)) return true;\r\n\r\n                if (source.isComptimeInt() && this.isNumericType(target)) return true;\r\n                if (source.isComptimeFloat() && target.isFloat()) return true;\r\n\r\n                if (source.isPointer() && target.isPointer()) return true;\r\n\r\n                if (this.isIntegerType(source) && target.isPointer()) return true;\r\n\r\n                if (source.isEnum() && this.isIntegerType(target)) return true;\r\n\r\n                return false;\r\n            }\r\n\r\n            private validateValueFitsInType(expr: AST.ExprNode, targetType: AST.TypeNode): void {\r\n                // Only check for integer/float literals and compile-time constants\r\n                const value = this.ExpressionEvaluator.evaluateComptimeExpression(expr, targetType);\r\n\r\n                if (value === null) {\r\n                    // Not a compile-time constant, can't check overflow statically\r\n                    return;\r\n                }\r\n\r\n                // Get the bounds for the target type\r\n                const bounds = this.getTypeBounds(targetType);\r\n\r\n                // Check if value fits in range\r\n                if (value < bounds.min || value > bounds.max) {\r\n                    this.reportError(\r\n                        DiagCode.ARITHMETIC_OVERFLOW,\r\n                        `Value ${value} does not fit in type '${targetType.toString()}' (valid range: ${bounds.min} to ${bounds.max})`,\r\n                        expr.span\r\n                    );\r\n                }\r\n            }\r\n\r\n            private getTypeBounds(type: AST.TypeNode): { min: bigint; max: bigint } {\r\n                if (type.isSigned()) {\r\n                    const width = type.getWidth() || 64;\r\n                    if (width === 64) {\r\n                        return {\r\n                            min: BigInt('-9223372036854775808'),\r\n                            max: BigInt('9223372036854775807')\r\n                        };\r\n                    }\r\n                    const max = BigInt(2) ** BigInt(width - 1) - BigInt(1);\r\n                    const min = -(BigInt(2) ** BigInt(width - 1));\r\n                    return { min, max };\r\n                }\r\n\r\n                if (type.isUnsigned()) {\r\n                    const width = type.getWidth() || 64;\r\n                    const max = BigInt(2) ** BigInt(width) - BigInt(1);\r\n                    return { min: BigInt(0), max };\r\n                }\r\n\r\n                // For other types, use full range\r\n                return {\r\n                    min: BigInt('-9223372036854775808'),\r\n                    max: BigInt('9223372036854775807')\r\n                };\r\n            }\r\n\r\n            private isValidThrowType(thrownType: AST.TypeNode, functionErrorType: AST.TypeNode, span: AST.Span): boolean {\r\n                // Direct type match\r\n                if (this.isSameType(thrownType, functionErrorType)) {\r\n                    return true;\r\n                }\r\n\r\n                // **CASE 1**: Function error type is an error set\r\n                if (functionErrorType.isErrset()) {\r\n                    const errorSet = functionErrorType.getError()!;\r\n\r\n                    // Check if thrown type is a member of the error set\r\n                    if (thrownType.isIdent()) {\r\n                        const thrownIdent = thrownType.getIdent()!;\r\n                        const isMember = errorSet.members.some(member => member.name === thrownIdent.name);\r\n\r\n                        if (isMember) {\r\n                            return true;\r\n                        }\r\n                    }\r\n\r\n                    return false;\r\n                }\r\n\r\n                // **CASE 2**: Function error type is an identifier (e.g., MyError)\r\n                if (functionErrorType.isIdent()) {\r\n                    const funcErrorIdent = functionErrorType.getIdent()!;\r\n\r\n                    // Look up the actual error type definition\r\n                    const errorSymbol = this.config.services.scopeManager.lookupSymbol(funcErrorIdent.name);\r\n                    if (errorSymbol && errorSymbol.type && errorSymbol.type.isErrset()) {\r\n                        const errorSet = errorSymbol.type.getError()!;\r\n\r\n                        // Check if thrown type is a member\r\n                        if (thrownType.isIdent()) {\r\n                            const thrownIdent = thrownType.getIdent()!;\r\n                            return errorSet.members.some(member => member.name === thrownIdent.name);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // ✅ Handle when thrown type is an error member identifier\r\n                // and function expects anyerror or a broader error type\r\n                if (thrownType.isIdent()) {\r\n                    const thrownIdent = thrownType.getIdent()!;\r\n                    const thrownSymbol = this.config.services.scopeManager.lookupSymbol(thrownIdent.name);\r\n\r\n                    // If it's an error member, check if function accepts it\r\n                    if (thrownSymbol && thrownSymbol.kind === SymbolKind.Error) {\r\n                        // If function error type is anyerror, accept it\r\n                        if (this.isAnyErrorType(functionErrorType)) {\r\n                            return true;\r\n                        }\r\n\r\n                        // Otherwise, need to verify it's part of the allowed error set\r\n                        return this.isErrorMemberOfType(thrownIdent.name, functionErrorType);\r\n                    }\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n            private isErrorMemberOfType(memberName: string, errorType: AST.TypeNode): boolean {\r\n                // Resolve the error type if it's an identifier\r\n                const resolvedType = this.resolveIdentifierType(errorType);\r\n\r\n                if (resolvedType.isErrset()) {\r\n                    const errorSet = resolvedType.getError()!;\r\n                    return errorSet.members.some(member => member.name === memberName);\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private extractTypeFromInitializer(expr: AST.ExprNode): AST.TypeNode | null {\r\n                if (expr.kind !== 'Primary') return null;\r\n\r\n                const primary = expr.getPrimary();\r\n                if (!primary || primary.kind !== 'Type') return null;\r\n\r\n                return primary.getType();\r\n            }\r\n\r\n            private extractSymbolFromExpression(expr: AST.ExprNode): Symbol | null {\r\n                if (expr.is('Primary')) {\r\n                    const primary = expr.getPrimary();\r\n                    if (primary?.is('Ident')) {\r\n                        const ident = primary.getIdent();\r\n                        if (ident) {\r\n                            return this.config.services.scopeManager.lookupSymbol(ident.name);\r\n                        }\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n\r\n            private extractBuiltinName(expr: AST.ExprNode): string | null {\r\n                if (expr.kind !== 'Primary') return null;\r\n                const primary = expr.getPrimary();\r\n                if (!primary || primary.kind !== 'Ident') return null;\r\n                const ident = primary.getIdent();\r\n                return (ident?.name ? '@'+ident.name : null) || null;\r\n            }\r\n\r\n            private extractMemberName(memberExpr: AST.ExprNode): string | null {\r\n                switch (memberExpr.kind) {\r\n                    case 'Primary': {\r\n                        const src = memberExpr.getPrimary()!;\r\n                        if (src.kind === 'Ident') {\r\n                            return src.getIdent()!.name;\r\n                        }\r\n                        return null;\r\n                    }\r\n\r\n                    case 'Prefix': {\r\n                        const src = memberExpr.getPrefix()!;\r\n                        return this.extractMemberName(src.expr);\r\n                    }\r\n\r\n                    case 'Postfix': {\r\n                        const src = memberExpr.getPostfix()!;\r\n\r\n                        switch (src.kind) {\r\n                            case 'MemberAccess': {\r\n                                const access = src.getMemberAccess()!;\r\n                                return this.extractMemberName(access.target);\r\n                            }\r\n\r\n                            case 'Call': {\r\n                                const call = src.getCall()!;\r\n                                return this.extractMemberName(call.base);\r\n                            }\r\n\r\n                            case 'ArrayAccess': {\r\n                                const index = src.getArrayAccess()!;\r\n                                return this.extractMemberName(index.base);\r\n                            }\r\n\r\n                            case 'Increment':\r\n                            case 'Decrement':\r\n                            case 'Dereference': {\r\n                                return this.extractMemberName(src.getAsExprNode()!);\r\n                            }\r\n\r\n                            default:\r\n                                return null;\r\n                        }\r\n                    }\r\n\r\n                    case 'Binary':\r\n                    case 'As':\r\n                    case 'Orelse':\r\n                    case 'Range':\r\n                    case 'Try':\r\n                    case 'Catch':\r\n                    case 'If':\r\n                    case 'Switch':\r\n                    case 'Typeof':\r\n                    case 'Sizeof':\r\n                        return null;\r\n\r\n                    default:\r\n                        this.log('verbose', `Cannot extract member name from expression kind: ${memberExpr.kind}`);\r\n                        return null;\r\n                }\r\n            }\r\n\r\n            private extractEnumVariantName(expr: AST.ExprNode): string | null {\r\n                if (expr.is('Postfix')) {\r\n                    const postfix = expr.getPostfix();\r\n                    if (postfix?.kind === 'MemberAccess') {\r\n                        const access = postfix.getMemberAccess()!;\r\n                        return this.extractMemberName(access.target);\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n\r\n            private extractTypeName(typeNode: AST.TypeNode): string | null {\r\n                if (typeNode.isIdent()) {\r\n                    return typeNode.getIdent()!.name;\r\n                }\r\n                if (typeNode.isStruct()) {\r\n                    return typeNode.getStruct()!.name || null;\r\n                }\r\n                return null;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private findModuleScope(moduleName: string): Scope | null {\r\n                const moduleScope = this.config.services.scopeManager.findScopeByName(moduleName, ScopeKind.Module);\r\n                if (!moduleScope) {\r\n                    this.reportError(DiagCode.MODULE_SCOPE_NOT_FOUND, `Module scope for '${moduleName}' not found`);\r\n                }\r\n                return moduleScope;\r\n            }\r\n\r\n            private findCallTargetSymbol(baseExpr: AST.ExprNode, objectScope?: Scope): Symbol | undefined {\r\n                if (baseExpr.kind === 'Primary') {\r\n                    const primary = baseExpr.getPrimary()!;\r\n\r\n                    if (primary.kind === 'Ident') {\r\n                        const ident = primary.getIdent();\r\n                        if (ident) {\r\n                            const s = objectScope\r\n                            ? this.config.services.scopeManager.lookupSymbolInScopeChain(ident.name, objectScope.id)\r\n                            : this.config.services.scopeManager.lookupSymbol(ident.name) ?? undefined;\r\n                            return s ?? undefined;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return undefined;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private isBuiltinFunction(baseExpr: AST.ExprNode): boolean {\r\n                if (baseExpr.isIdent()) {\r\n                    const ident = baseExpr.getIdent();\r\n                    return ident?.builtin === true || (ident?.name.startsWith('@') === true);\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n            private isInsideFunctionScope(): boolean {\r\n                let currentScope = this.config.services.scopeManager.getCurrentScope();\r\n\r\n                while (currentScope) {\r\n                    if (currentScope.kind === ScopeKind.Function) {\r\n                        return true;\r\n                    }\r\n\r\n                    // Don't stop at Type scopes - they can contain methods\r\n                    // Only stop at Module boundaries\r\n                    if (currentScope.kind === ScopeKind.Module || currentScope.kind === ScopeKind.Global) {\r\n                        return false;\r\n                    }\r\n\r\n                    // Walk up the scope chain\r\n                    if (currentScope.parent !== null) {\r\n                        try {\r\n                            currentScope = this.config.services.scopeManager.getScope(currentScope.parent);\r\n                        } catch {\r\n                            return false;\r\n                        }\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n            private isAccessibleFrom(targetScope: Scope): boolean {\r\n                const currentScope = this.config.services.scopeManager.getCurrentScope();\r\n\r\n                let current: Scope | null = currentScope;\r\n                let target: Scope | null = targetScope;\r\n\r\n                while (current && current.kind !== ScopeKind.Module) {\r\n                    current = current.parent !== null ? this.config.services.scopeManager.getScope(current.parent) : null;\r\n                }\r\n\r\n                while (target && target.kind !== ScopeKind.Module) {\r\n                    target = target.parent !== null ? this.config.services.scopeManager.getScope(target.parent) : null;\r\n                }\r\n\r\n                return current?.id === target?.id;\r\n            }\r\n\r\n            private isBoolLiteral(expr: AST.ExprNode | undefined, value: boolean): boolean {\r\n                if (!expr || !expr.is('Primary')) return false;\r\n\r\n                const primary = expr.getPrimary();\r\n                if (!primary?.is('Literal')) return false;\r\n\r\n                const literal = primary.getLiteral();\r\n                return literal?.kind === 'Bool' && literal.value === value;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private createCacheKey(expr: AST.ExprNode): string {\r\n                const moduleName = this.config.services.contextTracker.getModuleName() || 'unknown';\r\n                const span = expr.span || { start: 0, end: 0 };\r\n                return `${moduleName}:${span.start}:${span.end}:${expr.kind}`;\r\n            }\r\n\r\n            private cacheType(key: string, type: AST.TypeNode): void {\r\n                if (this.typeCtx.typeCache.size >= this.CACHE_MAX_SIZE) {\r\n                    const entries = Array.from(this.typeCtx.typeCache.entries());\r\n                    const toKeep = entries.slice(-Math.floor(this.CACHE_MAX_SIZE / 2));\r\n                    this.typeCtx.typeCache.clear();\r\n                    toKeep.forEach(([k, v]) => this.typeCtx.typeCache.set(k, v));\r\n                }\r\n\r\n                this.typeCtx.typeCache.set(key, type || null);\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private init(): boolean {\r\n                this.config.services.contextTracker.reset();\r\n                this.config.services.contextTracker.setPhase(AnalysisPhase.TypeValidation);\r\n\r\n                const globalScope = this.config.services.scopeManager.getGlobalScope();\r\n                this.config.services.scopeManager.setCurrentScope(globalScope.id);\r\n                this.config.services.contextTracker.setScope(globalScope.id);\r\n\r\n                this.log('verbose', 'Type validation initialized');\r\n                return true;\r\n            }\r\n\r\n            private initStats(): TypeValidationStats {\r\n                return {\r\n                    modulesProcessed        : 0,\r\n                    typesInferred           : 0,\r\n                    typesCached             : 0,\r\n                    compatibilityChecks     : 0,\r\n                    callsValidated          : 0,\r\n                    memberAccessValidated   : 0,\r\n                    assignmentsValidated    : 0,\r\n                    returnsValidated        : 0,\r\n                    errors                  : 0,\r\n                    startTime               : Date.now()\r\n                };\r\n            }\r\n\r\n            private initTypeValidatorContext(): TypeValidatorContext {\r\n                return {\r\n                    currentModule   : '',\r\n                    moduleStack     : [],\r\n                    typeCache       : new Map(),\r\n                };\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            logStatistics(): void {\r\n                const duration = Date.now() - this.stats.startTime;\r\n                this.log('verbose',\r\n                    `Type Validation Statistics :\\n` +\r\n                    `  Duration                 : ${duration}ms\\n` +\r\n                    `  Types inferred           : ${this.stats.typesInferred}\\n` +\r\n                    `  Types cached             : ${this.stats.typesCached}\\n` +\r\n                    `  Compatibility checks     : ${this.stats.compatibilityChecks}\\n` +\r\n                    `  Calls validated          : ${this.stats.callsValidated}\\n` +\r\n                    `  Member access validated  : ${this.stats.memberAccessValidated}\\n` +\r\n                    `  Assignments validated    : ${this.stats.assignmentsValidated}\\n` +\r\n                    `  Returns validated        : ${this.stats.returnsValidated}\\n` +\r\n                    `  Cache size               : ${this.typeCtx.typeCache.size}\\n` +\r\n                    `  Errors                   : ${this.stats.errors}`\r\n                );\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ExpressionEvaluator.ts — Complete compile-time expression evaluation\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as AST                 from '@je-es/ast';\n    import { DiagCode }             from './DiagnosticManager';\n    import { AnalysisConfig }       from '../ast-analyzer';\n    import { Scope, Symbol, SymbolKind, ScopeKind } from './ScopeManager';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    type ComptimeValue = bigint | number | boolean | null;\n\n    interface EvaluationResult {\n        value: ComptimeValue;\n        type: 'int' | 'float' | 'bool' | 'null';\n    }\n\n    interface EvaluationContext {\n        allowFloats: boolean;\n        maxIntValue: bigint;\n        minIntValue: bigint;\n        targetType?: AST.TypeNode;  // For size-aware validation\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ExpressionEvaluator {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            private readonly MAX_INT_64 = BigInt('9223372036854775807'); // i64::MAX\n            private readonly MIN_INT_64 = BigInt('-9223372036854775808'); // i64::MIN\n\n            constructor(public config: AnalysisConfig) {}\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            evaluateComptimeExpression(expr: AST.ExprNode, targetType?: AST.TypeNode): bigint | null {\n                const bounds = this.getTypeBounds(targetType);\n\n                const result = this.evaluateExpression(expr, {\n                    allowFloats: false,\n                    maxIntValue: BigInt('9223372036854775807'), // ✅ Use max range during evaluation\n                    minIntValue: BigInt('-9223372036854775808'),\n                    targetType\n                });\n\n                if (!result) return null;\n\n                if (result.type !== 'int') {\n                    return null;\n                }\n\n                const value = result.value as bigint;\n\n                // ✅ Check bounds AFTER evaluation, using the target type bounds\n                if (targetType && (value < bounds.min || value > bounds.max)) {\n                    this.reportError(\n                        DiagCode.ARITHMETIC_OVERFLOW,\n                        `Value ${value} does not fit in type '${targetType.toString()}' (valid range: ${bounds.min} to ${bounds.max})`,\n                        expr.span\n                    );\n                    return null;\n                }\n\n                return value;\n            }\n\n            private getTypeBounds(type?: AST.TypeNode): { min: bigint; max: bigint } {\n                if (!type) {\n                    return { min: this.MIN_INT_64, max: this.MAX_INT_64 };\n                }\n\n                // Signed integers\n                if (type.isSigned()) {\n                    const width = type.getWidth() || 64;\n                    const max = BigInt(2) ** BigInt(width - 1) - BigInt(1);\n                    const min = -(BigInt(2) ** BigInt(width - 1));\n                    return { min, max };\n                }\n\n                // Unsigned integers\n                if (type.isUnsigned()) {\n                    const width = type.getWidth() || 64;\n                    const max = BigInt(2) ** BigInt(width) - BigInt(1);\n                    return { min: BigInt(0), max };\n                }\n\n                // Comptime integers - use full range\n                if (type.isComptimeInt()) {\n                    return { min: this.MIN_INT_64, max: this.MAX_INT_64 };\n                }\n\n                // Default to i64 range\n                return { min: this.MIN_INT_64, max: this.MAX_INT_64 };\n            }\n\n            evaluateExpression(expr: AST.ExprNode, ctx?: EvaluationContext): EvaluationResult | null {\n                const context = ctx || {\n                    allowFloats: true,\n                    maxIntValue: this.MAX_INT_64,\n                    minIntValue: this.MIN_INT_64\n                };\n\n                try {\n                    switch (expr.kind) {\n                        case 'Primary':\n                            return this.evaluatePrimary(expr.getPrimary()!, context);\n                        case 'Binary':\n                            return this.evaluateBinary(expr.getBinary()!, context);\n                        case 'Prefix':\n                            return this.evaluatePrefix(expr.getPrefix()!, context);\n                        case 'As':\n                            return this.evaluateAs(expr.getAs()!, context);\n                        case 'Sizeof':\n                            return this.evaluateSizeof(expr.getSizeof()!, context);\n                        default:\n                            return null;\n                    }\n                } catch (error) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Error evaluating compile-time expression: ${error}`,\n                        expr.span\n                    );\n                    return null;\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private evaluatePrimary(primary: AST.PrimaryNode, ctx: EvaluationContext): EvaluationResult | null {\n                switch (primary.kind) {\n                    case 'Literal':\n                        return this.evaluateLiteral(primary.getLiteral()!, ctx);\n                    case 'Ident':\n                        return this.evaluateIdentifier(primary.getIdent()!, ctx);\n                    case 'Paren': {\n                        const paren = primary.getParen()!;\n                        return paren.source ? this.evaluateExpression(paren.source, ctx) : null;\n                    }\n                    default:\n                        return null;\n                }\n            }\n\n            private evaluateLiteral(literal: AST.LiteralNode, ctx: EvaluationContext): EvaluationResult | null {\n                switch (literal.kind) {\n                    case 'Integer': {\n                        try {\n                            const value = BigInt(literal.value as string);\n\n                            // // Check overflow\n                            // if (value > ctx.maxIntValue || value < ctx.minIntValue) {\n                            //     this.reportError(\n                            //         DiagCode.ARITHMETIC_OVERFLOW,\n                            //         `Integer literal ${value} exceeds valid range [${ctx.minIntValue}, ${ctx.maxIntValue}]`,\n                            //         literal.span\n                            //     );\n                            //     return null;\n                            // }\n\n                            return { value, type: 'int' };\n                        } catch {\n                            this.reportError(\n                                DiagCode.ANALYSIS_ERROR,\n                                `Invalid integer literal: ${literal.value}`,\n                                literal.span\n                            );\n                            return null;\n                        }\n                    }\n\n                    case 'Float': {\n                        if (!ctx.allowFloats) {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                'Float literals not allowed in integer-only context',\n                                literal.span\n                            );\n                            return null;\n                        }\n\n                        try {\n                            const value = parseFloat(literal.value as string);\n\n                            if (!isFinite(value)) {\n                                this.reportError(\n                                    DiagCode.ARITHMETIC_OVERFLOW,\n                                    'Float literal out of valid range',\n                                    literal.span\n                                );\n                                return null;\n                            }\n\n                            return { value, type: 'float' };\n                        } catch {\n                            this.reportError(\n                                DiagCode.ANALYSIS_ERROR,\n                                `Invalid float literal: ${literal.value}`,\n                                literal.span\n                            );\n                            return null;\n                        }\n                    }\n\n                    case 'Bool':\n                        return { value: literal.value as boolean, type: 'bool' };\n\n                    case 'Null':\n                        return { value: null, type: 'null' };\n\n                    default:\n                        return null;\n                }\n            }\n\n            private evaluateIdentifier(ident: AST.IdentNode, ctx: EvaluationContext): EvaluationResult | null {\n                // Only evaluate immutable const-like symbols\n                const symbol = this.config.services.scopeManager.lookupSymbol(ident.name);\n                if (!symbol) return null;\n\n                // Must be immutable definition or variable\n                if (symbol.kind !== SymbolKind.Definition && symbol.kind !== SymbolKind.Variable) {\n                    return null;\n                }\n\n                if (symbol.mutability.kind !== 'Immutable') {\n                    return null;\n                }\n\n                // Get initializer from metadata\n                if (symbol.metadata && typeof symbol.metadata === 'object') {\n                    const metadata = symbol.metadata as any;\n                    if (metadata.initializer) {\n                        return this.evaluateExpression(metadata.initializer, ctx);\n                    }\n                }\n\n                return null;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private evaluateBinary(binary: AST.BinaryNode, ctx: EvaluationContext): EvaluationResult | null {\n                const left = this.evaluateExpression(binary.left, ctx);\n                const right = this.evaluateExpression(binary.right, ctx);\n\n                if (!left || !right) return null;\n\n                // Type compatibility check\n                if (!this.areTypesCompatible(left.type, right.type, binary.kind)) {\n                    this.reportError(\n                        DiagCode.TYPE_MISMATCH,\n                        `Cannot perform ${binary.kind} operation on incompatible types '${left.type}' and '${right.type}'`,\n                        binary.span\n                    );\n                    return null;\n                }\n\n                switch (binary.kind) {\n                    case 'Additive':\n                        return this.evaluateAdditive(left, right, binary.operator, binary.span);\n\n                    case 'Multiplicative':\n                        return this.evaluateMultiplicative(left, right, binary.operator, binary.span);\n\n                    case 'Power':\n                        return this.evaluatePower(left, right, binary.span);\n\n                    case 'Shift':\n                        return this.evaluateShift(left, right, binary.operator, binary.span);\n\n                    case 'BitwiseAnd':\n                    case 'BitwiseXor':\n                    case 'BitwiseOr':\n                        return this.evaluateBitwise(left, right, binary.kind, binary.span);\n\n                    case 'Relational':\n                    case 'Equality':\n                        return this.evaluateComparison(left, right, binary.operator, binary.span);\n\n                    case 'LogicalAnd':\n                    case 'LogicalOr':\n                        return this.evaluateLogical(left, right, binary.kind, binary.span);\n\n                    default:\n                        return null;\n                }\n            }\n\n            private evaluateAdditive(\n                left: EvaluationResult,\n                right: EvaluationResult,\n                op: string,\n                span: AST.Span\n            ): EvaluationResult | null {\n                // CRITICAL: Reject boolean operands immediately\n                if (left.type === 'bool' || right.type === 'bool') {\n                    this.reportError(\n                        DiagCode.TYPE_MISMATCH,\n                        `Cannot perform ${op === '+' ? 'addition' : 'subtraction'} on boolean type`,\n                        span\n                    );\n                    return null;\n                }\n\n                // Handle float operations\n                if (left.type === 'float' || right.type === 'float') {\n                    const l = this.toFloat(left);\n                    const r = this.toFloat(right);\n\n                    const result = op === '+' ? l + r : l - r;\n\n                    if (!isFinite(result)) {\n                        this.reportError(\n                            DiagCode.ARITHMETIC_OVERFLOW,\n                            `Float ${op === '+' ? 'addition' : 'subtraction'} overflow`,\n                            span\n                        );\n                        return null;\n                    }\n\n                    return { value: result, type: 'float' };\n                }\n\n                // Integer operations\n                const l = left.value as bigint;\n                const r = right.value as bigint;\n\n                try {\n                    const result = op === '+' ? l + r : l - r;\n\n                    if (result > this.MAX_INT_64 || result < this.MIN_INT_64) {\n                        this.reportError(\n                            DiagCode.ARITHMETIC_OVERFLOW,\n                            `Integer ${op === '+' ? 'addition' : 'subtraction'} overflow: ${l} ${op} ${r} = ${result}`,\n                            span\n                        );\n                        return null;\n                    }\n\n                    return { value: result, type: 'int' };\n                } catch {\n                    this.reportError(\n                        DiagCode.ARITHMETIC_OVERFLOW,\n                        `Integer ${op === '+' ? 'addition' : 'subtraction'} overflow`,\n                        span\n                    );\n                    return null;\n                }\n            }\n\n            private evaluateMultiplicative(\n                left: EvaluationResult,\n                right: EvaluationResult,\n                op: string,\n                span: AST.Span\n            ): EvaluationResult | null {\n                // CRITICAL: Reject boolean operands immediately\n                if (left.type === 'bool' || right.type === 'bool') {\n                    this.reportError(\n                        DiagCode.TYPE_MISMATCH,\n                        `Cannot perform ${op === '+' ? 'addition' : 'subtraction'} on boolean type`,\n                        span\n                    );\n                    return null;\n                }\n\n                // Handle float operations\n                if (left.type === 'float' || right.type === 'float') {\n                    const l = this.toFloat(left);\n                    const r = this.toFloat(right);\n\n                    if (op === '/' && r === 0) {\n                        this.reportError(\n                            DiagCode.DIVISION_BY_ZERO,\n                            'Division by zero in compile-time expression',\n                            span\n                        );\n                        return null;\n                    }\n\n                    if (op === '%' && r === 0) {\n                        this.reportError(\n                            DiagCode.DIVISION_BY_ZERO,\n                            'Modulo by zero in compile-time expression',\n                            span\n                        );\n                        return null;\n                    }\n\n                    let result: number;\n                    switch (op) {\n                        case '*': result = l * r; break;\n                        case '/': result = l / r; break;\n                        case '%': result = l % r; break;\n                        default: return null;\n                    }\n\n                    if (!isFinite(result)) {\n                        this.reportError(\n                            DiagCode.ARITHMETIC_OVERFLOW,\n                            `Float ${op} overflow`,\n                            span\n                        );\n                        return null;\n                    }\n\n                    return { value: result, type: 'float' };\n                }\n\n                // Integer operations\n                const l = left.value as bigint;\n                const r = right.value as bigint;\n\n                if ((op === '/' || op === '%') && r === BigInt(0)) {\n                    this.reportError(\n                        DiagCode.DIVISION_BY_ZERO,\n                        `${op === '/' ? 'Division' : 'Modulo'} by zero in compile-time expression`,\n                        span\n                    );\n                    return null;\n                }\n\n                try {\n                    let result: bigint;\n                    switch (op) {\n                        case '*': result = l * r; break;\n                        case '/': result = l / r; break;\n                        case '%': result = l % r; break;\n                        default: return null;\n                    }\n\n                    if (result > this.MAX_INT_64 || result < this.MIN_INT_64) {\n                        this.reportError(\n                            DiagCode.ARITHMETIC_OVERFLOW,\n                            `Integer ${op} overflow: ${l} ${op} ${r}`,\n                            span\n                        );\n                        return null;\n                    }\n\n                    return { value: result, type: 'int' };\n                } catch {\n                    this.reportError(\n                        DiagCode.ARITHMETIC_OVERFLOW,\n                        `Integer ${op} overflow`,\n                        span\n                    );\n                    return null;\n                }\n            }\n\n            private evaluatePower(\n                left: EvaluationResult,\n                right: EvaluationResult,\n                span: AST.Span\n            ): EvaluationResult | null {\n                // Handle float operations\n                if (left.type === 'float' || right.type === 'float') {\n                    const l = this.toFloat(left);\n                    const r = this.toFloat(right);\n                    const result = Math.pow(l, r);\n\n                    if (!isFinite(result)) {\n                        this.reportError(\n                            DiagCode.ARITHMETIC_OVERFLOW,\n                            'Float power overflow',\n                            span\n                        );\n                        return null;\n                    }\n\n                    return { value: result, type: 'float' };\n                }\n\n                // Integer operations\n                const base = left.value as bigint;\n                const exp = right.value as bigint;\n\n                if (exp < BigInt(0)) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        'Negative exponent not allowed in compile-time integer expression',\n                        span\n                    );\n                    return null;\n                }\n\n                if (exp > BigInt(10000)) {\n                    this.reportError(\n                        DiagCode.ARITHMETIC_OVERFLOW,\n                        'Exponent too large for compile-time evaluation',\n                        span\n                    );\n                    return null;\n                }\n\n                try {\n                    const result = base ** exp;\n\n                    if (result > this.MAX_INT_64 || result < this.MIN_INT_64) {\n                        this.reportError(\n                            DiagCode.ARITHMETIC_OVERFLOW,\n                            `Integer power overflow: ${base} ** ${exp}`,\n                            span\n                        );\n                        return null;\n                    }\n\n                    return { value: result, type: 'int' };\n                } catch {\n                    this.reportError(\n                        DiagCode.ARITHMETIC_OVERFLOW,\n                        'Integer power overflow',\n                        span\n                    );\n                    return null;\n                }\n            }\n\n            private evaluateShift(\n                left: EvaluationResult,\n                right: EvaluationResult,\n                op: string,\n                span: AST.Span\n            ): EvaluationResult | null {\n                if (left.type !== 'int' || right.type !== 'int') {\n                    this.reportError(\n                        DiagCode.TYPE_MISMATCH,\n                        'Shift operations require integer operands',\n                        span\n                    );\n                    return null;\n                }\n\n                const value = left.value as bigint;\n                const shift = right.value as bigint;\n\n                if (shift < BigInt(0)) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        'Negative shift amount not allowed',\n                        span\n                    );\n                    return null;\n                }\n\n                if (shift > BigInt(63)) {\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        'Shift amount too large (max 63 bits)',\n                        span\n                    );\n                    return null;\n                }\n\n                const shiftNum = Number(shift);\n                const result = op === '<<' ? value << BigInt(shiftNum) : value >> BigInt(shiftNum);\n\n                return { value: result, type: 'int' };\n            }\n\n            private evaluateBitwise(\n                left: EvaluationResult,\n                right: EvaluationResult,\n                op: 'BitwiseAnd' | 'BitwiseXor' | 'BitwiseOr',\n                span: AST.Span\n            ): EvaluationResult | null {\n                if (left.type !== 'int' || right.type !== 'int') {\n                    this.reportError(\n                        DiagCode.TYPE_MISMATCH,\n                        'Bitwise operations require integer operands',\n                        span\n                    );\n                    return null;\n                }\n\n                const l = left.value as bigint;\n                const r = right.value as bigint;\n\n                let result: bigint;\n                switch (op) {\n                    case 'BitwiseAnd': result = l & r; break;\n                    case 'BitwiseXor': result = l ^ r; break;\n                    case 'BitwiseOr': result = l | r; break;\n                }\n\n                return { value: result, type: 'int' };\n            }\n\n            private evaluateComparison(\n                left: EvaluationResult,\n                right: EvaluationResult,\n                op: string,\n                span: AST.Span\n            ): EvaluationResult | null {\n                // Handle nulls\n                if (left.type === 'null' || right.type === 'null') {\n                    if (op === '==' || op === '!=') {\n                        const result = (left.value === right.value) === (op === '==');\n                        return { value: result, type: 'bool' };\n                    }\n                    return null;\n                }\n\n                // Convert to common type\n                if (left.type === 'float' || right.type === 'float') {\n                    const l = this.toFloat(left);\n                    const r = this.toFloat(right);\n                    return { value: this.compare(l, r, op), type: 'bool' };\n                }\n\n                if (left.type === 'int' && right.type === 'int') {\n                    const l = left.value as bigint;\n                    const r = right.value as bigint;\n                    return { value: this.compare(l, r, op), type: 'bool' };\n                }\n\n                if (left.type === 'bool' && right.type === 'bool') {\n                    if (op === '==' || op === '!=') {\n                        const result = (left.value === right.value) === (op === '==');\n                        return { value: result, type: 'bool' };\n                    }\n                }\n\n                return null;\n            }\n\n            private evaluateLogical(\n                left: EvaluationResult,\n                right: EvaluationResult,\n                op: 'LogicalAnd' | 'LogicalOr',\n                span: AST.Span\n            ): EvaluationResult | null {\n                if (left.type !== 'bool' || right.type !== 'bool') {\n                    this.reportError(\n                        DiagCode.TYPE_MISMATCH,\n                        'Logical operations require boolean operands',\n                        span\n                    );\n                    return null;\n                }\n\n                const l = left.value as boolean;\n                const r = right.value as boolean;\n\n                const result = op === 'LogicalAnd' ? l && r : l || r;\n                return { value: result, type: 'bool' };\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private evaluatePrefix(prefix: AST.PrefixNode, ctx: EvaluationContext): EvaluationResult | null {\n                const value = this.evaluateExpression(prefix.expr, ctx);\n                if (!value) return null;\n\n                switch (prefix.kind) {\n                    case 'UnaryPlus':\n                        // ✅ Check for numeric type\n                        if (value.type !== 'int' && value.type !== 'float') {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                `Unary '+' requires numeric operand, got '${value.type}'`,\n                                prefix.span\n                            );\n                            return null;\n                        }\n                        return value;\n\n                    case 'UnaryMinus':\n                        // ✅ Check for numeric type\n                        if (value.type !== 'int' && value.type !== 'float') {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                `Unary '-' requires numeric operand, got '${value.type}'`,\n                                prefix.span\n                            );\n                            return null;\n                        }\n\n                        if (value.type === 'int') {\n                            const result = -(value.value as bigint);\n                            if (result > this.MAX_INT_64 || result < this.MIN_INT_64) {\n                                this.reportError(\n                                    DiagCode.ARITHMETIC_OVERFLOW,\n                                    'Integer negation overflow',\n                                    prefix.span\n                                );\n                                return null;\n                            }\n                            return { value: result, type: 'int' };\n                        }\n                        if (value.type === 'float') {\n                            return { value: -(value.value as number), type: 'float' };\n                        }\n                        return null;\n\n                    case 'LogicalNot':\n                        if (value.type !== 'bool') {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                `Logical not requires boolean operand, got '${value.type}'`,\n                                prefix.span\n                            );\n                            return null;\n                        }\n                        return { value: !(value.value as boolean), type: 'bool' };\n\n                    case 'BitwiseNot':\n                        if (value.type !== 'int') {\n                            this.reportError(\n                                DiagCode.TYPE_MISMATCH,\n                                `Bitwise not requires integer operand, got '${value.type}'`,\n                                prefix.span\n                            );\n                            return null;\n                        }\n                        return { value: ~(value.value as bigint), type: 'int' };\n\n                    default:\n                        return null;\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private evaluateAs(asNode: AST.AsNode, ctx: EvaluationContext): EvaluationResult | null {\n                const value = this.evaluateExpression(asNode.base, ctx);\n                if (!value) return null;\n\n                // Type conversion based on target type\n                const targetType = asNode.type;\n\n                // Int to float\n                if (value.type === 'int' && this.isFloatType(targetType)) {\n                    return { value: Number(value.value), type: 'float' };\n                }\n\n                // Float to int (truncation)\n                if (value.type === 'float' && this.isIntegerType(targetType)) {\n                    const intValue = BigInt(Math.trunc(value.value as number));\n                    if (intValue > this.MAX_INT_64 || intValue < this.MIN_INT_64) {\n                        this.reportError(\n                            DiagCode.ARITHMETIC_OVERFLOW,\n                            'Float to integer conversion overflow',\n                            asNode.span\n                        );\n                        return null;\n                    }\n                    return { value: intValue, type: 'int' };\n                }\n\n                // Same type conversion\n                return value;\n            }\n\n            private evaluateSizeof(sizeofNode: AST.SizeofNode, ctx: EvaluationContext): EvaluationResult | null {\n                const type = sizeofNode.expr.getType()!;\n                return { value: this.computeTypeSize(type), type: 'int' };\n            }\n\n            computeTypeSize(type: AST.TypeNode): number | null {\n\n                switch (type.kind) {\n                    case 'primitive': {\n                        const prim = type.getPrimitive()!;\n\n                        // Handle sized primitives\n                        if (prim.width !== undefined) {\n                            return prim.width;\n                        }\n\n                        // Handle standard primitives\n                        switch (prim.kind) {\n                            case 'bool': return 1;\n                            case 'void': return 0;\n                            default:\n                                return null;\n                        }\n                    }\n\n                    case 'pointer':\n                        return 64; // Assume 64-bit pointers\n\n                    case 'optional':\n                        // Optional adds 1 bit for the tag + size of inner type\n                        const inner = type.getOptional()!.target;\n                        const innerSize = this.computeTypeSize(inner);\n                        return innerSize !== null ? innerSize + 1 : null;\n\n                    case 'array': {\n                        const arr = type.getArray()!;\n                        const elemSize = this.computeTypeSize(arr.target);\n                        if (elemSize === null) return null;\n\n                        if (arr.size) {\n                            const sizeValue = this.extractIntegerValue(arr.size);\n                            if (sizeValue !== undefined) {\n                                return elemSize * sizeValue;\n                            }\n                        }\n                        return null; // Dynamic size\n                    }\n\n                    case 'tuple': {\n                        const tuple = type.getTuple()!;\n                        let totalSize = 0;\n\n                        for (const field of tuple.fields) {\n                            const fieldSize = this.computeTypeSize(field);\n                            if (fieldSize === null) return null;\n                            totalSize += fieldSize;\n                        }\n\n                        return totalSize;\n                    }\n\n                    case 'struct': {\n                        const struct = type.getStruct()!;\n                        let totalSize = 0;\n\n                        for (const member of struct.members) {\n                            if (member.isField()) {\n                                const field = member.getField()!;\n                                if (field.type) {\n                                    const fieldSize = this.computeTypeSize(field.type);\n                                    if (fieldSize === null) return null;\n                                    totalSize += fieldSize;\n                                }\n                            }\n                        }\n\n                        return totalSize;\n                    }\n\n                    default:\n                        return null; // Size cannot be determined\n                }\n            }\n\n            extractIntegerValue(expr: AST.ExprNode): number | undefined {\n                const comptimeValue = this.evaluateComptimeExpression(expr);\n\n                if (comptimeValue === null) return undefined;\n\n                // Convert BigInt to number if within safe range\n                if (comptimeValue > BigInt(Number.MAX_SAFE_INTEGER) ||\n                    comptimeValue < BigInt(Number.MIN_SAFE_INTEGER)) {\n                    return undefined;\n                }\n\n                return Number(comptimeValue);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private areTypesCompatible(t1: string, t2: string, op: string): boolean {\n                // Same types - but check if operation is valid for that type\n                if (t1 === t2) {\n                    // Bool is only compatible with bool for logical/comparison operations\n                    if (t1 === 'bool') {\n                        return op === 'LogicalAnd' ||\n                            op === 'LogicalOr' ||\n                            op === 'Equality' ||\n                            op === 'Relational';\n                    }\n                    // Null only for equality\n                    if (t1 === 'null') {\n                        return op === 'Equality' || op === 'Relational';\n                    }\n                    return true;\n                }\n\n                // Numeric types can mix (int + float = float)\n                if ((t1 === 'int' || t1 === 'float') && (t2 === 'int' || t2 === 'float')) {\n                    // But NOT for bitwise or shift operations\n                    if (op === 'BitwiseAnd' || op === 'BitwiseXor' || op === 'BitwiseOr' || op === 'Shift') {\n                        return t1 === 'int' && t2 === 'int';\n                    }\n                    return true;\n                }\n\n                // Bool with anything else is incompatible\n                if (t1 === 'bool' || t2 === 'bool') {\n                    return false;\n                }\n\n                // Null can only compare with null\n                if (t1 === 'null' || t2 === 'null') {\n                    return op === 'Equality';\n                }\n\n                return false;\n            }\n\n            private toFloat(result: EvaluationResult): number {\n                if (result.type === 'float') return result.value as number;\n                if (result.type === 'int') return Number(result.value);\n                return 0;\n            }\n\n            private compare(l: any, r: any, op: string): boolean {\n                switch (op) {\n                    case '==': return l === r;\n                    case '!=': return l !== r;\n                    case '<': return l < r;\n                    case '<=': return l <= r;\n                    case '>': return l > r;\n                    case '>=': return l >= r;\n                    default: return false;\n                }\n            }\n\n            private isFloatType(type: AST.TypeNode): boolean {\n                return type.isFloat() || type.isComptimeFloat();\n            }\n\n            private isIntegerType(type: AST.TypeNode): boolean {\n                return type.isSigned() || type.isUnsigned() || type.isComptimeInt();\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private reportError(code: DiagCode, message: string, span?: AST.Span): void {\n                this.config.services.diagnosticManager.reportError(code, message, span);\n            }\n\n            private reportWarning(code: DiagCode, message: string, span?: AST.Span): void {\n                this.config.services.diagnosticManager.reportWarning(code, message, span);\n            }\n\n            private reportInfo(code: DiagCode, message: string, span?: AST.Span): void {\n                this.config.services.diagnosticManager.reportInfo(code, message, span);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// SemanticValidator.ts — Complete semantic validation phase\n//\n// Developed with ❤️ by Maysara.\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as AST                     from '@je-es/ast';\n    import { AnalysisPhase }            from '../components/ContextTracker';\n    import { DiagCode, DiagKind }       from '../components/DiagnosticManager';\n    import { AnalysisConfig }           from '../ast-analyzer';\n    import { PhaseBase }                from '../interfaces/PhaseBase';\n    import { ScopeKind, Symbol, SymbolKind }       from '../components/ScopeManager';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    interface EntryPointValidation {\n        hasEntryModule: boolean;\n        hasMainFunction: boolean;\n        mainIsPublic: boolean;\n        errors: string[];\n    }\n\n    interface UnusedSymbolAnalysis {\n        unusedVariables: Symbol[];\n        unusedParameters: Symbol[];\n        unusedFunctions: Symbol[];\n        totalUnused: number;\n    }\n\n    interface SemanticStats {\n        entryPointChecks: number;\n        unusedSymbolChecks: number;\n        visibilityChecks: number;\n        moduleIntegrityChecks: number;\n        errors: number;\n        warnings: number;\n        startTime: number;\n    }\n\n    // Constants for analysis\n    const MAX_INT32 = 2147483647;\n    const MIN_INT32 = -2147483648;\n    const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class SemanticValidator extends PhaseBase {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            private stats               : SemanticStats         = this.initStats();\n\n            constructor( config : AnalysisConfig ) {\n                super(AnalysisPhase.SemanticValidation, config);\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ────────────────────────────────┐\n\n            handle(): boolean {\n                try {\n                    this.log('verbose', 'Starting semantic validation phase...');\n                    this.stats.startTime = Date.now();\n\n                    this.validateEntryPoint();\n                    this.validateUnusedSymbols();\n                    this.validateModuleIntegrity();\n                    this.validateVisibilityRules();\n\n                    this.logStatistics();\n                    return !this.config.services.diagnosticManager.hasErrors();\n\n                } catch (error) {\n                    this.log('errors', `Fatal error during semantic validation: ${error}`);\n                    this.reportError(\n                        DiagCode.ANALYSIS_ERROR,\n                        `Semantic validation failed: ${error}`\n                    );\n                    return false;\n                }\n            }\n\n            reset(): void {\n                this.stats              = this.initStats();\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private validateEntryPoint(): void {\n                this.log('symbols', 'Validating entry point');\n                this.stats.entryPointChecks++;\n\n                const entryModuleName = this.config.program!.metadata?.entryModule as string;\n                if (!entryModuleName) {\n                    // No entry module specified - this might be a library, so just return\n                    this.log('verbose', 'No entry module specified, skipping entry point validation');\n                    return;\n                }\n\n                const validation = this.performEntryPointValidation(entryModuleName);\n                this.reportEntryPointErrors(validation, entryModuleName);\n            }\n\n            private performEntryPointValidation(entryModuleName: string): EntryPointValidation {\n                const result: EntryPointValidation = {\n                    hasEntryModule: false,\n                    hasMainFunction: false,\n                    mainIsPublic: false,\n                    errors: []\n                };\n\n                // Check if entry module exists\n                const entryModule = this.config.program!.modules.get(entryModuleName);\n                if (!entryModule) {\n                    result.errors.push(`Entry module '${entryModuleName}' not found`);\n                    return result;\n                }\n                result.hasEntryModule = true;\n\n                // Set context for better error reporting\n                this.config.services.contextTracker.setModuleName(entryModuleName);\n                if (typeof entryModule.metadata?.path === 'string') {\n                    this.config.services.contextTracker.setModulePath(entryModule.metadata.path);\n                }\n\n                // Look for main function\n                const mainFunc = entryModule.findFunction('main');\n                if (!mainFunc) {\n                    result.errors.push(`Entry module '${entryModuleName}' does not contain 'main' function`);\n                    return result;\n                }\n                result.hasMainFunction = true;\n\n                // Check if main is public\n                if (mainFunc.visibility.kind !== 'Public') {\n                    result.errors.push(`Main function in entry module '${entryModuleName}' must be public`);\n                    return result;\n                }\n                result.mainIsPublic = true;\n\n                // Additional validation for main function signature\n                this.validateMainFunctionSignature(mainFunc, result);\n\n                return result;\n            }\n\n            private validateMainFunctionSignature(mainFunc: AST.FuncStmtNode, result: EntryPointValidation): void {\n                // Validate parameter count (main should have 0 or specific parameters)\n                if (mainFunc.parameters.length > 2) {\n                    result.errors.push(`Main function should not have more than 2 parameters`);\n                }\n\n                // Check return type if specified\n                if (mainFunc.returnType && !this.isValidMainReturnType(mainFunc.returnType)) {\n                    result.errors.push(`Main function should return void or exit code type`);\n                }\n            }\n\n            private isValidMainReturnType(returnType: AST.TypeNode): boolean {\n                return returnType.isVoid() ||\n                       (returnType.isSigned() && returnType.getWidth() === 32) ||\n                       (returnType.isUnsigned() && returnType.getWidth() === 8);\n            }\n\n            private reportEntryPointErrors(validation: EntryPointValidation, entryModuleName: string): void {\n                for (const error of validation.errors) {\n                    let code: DiagCode;\n\n                    if (error.includes('not found')) {\n                        code = DiagCode.ENTRY_MODULE_NOT_FOUND;\n                    } else if (error.includes('does not contain')) {\n                        code = DiagCode.ENTRY_MODULE_NO_MAIN;\n                    } else if (error.includes('must be public')) {\n                        code = DiagCode.ENTRY_MODULE_PRIVATE_MAIN;\n                    } else {\n                        code = DiagCode.ANALYSIS_ERROR;\n                    }\n\n                    this.reportError(code, error);\n                    this.stats.errors++;\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private validateUnusedSymbols(): void {\n                this.log('symbols', 'Validating unused symbols');\n                this.stats.unusedSymbolChecks++;\n\n                const analysis = this.analyzeUnusedSymbols();\n                this.reportUnusedSymbols(analysis);\n            }\n\n            private analyzeUnusedSymbols(): UnusedSymbolAnalysis {\n                const analysis: UnusedSymbolAnalysis = {\n                    unusedVariables: [],\n                    unusedParameters: [],\n                    unusedFunctions: [],\n                    totalUnused: 0\n                };\n\n                for (const symbol of this.config.services.scopeManager.getAllSymbols().values()) {\n                    if (!symbol.used && this.shouldCheckForUnused(symbol)) {\n                        switch (symbol.kind) {\n                            case SymbolKind.Variable:\n                                analysis.unusedVariables.push(symbol);\n                                break;\n                            case SymbolKind.Parameter:\n                                analysis.unusedParameters.push(symbol);\n                                break;\n                            case SymbolKind.Function:\n                                analysis.unusedFunctions.push(symbol);\n                                break;\n                        }\n                        analysis.totalUnused++;\n                    }\n                }\n\n                return analysis;\n            }\n\n            private shouldCheckForUnused(symbol: Symbol): boolean {\n                // Skip symbols that start with underscore (conventional ignore)\n                if (symbol.name.startsWith('_')) {\n                    return false;\n                }\n\n                // Skip public symbols (may be used by other modules or external code)\n                if (symbol.visibility.kind === 'Public') {\n                    return false;\n                }\n\n                // Skip main function\n                if (symbol.name === 'main' && symbol.kind === SymbolKind.Function) {\n                    return false;\n                }\n\n                // Skip builtin functions\n                if (symbol.name.startsWith('@')) {\n                    return false;\n                }\n\n                // Skip imported symbols (they might be used indirectly)\n                if (symbol.importSource) {\n                    return false;\n                }\n\n                return true;\n            }\n\n            private reportUnusedSymbols(analysis: UnusedSymbolAnalysis): void {\n                // Report unused variables\n                for (const symbol of analysis.unusedVariables) {\n                    this.reportUnusedSymbol(symbol, DiagCode.UNUSED_VARIABLE, 'Variable');\n                }\n\n                // Report unused parameters\n                for (const symbol of analysis.unusedParameters) {\n                    this.reportUnusedSymbol(symbol, DiagCode.UNUSED_PARAMETER, 'Parameter');\n                }\n\n                // Report unused functions\n                for (const symbol of analysis.unusedFunctions) {\n                    this.reportUnusedSymbol(symbol, DiagCode.UNUSED_FUNCTION, 'Function');\n                }\n\n                // Log summary\n                if (analysis.totalUnused > 0) {\n                    this.log('verbose',\n                        `Found ${analysis.totalUnused} unused symbols: ` +\n                        `${analysis.unusedVariables.length} variables, ` +\n                        `${analysis.unusedParameters.length} parameters, ` +\n                        `${analysis.unusedFunctions.length} functions`\n                    );\n                }\n            }\n\n            private reportUnusedSymbol(symbol: Symbol, code: DiagCode, symbolType: string): void {\n                const prevModule = this.config.services.contextTracker.getModuleName();\n                const prevPath = this.config.services.contextTracker.getModulePath();\n                const prevSpan = this.config.services.contextTracker.getContextSpan();\n\n                try {\n                    // Set module context for better error reporting\n                    if (symbol.module) {\n                        this.config.services.contextTracker.setModuleName(symbol.module);\n                        const module = this.config.program!.modules.get(symbol.module);\n                        if (module && typeof module.metadata?.path === 'string') {\n                            this.config.services.contextTracker.setModulePath(module.metadata.path);\n                        }\n                    }\n\n                    this.config.services.contextTracker.setCurrentContextSpan(symbol.contextSpan);\n\n                    // ✅ Don't warn about unused static methods\n                    if (symbol.kind === SymbolKind.Function) {\n                        const parentScope = this.config.services.scopeManager.getScope(symbol.scope);\n                        if (parentScope.kind === ScopeKind.Type) {\n                            // Check if it's a static method\n                            if (symbol.visibility.kind === 'Static') {\n                                return; // Skip warning for static methods\n                            }\n                        }\n                    }\n\n                    if(symbol.name === 'self' && symbol.kind === SymbolKind.Parameter) {\n                        return; // Skip warning for 'self' in function\n                    }\n\n                    this.config.services.diagnosticManager.push({\n                        code,\n                        kind: DiagKind.WARNING,\n                        msg: `${symbolType} '${symbol.name}' is declared but never used`,\n                        targetSpan: symbol.targetSpan\n                    });\n\n                    this.stats.warnings++;\n                } finally {\n                    // Restore previous context\n                    this.config.services.contextTracker.setModuleName(prevModule);\n                    this.config.services.contextTracker.setModulePath(prevPath);\n                    this.config.services.contextTracker.setCurrentContextSpan(prevSpan);\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private validateModuleIntegrity(): void {\n                this.log('symbols', 'Validating module integrity');\n                this.stats.moduleIntegrityChecks++;\n\n                for (const [moduleName, module] of this.config.program!.modules) {\n                    this.validateSingleModuleIntegrity(moduleName, module);\n                }\n            }\n\n            private validateSingleModuleIntegrity(moduleName: string, module: AST.Module): void {\n                const prevModule = this.config.services.contextTracker.getModuleName();\n                const prevPath = this.config.services.contextTracker.getModulePath();\n                const prevSpan = this.config.services.contextTracker.getContextSpan();\n\n                try {\n                    this.config.services.contextTracker.setModuleName(moduleName);\n                    if (typeof module.metadata?.path === 'string') {\n                        this.config.services.contextTracker.setModulePath(module.metadata.path);\n                    }\n\n                    // Set span context from module metadata if it's a valid span\n                    const moduleSpan = module.metadata?.span;\n                    if (moduleSpan && typeof moduleSpan === 'object' &&\n                        'start' in moduleSpan && 'end' in moduleSpan) {\n                        this.config.services.contextTracker.setCurrentContextSpan(moduleSpan as AST.Span);\n                    }\n\n                    // Check for empty modules\n                    if (module.statements.length === 0) {\n                        this.reportWarning(\n                            DiagCode.ANALYSIS_ERROR,\n                            `Module '${moduleName}' is empty`\n                        );\n                        return;\n                    }\n\n                    // // Check for modules with only imports\n                    // const nonImportStatements = module.statements.filter(stmt => stmt.kind !== 'Use');\n                    // if (nonImportStatements.length === 0) {\n                    //     this.reportWarning(\n                    //         DiagCode.ANALYSIS_ERROR,\n                    //         `Module '${moduleName}' contains only imports`\n                    //     );\n                    // }\n                } finally {\n                    // Restore previous context\n                    this.config.services.contextTracker.setModuleName(prevModule);\n                    this.config.services.contextTracker.setModulePath(prevPath);\n                    this.config.services.contextTracker.setCurrentContextSpan(prevSpan);\n                }\n\n                // Check for circular imports\n                this.checkCircularImports(moduleName, module);\n\n                // Validate export consistency\n                this.validateExportConsistency(moduleName, module);\n            }\n\n            private checkCircularImports(moduleName: string, module: AST.Module): void {\n                const importedModules = new Set<string>();\n\n                for (const stmt of module.statements) {\n                    if (stmt.kind === 'Use') {\n                        const useNode = stmt.getUse()!;\n                        if (useNode.path) {\n                            const importedModule = this.findModuleByPath(useNode.path);\n                            if (importedModule) {\n                                importedModules.add(importedModule);\n\n                                // Check if imported module also imports this module\n                                if (this.hasCircularImport(moduleName, importedModule, new Set())) {\n                                    this.reportWarning(\n                                        DiagCode.IMPORT_CIRCULAR_DEPENDENCY,\n                                        `Circular import detected between '${moduleName}' and '${importedModule}'`,\n                                        useNode.span\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            private hasCircularImport(originalModule: string, currentModule: string, visited: Set<string>): boolean {\n                if (visited.has(currentModule)) {\n                    return currentModule === originalModule;\n                }\n\n                visited.add(currentModule);\n                const module = this.config.program!.modules.get(currentModule);\n                if (!module) return false;\n\n                for (const stmt of module.statements) {\n                    if (stmt.kind === 'Use') {\n                        const useNode = stmt.getUse()!;\n                        if (useNode.path) {\n                            const importedModule = this.findModuleByPath(useNode.path);\n                            if (importedModule === originalModule) {\n                                return true;\n                            }\n                            if (importedModule && this.hasCircularImport(originalModule, importedModule, new Set(visited))) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n\n                return false;\n            }\n\n            private validateExportConsistency(moduleName: string, module: AST.Module): void {\n                // Check that all public symbols are actually accessible\n                const moduleScope = this.config.services.scopeManager.findScopeByName(moduleName, 'Module' as any);\n                if (!moduleScope) return;\n\n                for (const [symbolName, symbol] of moduleScope.symbols) {\n                    if (symbol.visibility.kind === 'Public' && !symbol.used) {\n                        // This is handled by unused symbol validation, but we could add\n                        // module-specific export consistency checks here\n                    }\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private validateVisibilityRules(): void {\n                this.log('symbols', 'Validating visibility rules');\n                this.stats.visibilityChecks++;\n\n                for (const symbol of this.config.services.scopeManager.getAllSymbols().values()) {\n                    this.validateSymbolVisibility(symbol);\n                }\n            }\n\n            private validateSymbolVisibility(symbol: Symbol): void {\n                // Private symbols should not be accessed outside their module\n                if (symbol.visibility.kind === 'Private' && symbol.used) {\n                    this.validatePrivateSymbolUsage(symbol);\n                }\n\n                // Public symbols should be meaningfully public\n                if (symbol.visibility.kind === 'Public') {\n                    this.validatePublicSymbolExposure(symbol);\n                }\n            }\n\n            private validatePrivateSymbolUsage(symbol: Symbol): void {\n                // This would require more sophisticated cross-module usage analysis\n                // For now, we trust that the symbol resolver has handled this correctly\n            }\n\n            private validatePublicSymbolExposure(symbol: Symbol): void {\n                // Check if public symbols are actually used or meant to be API\n                if (!symbol.used && symbol.kind !== SymbolKind.Function) {\n                    // Public unused symbols might indicate API design issues\n                    // But this is more of a design hint than an error\n                }\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private findModuleByPath(importPath: string): string | undefined {\n                for (const [name, module] of this.config.program!.modules) {\n                    const modulePath = module.metadata?.path as string | undefined;\n                    if (modulePath === importPath) {\n                        return name;\n                    }\n                }\n                return undefined;\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            private init(): boolean {\n                this.config.services.contextTracker.reset();\n                this.config.services.contextTracker.setPhase(AnalysisPhase.SemanticValidation);\n\n                this.log('verbose', 'Semantic validation initialized');\n                return true;\n            }\n\n            private initStats(): SemanticStats {\n                return {\n                    entryPointChecks: 0,\n                    unusedSymbolChecks: 0,\n                    visibilityChecks: 0,\n                    moduleIntegrityChecks: 0,\n                    errors: 0,\n                    warnings: 0,\n                    startTime: Date.now()\n                };\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\n\n            logStatistics(): void {\n                const duration = Date.now() - this.stats.startTime;\n                this.log('verbose',\n                    `Semantic Validation Statistics     :\\n` +\n                    `  Duration                         : ${duration}ms\\n` +\n                    `  Entry point checks               : ${this.stats.entryPointChecks}\\n` +\n                    `  Unused symbol checks             : ${this.stats.unusedSymbolChecks}\\n` +\n                    `  Visibility checks                : ${this.stats.visibilityChecks}\\n` +\n                    `  Module integrity checks          : ${this.stats.moduleIntegrityChecks}\\n` +\n                    `  Errors                           : ${this.stats.errors}\\n` +\n                    `  Warnings                         : ${this.stats.warnings}`\n                );\n            }\n\n        // └──────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// Analyzer.ts — Main AST analyzer with multi-phase validation\r\n//\r\n// Developed with ❤️ by Maysara.\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\r\n\r\n    import * as AST                                 from '@je-es/ast';\r\n    import * as Diag                                from './components/DiagnosticManager';\r\n    import { ContextTracker, AnalysisPhase }        from './components/ContextTracker';\r\n    import { DebugManager, DebugKind }              from './components/DebugManager';\r\n    import { ScopeManager }                         from './components/ScopeManager';\r\n    import { SymbolCollector }                      from './phases/SymbolCollector';\r\n    import { SymbolResolver }                       from './phases/SymbolResolver';\r\n    import { TypeValidator }                        from './phases/TypeValidator';\r\n    import { SemanticValidator }                    from './phases/SemanticValidator';\r\n\r\n    // Re-export\r\n    export { type Diagnostic, DiagCode, DiagKind, DiagnosticFix, DiagnosticManager }\r\n                                                from './components/DiagnosticManager';\r\n    export { DebugManager }                     from './components/DebugManager';\r\n    export { ContextTracker, AnalysisPhase }    from './components/ContextTracker';\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\r\n\r\n    /** Analysis configuration options */\r\n    export interface AnalysisConfig {\r\n        /** Debug output level */\r\n        debug               ?: DebugKind;\r\n        /** Stop after specific phase */\r\n        stopAtPhase         ?: AnalysisPhase;\r\n        /** Enable strict mode (fail fast) */\r\n        strictMode          ?: boolean;\r\n        /** Maximum number of errors before stopping */\r\n        maxErrors           ?: number;\r\n\r\n        services            : AnalysisServices;\r\n\r\n        program             : AST.Program | null;\r\n    }\r\n\r\n    /** Analysis result with diagnostics and metadata */\r\n    export interface AnalysisResult {\r\n\r\n        /** Whether analysis succeeded without errors */\r\n        success             : boolean;\r\n\r\n        /** All diagnostic messages */\r\n        diagnostics         : Diag.Diagnostic[];\r\n\r\n        // /** Analysis performance metrics */\r\n        // performance?: PerformanceReport;\r\n\r\n        /** Phase where analysis stopped */\r\n        completedPhase      ?: AnalysisPhase;\r\n\r\n        /** Debug information (if enabled) */\r\n        debugInfo           ?: {\r\n            totalTime: number;\r\n            phaseTimings: Map<AnalysisPhase, number>;\r\n            memoryUsage?: number;\r\n        };\r\n    }\r\n\r\n    /** Internal phase result */\r\n    export interface PhaseResult {\r\n        success             : boolean;\r\n        phase               : AnalysisPhase;\r\n        duration            : number;\r\n        errors              : number;\r\n        warnings            : number;\r\n    }\r\n\r\n    /** Analysis services */\r\n    export interface AnalysisServices {\r\n        debugManager        : DebugManager;\r\n        contextTracker      : ContextTracker;\r\n        diagnosticManager   : Diag.DiagnosticManager;\r\n        scopeManager        : ScopeManager;\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\r\n\r\n    /**\r\n     * Multi-phase AST analyzer for je-es language\r\n     *\r\n     * Provides comprehensive analysis including:\r\n     * - Symbol collection and scope management\r\n     * - Symbol resolution and usage validation\r\n     * - Type checking and inference\r\n     * - Semantic validation\r\n     */\r\n    export class Analyzer {\r\n\r\n        // ┌────────────────────────── INITIALIZATION ──────────────────────────┐\r\n\r\n            config              : Required<AnalysisConfig>;\r\n            phaseTimings        : Map<AnalysisPhase, number> = new Map();\r\n            symbolCollector     : SymbolCollector;\r\n            symbolResolver      : SymbolResolver;\r\n            typeValidator       : TypeValidator;\r\n            semanticValidator   : SemanticValidator;\r\n\r\n            private constructor(config: Partial<AnalysisConfig> = {}) {\r\n                // Merge with defaults\r\n                this.config = this.createConfig(config);\r\n\r\n                // Initialize phase validators\r\n                this.symbolCollector    = new SymbolCollector(this.config);\r\n                this.symbolResolver     = new SymbolResolver(this.config);\r\n                this.typeValidator      = new TypeValidator(this.config);\r\n                this.semanticValidator  = new SemanticValidator(this.config);\r\n\r\n                this.log('verbose', `🚀 Analyzer initialized with config: ${JSON.stringify(this.config)}`);\r\n            }\r\n\r\n            getDiagMgr = () => this.config.services.diagnosticManager;\r\n\r\n            /** Factory method to create analyzer instance */\r\n            static create(config?: Partial<AnalysisConfig>): Analyzer {\r\n                return new Analyzer(config);\r\n            }\r\n\r\n            private log(kind: DebugKind = 'verbose', message: string ) {\r\n                this.config.services.debugManager.log(kind, message);\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────── MAIN ANALYSIS INTERFACE ───────────────────┐\r\n\r\n            /**\r\n             * Analyze a program through all configured phases\r\n             * @param program The AST program to analyze\r\n             * @param config Optional runtime configuration overrides\r\n             * @returns Analysis result with diagnostics and metadata\r\n             */\r\n            analyze(program: AST.Program, config?: Partial<AnalysisConfig>): AnalysisResult {\r\n                const startTime = Date.now();\r\n                this.log('verbose', '🔍 Starting multi-phase analysis...');\r\n\r\n                try {\r\n                    // Apply runtime config overrides\r\n                    const effectiveConfig = { ...this.config, ...config };\r\n\r\n                    // Reset all components\r\n                    // this.reset();\r\n\r\n                    // Validate program structure\r\n                    if (!this.validateProgramStructure(program)) {\r\n                        return this.createErrorResult('Invalid program structure', AnalysisPhase.Collection);\r\n                    }\r\n\r\n                    // Set the program\r\n                    this.config.program = program;\r\n\r\n                    // Execute phases in order\r\n                    const phases: Array<{ phase: AnalysisPhase, executor: () => boolean }> = [\r\n\r\n                        { phase: AnalysisPhase.Collection,          executor: () => this.executePhase1() },\r\n                        { phase: AnalysisPhase.Resolution,          executor: () => this.executePhase2() },\r\n                        { phase: AnalysisPhase.TypeValidation,      executor: () => this.executePhase3() },\r\n                        { phase: AnalysisPhase.SemanticValidation,  executor: () => this.executePhase4() },\r\n                    ];\r\n\r\n                    let completedPhase: AnalysisPhase = AnalysisPhase.Collection;\r\n                    let shouldContinue = true;\r\n\r\n                    for (const { phase, executor } of phases) {\r\n                        if (!shouldContinue || this.shouldStopAtPhase(phase, effectiveConfig.stopAtPhase)) {\r\n                            break;\r\n                        }\r\n\r\n                        const phaseResult = this.runPhase(phase, executor);\r\n                        completedPhase = phase;\r\n\r\n                        // Check if we should continue\r\n                        if (!phaseResult.success) {\r\n                            if (effectiveConfig.strictMode) {\r\n                                this.log('errors', `❌ Stopping analysis at phase ${phase} due to errors (strict mode)`);\r\n                                shouldContinue = false;\r\n                            }\r\n                        }\r\n\r\n                        // Check error limit\r\n                        if (this.config.services.diagnosticManager.length() >= effectiveConfig.maxErrors) {\r\n                            this.log('errors', `⚠️ Stopping analysis due to error limit (${effectiveConfig.maxErrors})`);\r\n                            shouldContinue = false;\r\n                        }\r\n                    }\r\n\r\n                    // Generate final result\r\n                    const totalTime = Date.now() - startTime;\r\n                    const result = this.createFinalResult(completedPhase, totalTime);\r\n\r\n                    this.log('verbose',\r\n                        `✅ Analysis completed in ${totalTime}ms\\n` +\r\n                        `   Success: ${result.success}\\n` +\r\n                        `   Errors: ${result.diagnostics.filter(d => d.kind === 'error').length}\\n` +\r\n                        `   Warnings: ${result.diagnostics.filter(d => d.kind === 'warning').length}\\n` +\r\n                        `   Completed phase: ${completedPhase}`\r\n                    );\r\n\r\n                    // if we have errors log it\r\n                    for (const diagnostic of result.diagnostics) {\r\n                        this.log('errors', `${diagnostic.kind}: ${diagnostic.msg}`);\r\n                    }\r\n\r\n                    return result;\r\n\r\n                } catch (error) {\r\n                    this.log('errors', `💥 Fatal analysis error: ${error}`);\r\n                    return this.createFatalErrorResult(error instanceof Error ? error.message : String(error));\r\n                }\r\n            }\r\n\r\n            /**\r\n             * Get debug log for troubleshooting\r\n             */\r\n            getDebugLog(): string[] {\r\n                // This would need to be implemented in DebugManager if you want to capture logs\r\n                return [];\r\n            }\r\n\r\n            private createServices(config ?: Partial<AnalysisConfig>): AnalysisServices {\r\n                const debugManager       = new DebugManager(undefined, config?.debug ?? 'off');\r\n                const contextTracker     = new ContextTracker(debugManager);\r\n                const diagnosticManager  = new Diag.DiagnosticManager(contextTracker, config?.strictMode ?? false);\r\n                const scopeManager       = new ScopeManager(diagnosticManager, debugManager);\r\n\r\n                return { debugManager, contextTracker, diagnosticManager, scopeManager }\r\n            }\r\n\r\n            private createConfig(config: Partial<AnalysisConfig>): Required<AnalysisConfig> {\r\n                return {\r\n                    debug           : config.debug          ?? 'off',\r\n                    stopAtPhase     : config.stopAtPhase    ?? AnalysisPhase.SemanticValidation,\r\n                    strictMode      : config.strictMode     ?? false,\r\n                    maxErrors       : config.maxErrors      ?? 100,\r\n                    services        : this.createServices(config),\r\n                    program         : config.program     ?? null,\r\n                };\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n        // ┌────────────────────────── PHASE EXECUTION ─────────────────────────┐\r\n\r\n            private executePhase1(): boolean {\r\n                this.log('symbols', '📂 Phase 1: Symbol Collection');\r\n                return this.symbolCollector.handle();\r\n            }\r\n\r\n            private executePhase2(): boolean {\r\n                this.log('symbols', '🔗 Phase 2: Symbol Resolution');\r\n                return this.symbolResolver.handle();\r\n            }\r\n\r\n            private executePhase3(): boolean {\r\n                this.log('symbols', '🔍 Phase 3: Type Validation');\r\n                return this.typeValidator.handle();\r\n            }\r\n\r\n            private executePhase4(): boolean {\r\n                this.log('symbols', '✅ Phase 4: Semantic Validation');\r\n                return this.semanticValidator.handle();\r\n            }\r\n\r\n            private runPhase(phase: AnalysisPhase, executor: () => boolean): PhaseResult {\r\n                const startTime = Date.now();\r\n                const errorsBefore = this.config.services.diagnosticManager.length();\r\n\r\n                this.log('verbose', `🔄 Starting phase: ${phase}`);\r\n                this.config.services.debugManager.increaseIndent();\r\n\r\n                try {\r\n                    const success = executor();\r\n                    const duration = Date.now() - startTime;\r\n                    const errorsAfter = this.config.services.diagnosticManager.length();\r\n                    const newErrors = Math.max(0, errorsAfter - errorsBefore);\r\n                    const newWarnings = this.config.services.diagnosticManager.getDiagnostics()\r\n                        .slice(errorsBefore)\r\n                        .filter(d => d.kind === 'warning').length;\r\n\r\n                    this.phaseTimings.set(phase, duration);\r\n\r\n                    const result: PhaseResult = {\r\n                        success,\r\n                        phase,\r\n                        duration,\r\n                        errors: newErrors,\r\n                        warnings: newWarnings\r\n                    };\r\n\r\n                    this.log('verbose',\r\n                        `✨ Phase ${phase} completed in ${duration}ms ` +\r\n                        `(${newErrors} errors, ${newWarnings} warnings)`\r\n                    );\r\n\r\n                    // if we have errors log it\r\n                    for (const diagnostic of this.config.services.diagnosticManager.getDiagnostics().slice(errorsBefore)) {\r\n                        this.log('errors', `${diagnostic.kind}: ${diagnostic.msg}`);\r\n                    }\r\n\r\n                    return result;\r\n                } finally {\r\n                    this.config.services.debugManager.decreaseIndent();\r\n                }\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n        // ┌─────────────────────── VALIDATION AND UTILITIES ───────────────────┐\r\n\r\n            private validateProgramStructure(program: AST.Program): boolean {\r\n                if (!program) {\r\n                    this.config.services.diagnosticManager.reportError(\r\n                        Diag.DiagCode.INTERNAL_ERROR,\r\n                        'Program is null or undefined'\r\n                    );\r\n                    return false;\r\n                }\r\n\r\n                if (!program.modules || program.modules.size === 0) {\r\n                    this.config.services.diagnosticManager.reportError(\r\n                        Diag.DiagCode.MODULE_NOT_FOUND,\r\n                        'Program contains no modules'\r\n                    );\r\n                    return false;\r\n                }\r\n\r\n                // Validate entry module exists if specified\r\n                const entryModule = program.metadata?.entryModule as string;\r\n                if (entryModule && !program.modules.has(entryModule)) {\r\n                    this.config.services.diagnosticManager.reportError(\r\n                        Diag.DiagCode.ENTRY_MODULE_NOT_FOUND,\r\n                        `Entry module '${entryModule}' not found`\r\n                    );\r\n                    return false;\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            private shouldStopAtPhase(currentPhase: AnalysisPhase, targetPhase: AnalysisPhase): boolean {\r\n                const phaseOrder = [\r\n                    AnalysisPhase.Collection,\r\n                    AnalysisPhase.Resolution,\r\n                    AnalysisPhase.TypeValidation,\r\n                    AnalysisPhase.SemanticValidation,\r\n                ];\r\n\r\n                const currentIndex = phaseOrder.indexOf(currentPhase);\r\n                const targetIndex = phaseOrder.indexOf(targetPhase);\r\n\r\n                return currentIndex > targetIndex;\r\n            }\r\n\r\n            reset(): void {\r\n                this.log('verbose', '🔄 Resetting analyzer state...');\r\n\r\n                this.phaseTimings.clear();\r\n                this.config.services.contextTracker.reset();\r\n                this.config.services.diagnosticManager.reset();\r\n                this.config.services.debugManager.reset();\r\n                this.config.services.scopeManager.reset();\r\n\r\n                this.config.program = null;\r\n\r\n                this.symbolCollector.reset();\r\n                this.symbolResolver.reset();\r\n                this.typeValidator.reset();\r\n                this.semanticValidator.reset();\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n\r\n        // ┌───────────────────────── RESULT GENERATION ────────────────────────┐\r\n\r\n            private createFinalResult(completedPhase: AnalysisPhase, totalTime: number): AnalysisResult {\r\n                const diagnostics = this.config.services.diagnosticManager.getDiagnostics();\r\n                const hasErrors = diagnostics.some(d => d.kind === Diag.DiagKind.ERROR);\r\n\r\n                const result: AnalysisResult = {\r\n                    success: !hasErrors,\r\n                    diagnostics,\r\n                    completedPhase,\r\n                    debugInfo: {\r\n                        totalTime,\r\n                        phaseTimings: new Map(this.phaseTimings),\r\n                        memoryUsage: this.getMemoryUsage()\r\n                    }\r\n                };\r\n\r\n                return result;\r\n            }\r\n\r\n            private createErrorResult(message: string, phase: AnalysisPhase): AnalysisResult {\r\n                this.config.services.diagnosticManager.reportError(Diag.DiagCode.ANALYSIS_ERROR, message);\r\n\r\n                return {\r\n                    success: false,\r\n                    diagnostics: this.config.services.diagnosticManager.getDiagnostics(),\r\n                    completedPhase: phase\r\n                };\r\n            }\r\n\r\n            private createFatalErrorResult(message: string): AnalysisResult {\r\n                return {\r\n                    success: false,\r\n                    diagnostics: [{\r\n                        code: Diag.DiagCode.INTERNAL_ERROR,\r\n                        kind: Diag.DiagKind.ERROR,\r\n                        msg: `Fatal analysis error: ${message}`,\r\n                        targetSpan: { start: 0, end: 0 }\r\n                    }]\r\n                };\r\n            }\r\n\r\n            private getMemoryUsage(): number | undefined {\r\n                try {\r\n                    if (typeof process !== 'undefined' && process.memoryUsage) {\r\n                        return process.memoryUsage().heapUsed;\r\n                    }\r\n                } catch {\r\n                    // Ignore memory usage collection errors\r\n                }\r\n                return undefined;\r\n            }\r\n\r\n        // └────────────────────────────────────────────────────────────────────┘\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// Module.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { StmtNode, StmtKind }   from '../nodes/level-1/StmtNode';\n    import { FuncStmtNode }             from '../nodes/level-3/StmtNodes/FuncStmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class Module {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            constructor(\n                public name         : string,\n                public statements   : StmtNode[],\n                public exports      : string[],\n                public imports      : string[],\n                public metadata     : Record<string, unknown>,\n            ) { }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(name: string, stmts?: StmtNode[], metadata?: Record<string, unknown>): Module {\n                return new Module(name, stmts || [], [], [], metadata || {});\n            }\n\n            validate(): boolean {\n                try {\n                    // Validate module name\n                    if (!this.name.trim()) {return false;}\n\n                    // Validate all statements\n                    return this.statements.every(stmt => stmt.validate());\n                } catch {\n                    return false;\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── FIND ──────────────────────────────┐\n\n            findStatements(predicate: (stmt: StmtNode) => boolean): StmtNode[] {\n                return this.statements.filter(predicate);\n            }\n\n            findStatement(predicate: (stmt: StmtNode) => boolean): StmtNode | undefined {\n                return this.statements.find(predicate);\n            }\n\n            findStatementsByKind(kind: StmtKind): StmtNode[] {\n                return this.statements.filter(stmt => stmt.kind === kind);\n            }\n\n            findFunction(name: string): FuncStmtNode | undefined {\n                for (const stmt of this.statements) {\n                    if (stmt.is('Func') && stmt.getFunc()!.ident.name === name) {\n                        return stmt.getFunc();\n                    }\n                }\n                return undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── CTRL ──────────────────────────────┐\n\n            removeStatement(index: number): Module {\n                if (index < 0 || index >= this.statements.length) {\n                    throw new Error(`Statement index ${index} out of bounds (0-${this.statements.length - 1})`);\n                }\n\n                const newStatements = [...this.statements];\n                newStatements.splice(index, 1);\n                return new Module(\n                    this.name,\n                    newStatements,\n                    [...this.exports],\n                    [...this.imports],\n                    { ...this.metadata }\n                );\n            }\n\n            insertStatement(index: number, statement: StmtNode): Module {\n                if (index < 0 || index > this.statements.length) {\n                    throw new Error(`Statement index ${index} out of bounds (0-${this.statements.length})`);\n                }\n\n                const newStatements = [...this.statements];\n                newStatements.splice(index, 0, statement);\n                return new Module(\n                    this.name,\n                    newStatements,\n                    [...this.exports],\n                    [...this.imports],\n                    { ...this.metadata }\n                );\n            }\n\n            replaceStatement(index: number, statement: StmtNode): Module {\n                if (index < 0 || index >= this.statements.length) {\n                    throw new Error(`Statement index ${index} out of bounds (0-${this.statements.length - 1})`);\n                }\n\n                const newStatements = [...this.statements];\n                newStatements[index] = statement;\n                return new Module(\n                    this.name,\n                    newStatements,\n                    [...this.exports],\n                    [...this.imports],\n                    { ...this.metadata }\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ──────────────────────────────┐\n\n            isEmpty(): boolean {\n                return this.statements.length === 0;\n            }\n\n            hasStatement(statement: StmtNode): boolean {\n                return this.statements.includes(statement);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ──────────────────────────────┐\n\n            getStatementCount(): number {\n                return this.statements.length;\n            }\n\n            getTotalNodes(): number {\n                let count = 1; // Count self\n                for (const statement of this.statements) {\n                    const countt = 0;\n                    statement.traverse(() => void (count++));\n                    count += countt;\n                }\n                return count;\n            }\n\n            getStatementAt(index: number): StmtNode | undefined {\n                if (index < 0 || index >= this.statements.length) {\n                    return undefined;\n                }\n                return this.statements[index];\n            }\n\n            getStatementIndex(statement: StmtNode): number {\n                return this.statements.indexOf(statement);\n            }\n\n            getPublicStatements(): StmtNode[] {\n                const arr : StmtNode[] = [];\n\n                for (const stmt of this.statements) {\n                    if(\n                        (stmt.is('Let')     && stmt.getLet()!.field.visibility.kind !== 'Private') ||\n                        (stmt.is('Def')     && stmt.getDef()!.visibility.kind  !== 'Private') ||\n                        (stmt.is('Func')    && stmt.getFunc()!.visibility.kind !== 'Private')\n                    ) { arr.push(stmt); }\n                }\n\n                return arr;\n            }\n\n            getPath(): string {\n                return this.metadata?.path as string || '';\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// Program.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Module }               from './Module';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class Program {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            constructor(\n                public modules      : Map<string, Module>,\n                public metadata?    : Record<string, unknown>,\n            ) { }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(modules?: Module[], metadata?: Record<string, unknown>): Program {\n                // create module map from modules\n                const modulesMap = new Map<string, Module>();\n                for (const module of modules || []) {\n                    modulesMap.set(module.name, module);\n                }\n\n                return new Program(modulesMap, metadata);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── FIND ──────────────────────────────┐\n\n            findModules(predicate: (module: Module, name: string) => boolean): [string, Module][] {\n                const results: [string, Module][] = [];\n                for (const [name, module] of this.modules) {\n                    if (predicate(module, name)) {\n                        results.push([name, module]);\n                    }\n                }\n                return results;\n            }\n\n            findModule(predicate: (module: Module, name: string) => boolean): [string, Module] | undefined {\n                for (const [name, module] of this.modules) {\n                    if (predicate(module, name)) {\n                        return [name, module];\n                    }\n                }\n                return undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── CTRL ──────────────────────────────┐\n\n            removeModule(name: string): Program {\n                if (!this.modules.has(name)) {return this;}\n\n                const newModules = new Map(this.modules);\n                newModules.delete(name);\n                return new Program(newModules, this.metadata);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ──────────────────────────────┐\n\n            isEmpty(): boolean {\n                return this.modules.size === 0 ||\n                    Array.from(this.modules.values()).every(m => m.statements.length === 0);\n            }\n\n            hasModule(name: string): boolean {\n                return this.modules.has(name);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── ---- ──────────────────────────────┐\n\n            getModule(name: string): Module | undefined {\n                return this.modules.get(name);\n            }\n\n            getModuleNames(): string[] {\n                return Array.from(this.modules.keys());\n            }\n\n            getTotalModules(): number {\n                return this.modules.size;\n            }\n\n            getTotalStatements(): number {\n                return Array.from(this.modules.values())\n                    .reduce((total, module) => total + module.statements.length, 0);\n            }\n\n            getTotalNodes(): number {\n                let count = this.modules.size; // Count modules themselves\n                for (const module of this.modules.values()) {\n                    count += module.getTotalNodes();\n                }\n                return count;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export interface Span {\n        start           : number;\n        end             : number;\n    }\n\n    export type VisibilityKind = 'Unset' | 'Private' | 'Public' | 'Static';\n    export interface VisibilityInfo {\n        kind            : VisibilityKind;\n        span?           : Span;\n    }\n\n    export type MutabilityKind = 'Unset' | 'Mutable' | 'Immutable';\n    export interface MutabilityInfo {\n        kind            : MutabilityKind;\n        span?           : Span;\n    }\n\n    export type ComptimeKind = 'Unset' | 'Comptime' | 'Runtime';\n    export interface ComptimeInfo {\n        kind            : ComptimeKind;\n        span?           : Span;\n    }\n\n    export interface NameInfo {\n        name            : string;\n        span            : Span;\n    }\n\n    export const DEF_SPAN : Span = { start: -1, end: -1 };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export abstract class Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            abstract readonly level     : number;\n            abstract readonly kind      : string;\n            abstract readonly span      : Span;\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── FIND ──────────────────────────────┐\n\n            // Find descendants matching predicate with proper type guard support\n            findAll<U extends Node>(predicate: (node: Node) => node is U): U[];\n            findAll(predicate: (node: Node) => boolean): Node[];\n            findAll(predicate: (node: Node) => boolean): Node[] {\n                const results: Node[] = [];\n                this.traverse(node => {\n                    if (predicate(node)) {results.push(node);}\n                });\n                return results;\n            }\n\n            // Find first descendant matching predicate with proper type guard support\n            find<U extends Node>(predicate: (node: Node) => node is U): U | null;\n            find(predicate: (node: Node) => boolean): Node | null;\n            find(predicate: (node: Node) => boolean): Node | null {\n                let result: Node | null = null;\n                this.traverse(node => {\n                    if (!result && predicate(node)) {\n                        result = node;\n                        return 'stop';\n                    }\n                });\n                return result;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌────────────────────────────── TRAVERSE ────────────────────────────┐\n\n            // Depth-first traversal with early termination support and enhanced error handling\n            traverse(visitor: (node: Node) => void | 'stop'): void {\n                try {\n                    const result = visitor(this);\n                    if (result === 'stop') {return;}\n\n                    // Get children with proper error handling\n                    let children: readonly Node[];\n                    try {\n                        children = this.getChildrenNodes();\n                    } catch (error) {\n                        throw new Error(`Failed to get children from ${this.kind} node: ${error}`);\n                    }\n\n                    // Validate children array\n                    if (!Array.isArray(children)) {\n                        throw new Error(`getChildrenNodes() returned non-array from ${this.kind} node: ${typeof children}`);\n                    }\n\n                    // Traverse each child with individual error handling\n                    for (let i = 0; i < children.length; i++) {\n                        const child = children[i];\n\n                        // Validate child\n                        if (!child) {\n                            console.warn(`Child ${i} is null/undefined in ${this.kind} node`);\n                            continue;\n                        }\n\n                        if (typeof child !== 'object') {\n                            console.warn(`Child ${i} is not an object in ${this.kind} node: ${typeof child}`);\n                            continue;\n                        }\n\n                        // Check if child is a proper Node\n                        if (!('traverse' in child) || typeof child.traverse !== 'function') {\n                            console.error(`Child ${i} (${child.constructor?.name || 'unknown'}) of ${this.kind} node is missing traverse method`);\n                            console.error('Child object keys:', Object.keys(child));\n                            console.error('Child prototype:', Object.getPrototypeOf(child));\n                            throw new Error(`Child node ${child.constructor?.name || 'unknown'} missing traverse method`);\n                        }\n\n                        // Check if child is actually a Node instance\n                        if (!(child instanceof Node)) {\n                            console.error(`Child ${i} of ${this.kind} node is not a Node instance:`, child.constructor?.name);\n                            throw new Error(`Child ${child.constructor?.name || 'unknown'} is not a Node instance`);\n                        }\n\n                        try {\n                            child.traverse(visitor);\n                        } catch (error) {\n                            throw new Error(`Traversal failed at child ${i} (${child.constructor?.name || 'unknown'}) of ${this.kind} node: ${error}`);\n                        }\n                    }\n                } catch (error) {\n                    // Re-throw with context for better debugging\n                    if (error instanceof Error && error.message.includes('Traversal failed')) {\n                        throw error; // Already has context\n                    }\n                    throw new Error(`Traversal failed at ${this.kind} node: ${error}`);\n                }\n            }\n\n            // Pre-order traversal (visit parent before children)\n            traversePreOrder(visitor: (node: Node) => void | 'stop'): void {\n                this.traverse(visitor);\n            }\n\n            // Post-order traversal (visit children before parent)\n            traversePostOrder(visitor: (node: Node) => void | 'stop'): void {\n                const visitPostOrder = (node: Node): void | 'stop' => {\n                    // First traverse children\n                    for (const child of node.getChildrenNodes()) {\n                        const result = visitPostOrder(child);\n                        if (result === 'stop') {return 'stop';}\n                    }\n\n                    // Then visit current node\n                    return visitor(node);\n                };\n\n                visitPostOrder(this);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            // Check if this node has any children\n            hasChildren(): boolean {\n                try {\n                    return this.getChildrenNodes().length > 0;\n                } catch {\n                    return false;\n                }\n            }\n\n            // Check if this node is a leaf (no children)\n            isLeaf(): boolean {\n                return !this.hasChildren();\n            }\n\n            // Get the depth of this node (maximum distance to any leaf)\n            getDepth(): number {\n                if (this.isLeaf()) {return 0;}\n\n                let maxDepth = 0;\n                try {\n                    for (const child of this.getChildrenNodes()) {\n                        maxDepth = Math.max(maxDepth, child.getDepth());\n                    }\n                } catch (error) {\n                    console.warn(`Error getting depth for ${this.kind} node:`, error);\n                    return 0;\n                }\n\n                return maxDepth + 1;\n            }\n\n            // Count total number of descendant nodes (including self)\n            getNodeCount(): number {\n                let count = 1; // Count self\n                try {\n                    this.traverse(node => {\n                        if (node !== this) {count++;}\n                    });\n                } catch (error) {\n                    console.warn(`Error counting nodes for ${this.kind} node:`, error);\n                }\n                return count;\n            }\n\n            // Get all ancestor kind's in the tree\n            getNodeKinds(): Set<string> {\n                const types = new Set<string>();\n                try {\n                    this.traverse(node => {\n                        types.add(node.kind);\n                    });\n                } catch (error) {\n                    console.warn(`Error getting node types for ${this.kind} node:`, error);\n                    types.add(this.kind); // At least add this node's type\n                }\n                return types;\n            }\n\n            // Create a deep clone of the entire subtree\n            deepClone(newSpan?: Span): Node {\n                // This is a default implementation that subclasses can override for optimization\n                const cloned = this.clone(newSpan);\n\n                // Note: Subclasses should override this method to handle their specific child cloning\n                // This is a fallback that just returns a shallow clone\n                return cloned;\n            }\n\n            // Validation method that subclasses can override\n            validate(): boolean {\n                try {\n                    // Basic validation: ensure all children are valid\n                    const children = this.getChildrenNodes();\n                    for (const child of children) {\n                        if (!child || !child.validate()) {\n                            return false;\n                        }\n                    }\n                    return true;\n                } catch (error) {\n                    console.warn(`Validation error for ${this.kind} node:`, error);\n                    return false;\n                }\n            }\n\n            // Pretty print the AST structure with better error handling\n            printTree(indent = 0): string {\n                const spaces = '  '.repeat(indent);\n                const nodeInfo = `${spaces}${this.kind} (${this.span.start}-${this.span.end})`;\n\n                try {\n                    if (this.isLeaf()) {\n                        return nodeInfo;\n                    }\n\n                    const children = this.getChildrenNodes()\n                        .map(child => {\n                            try {\n                                return child.printTree(indent + 1);\n                            } catch (error) {\n                                return `${spaces}  ERROR: ${child?.constructor?.name || 'unknown'} - ${error}`;\n                            }\n                        })\n                        .join('\\n');\n\n                    return `${nodeInfo}\\n${children}`;\n                } catch (error) {\n                    return `${nodeInfo} [ERROR: ${error}]`;\n                }\n            }\n\n            // Check structural equality with another node (ignoring spans)\n            structurallyEquals(other: Node): boolean {\n                if (this.kind !== other.kind) {return false;}\n\n                try {\n                    const thisChildren = this.getChildrenNodes();\n                    const otherChildren = other.getChildrenNodes();\n\n                    if (thisChildren.length !== otherChildren.length) {return false;}\n\n                    return thisChildren.every((child, index) =>\n                        child.structurallyEquals(otherChildren[index])\n                    );\n                } catch {\n                    return false;\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌────────────────────────────── ABSTRACT ────────────────────────────┐\n\n            // Get direct children (must be implemented by subclasses)\n            abstract getChildrenNodes(): Node[];\n\n            // Clone node (shallow copy with new span)\n            abstract clone(newSpan?: Span): Node;\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class IdentNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Ident' as const;\n            public level = 4;\n\n            constructor(\n                public span         : Span,\n                public name         : string,\n                public builtin      : boolean,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n                return children;\n            }\n\n            clone(newSpan?: Span): IdentNode {\n                const cloned = new IdentNode(newSpan ?? this.span, this.name, this.builtin);\n                return cloned;\n            }\n\n            validate(): boolean {\n                return this.name.trim().length > 0;\n            }\n\n            toString(): string {\n                return `${this.builtin ? '@' : ''}${this.name}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, name: string, builtin = false): IdentNode {\n                return new IdentNode(span, name, builtin);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// BlockStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { StmtNode }     from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class BlockStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Block' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public stmts        : StmtNode[],\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return this.stmts ? this.stmts : [];\n            }\n\n            clone(newSpan?: Span): BlockStmtNode {\n                return new BlockStmtNode(\n                    newSpan ?? this.span,\n                    this.stmts\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, stmts?: StmtNode[]): BlockStmtNode {\n                return new BlockStmtNode(span, stmts ?? []);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// LetStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, VisibilityInfo, MutabilityInfo, ComptimeInfo } from '../../node';\n    import { ExprNode }                 from '../../level-2/ExprNode';\n    import { TypeNode }                 from '../../level-2/TypeNode';\n    import { IdentNode }                from '../../level-4/CommonNodes/IdentNode';\n    import { FieldNode }                from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class LetStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Let' as const;\n            public level = 3;\n\n            constructor(\n                public span             : Span,\n                public field            : FieldNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return this.field.getChildrenNodes();\n            }\n\n            clone(newSpan?: Span): LetStmtNode {\n                return new LetStmtNode(\n                    newSpan ?? this.span,\n                    this.field.clone(newSpan),\n                );\n            }\n\n            // for factory\n            getField(): FieldNode {\n                return this.field;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, visibility: VisibilityInfo, comptime: ComptimeInfo, mutability: MutabilityInfo, ident: IdentNode, type?: TypeNode, initializer?: ExprNode): LetStmtNode {\n                const field = FieldNode.create(span, visibility, comptime, mutability, ident, type, initializer);\n                return new LetStmtNode(span, field);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// FuncStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, VisibilityInfo, ComptimeInfo } from '../../node';\n    import { TypeNode }                 from '../../level-2/TypeNode';\n    import { FieldNode }                from '../../level-5/common/FieldNode';\n    import { IdentNode }                from '../../level-4/CommonNodes/IdentNode';\n    import { StmtNode }                 from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class FuncStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Function' as const;\n            public level = 3;\n\n            constructor(\n                public span             : Span,\n                public visibility       : VisibilityInfo,\n                public comptime         : ComptimeInfo,\n                public isInline         : boolean,\n                public ident            : IdentNode,\n                public parameters       : FieldNode[],\n                public body             : StmtNode,\n                public errorType?       : TypeNode,\n                public returnType?      : TypeNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                // Add parameters\n                for (const param of this.parameters) {\n                    children.push(param);\n                }\n\n                if (this.errorType) {children.push(this.errorType);}\n                if (this.returnType) {children.push(this.returnType);}\n                if (this.body) {children.push(this.body);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): FuncStmtNode {\n                return new FuncStmtNode(\n                    newSpan ?? this.span,\n                    this.visibility,\n                    this.comptime,\n                    this.isInline,\n                    this.ident,\n                    this.parameters,\n                    this.body,\n                    this.errorType,\n                    this.returnType,\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, visibility: VisibilityInfo, comptime: ComptimeInfo, isInline: boolean, ident: IdentNode, parameters: FieldNode[], body: StmtNode, errorType?: TypeNode, returnType?: TypeNode): FuncStmtNode {\n                return new FuncStmtNode(span, visibility, comptime, isInline, ident, parameters, body, errorType, returnType);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// UseStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, VisibilityInfo } from '../../node';\n    import { IdentNode } from '../../level-4/CommonNodes/IdentNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class UseStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Use' as const;\n            public level = 3;\n\n            constructor(\n                public span             : Span,\n                public visibility       : VisibilityInfo,\n                public targetArr        : IdentNode[] | undefined,\n                public alias?           : IdentNode,\n                public path?            : string,\n                public pathSpan?        : Span,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return []; // No child nodes for UseNode\n            }\n\n            clone(newSpan?: Span): UseStmtNode {\n                return new UseStmtNode(\n                    newSpan ?? this.span,\n                    this.visibility,\n                    this.targetArr,\n                    this.alias,\n                    this.path,\n                    this.pathSpan\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, visibility: VisibilityInfo, targetArr: IdentNode[] | undefined, alias?: IdentNode, path?: string, pathSpan?: Span): UseStmtNode {\n                return new UseStmtNode(span, visibility, targetArr, alias, path, pathSpan);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            isAllModule(): boolean {\n                return this.targetArr === undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// DefStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, VisibilityInfo } from '../../node';\n    import { TypeNode }         from '../../level-2/TypeNode';\n    import { IdentNode }        from '../../level-4/CommonNodes/IdentNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class DefStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Def' as const;\n            public level = 3;\n\n            constructor(\n                public span             : Span,\n                public visibility       : VisibilityInfo,\n                public ident            : IdentNode,\n                public type             : TypeNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.type];\n            }\n\n            clone(newSpan?: Span): DefStmtNode {\n                return new DefStmtNode(\n                    newSpan ?? this.span,\n                    this.visibility,\n                    this.ident,\n                    this.type\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, visibility: VisibilityInfo, ident: IdentNode, type: TypeNode): DefStmtNode {\n                return new DefStmtNode(span, visibility, ident, type);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// LoopStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { StmtNode }     from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type LoopKind = 'For' | 'While' | 'Do';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class LoopStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public span : Span,\n                public kind : LoopKind,\n                public expr : ExprNode,\n                public stmt : StmtNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.expr, this.stmt];\n            }\n\n            clone(newSpan?: Span): LoopStmtNode {\n                return new LoopStmtNode(\n                    newSpan ?? this.span,\n                    this.kind,\n                    this.expr,\n                    this.stmt\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── IS_X ──────────────────────────────┐\n\n            isFor(): boolean {\n                return this.kind === 'For';\n            }\n\n            isWhile(): boolean {\n                return this.kind === 'While';\n            }\n\n            isDo(): boolean {\n                return this.kind === 'While';\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static createFor(span: Span, expr: ExprNode, stmt: StmtNode): LoopStmtNode {\n                return new LoopStmtNode(span, 'For', expr, stmt);\n            }\n\n            static createWhile(span: Span, expr: ExprNode, stmt: StmtNode): LoopStmtNode {\n                return new LoopStmtNode(span, 'While', expr, stmt);\n            }\n\n            static createDo(span: Span, expr: ExprNode, stmt: StmtNode): LoopStmtNode {\n                return new LoopStmtNode(span, 'Do', expr, stmt);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ControlFlowStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type ControlFlowKind = 'return' | 'break' | 'continue' | 'defer' | 'throw';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ControlFlowStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public kind         : ControlFlowKind,\n                public value?       : ExprNode, // Only for Return\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return this.value ? [this.value] : [];\n            }\n\n            clone(newSpan?: Span): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(\n                    newSpan ?? this.span,\n                    this.kind,\n                    this.value\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── IS_X ──────────────────────────────┐\n\n            isReturn(): boolean {\n                return this.kind === 'return';\n            }\n\n            isDefer(): boolean {\n                return this.kind === 'defer';\n            }\n\n            isThrow(): boolean {\n                return this.kind === 'throw';\n            }\n\n            isBreak(): boolean {\n                return this.kind === 'break';\n            }\n\n            isContinue(): boolean {\n                return this.kind === 'continue';\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static asReturn(span: Span, value?: ExprNode): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(span, 'return', value);\n            }\n\n            static asDefer(span: Span, value?: ExprNode): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(span, 'defer', value);\n            }\n\n            static asThrow(span: Span, value?: ExprNode): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(span, 'throw', value);\n            }\n\n            static asBreak(span: Span): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(span, 'break');\n            }\n\n            static asContinue(span: Span): ControlFlowStmtNode {\n                return new ControlFlowStmtNode(span, 'continue');\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// TestStmtNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, NameInfo } from '../../node';\n    import { BlockStmtNode }        from './BlockStmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class TestStmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Test' as const;\n            public level = 3;\n\n            constructor(\n                public span             : Span,\n                public name             : NameInfo | undefined,\n                public block            : BlockStmtNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.block];\n            }\n\n            clone(newSpan?: Span): TestStmtNode {\n                return new TestStmtNode(\n                    newSpan ?? this.span,\n                    this.name,\n                    this.block\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, name: NameInfo | undefined, block: BlockStmtNode): TestStmtNode {\n                return new TestStmtNode(span, name, block);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, MutabilityInfo, VisibilityInfo, ComptimeInfo, NameInfo }\n                                        from '../node';\n    import { ExprNode }                 from '../level-2/ExprNode';\n    import { BlockStmtNode }            from '../level-3/StmtNodes/BlockStmtNode';\n    import { LetStmtNode }              from '../level-3/StmtNodes/LetStmtNode';\n    import { FuncStmtNode }             from '../level-3/StmtNodes/FuncStmtNode';\n    import { UseStmtNode }              from '../level-3/StmtNodes/UseStmtNode';\n    import { DefStmtNode }              from '../level-3/StmtNodes/DefStmtNode';\n    import { LoopStmtNode }             from '../level-3/StmtNodes/LoopStmtNode';\n    import { ControlFlowStmtNode }      from '../level-3/StmtNodes/ControlFlowStmtNode';\n    import { TypeNode }                 from '../level-2/TypeNode';\n    import { FieldNode }                from '../level-5/common/FieldNode';\n    import { IdentNode }                from '../level-4/CommonNodes/IdentNode';\n    import { TestStmtNode }             from '../level-3/StmtNodes/TestStmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type StmtKind =\n    | 'Unset'       | 'Expression'  | 'Block'       | 'Use'         | 'Def'\n    | 'Let'         | 'Func'        | 'For'         | 'While'       | 'Return'\n    | 'Break'       | 'Continue'    | 'Defer'       | 'Throw'       | 'Do'\n    | 'Test';\n\n    export type StmtTypes =\n    | ExprNode      | BlockStmtNode | TestStmtNode  | LetStmtNode   | FuncStmtNode\n    | UseStmtNode   | DefStmtNode   | LoopStmtNode  | ControlFlowStmtNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class StmtNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 1;\n\n            constructor(\n                public kind         : StmtKind,\n                public span         : Span,\n                public source       : StmtTypes,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                if (this.is('Block')) {\n                    children.push(...this.getBlock()!.getChildrenNodes());\n                } else if (this.source instanceof Node) {\n                    children.push(this.source);\n                }\n\n                return children;\n            }\n\n            clone(newSpan?: Span): StmtNode {\n                return new StmtNode(this.kind, newSpan ?? this.span, this.source);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            getExpr(): ExprNode | undefined {\n                if (this.is('Expression')) {\n                    return this.source as ExprNode;\n                }\n                return undefined;\n            }\n\n            getBlock(): BlockStmtNode | undefined {\n                if (this.is('Block')) {\n                    return this.source as BlockStmtNode;\n                }\n                return undefined;\n            }\n\n            getTest(): TestStmtNode | undefined {\n                if (this.is('Test')) {\n                    return this.source as TestStmtNode;\n                }\n                return undefined;\n            }\n\n            getUse(): UseStmtNode | undefined {\n                if (this.is('Use')) {\n                    return this.source as UseStmtNode;\n                }\n                return undefined;\n            }\n\n            getDef(): DefStmtNode | undefined {\n                if (this.is('Def')) {\n                    return this.source as DefStmtNode;\n                }\n                return undefined;\n            }\n\n            getLet(): LetStmtNode | undefined {\n                if (this.is('Let')) {\n                    return this.source as LetStmtNode;\n                }\n                return undefined;\n            }\n\n            getFunc(): FuncStmtNode | undefined {\n                if (this.is('Func')) {\n                    return this.source as FuncStmtNode;\n                }\n                return undefined;\n            }\n\n            getLoop(): LoopStmtNode | undefined {\n                if (this.is('For') || this.is('While') || this.is('Do')) {\n                    return this.source as LoopStmtNode;\n                }\n                return undefined;\n            }\n\n            getFor(): LoopStmtNode | undefined {\n                if (this.is('For')) {\n                    return this.source as LoopStmtNode;\n                }\n                return undefined;\n            }\n\n            getWhile(): LoopStmtNode | undefined {\n                if (this.is('While')) {\n                    return this.source as LoopStmtNode;\n                }\n                return undefined;\n            }\n\n\n            getDo(): LoopStmtNode | undefined {\n                if (this.is('Do')) {\n                    return this.source as LoopStmtNode;\n                }\n                return undefined;\n            }\n\n            getCtrlflow(): ControlFlowStmtNode | undefined {\n                if (this.is('Return') || this.is('Defer') || this.is('Throw') || this.is('Break') || this.is('Continue')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getReturn(): ControlFlowStmtNode | undefined {\n                if (this.is('Return')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getDefer(): ControlFlowStmtNode | undefined {\n                if (this.is('Defer')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getThrow(): ControlFlowStmtNode | undefined {\n                if (this.is('Throw')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getBreak(): ControlFlowStmtNode | undefined {\n                if (this.is('Break')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getContinue(): ControlFlowStmtNode | undefined {\n                if (this.is('Continue')) {\n                    return this.source as ControlFlowStmtNode;\n                }\n                return undefined;\n            }\n\n            getStmtName(): string | undefined {\n                if (this.is('Use')) {\n                    return (this.source as UseStmtNode).alias?.name ?? (this.source as UseStmtNode).path ?? 'unknown-use';\n                } else if (this.is('Def')) {\n                    return (this.source as DefStmtNode).ident.name;\n                } else if (this.is('Let')) {\n                    return (this.source as LetStmtNode).field.ident.name;\n                } else if (this.is('Func')) {\n                    return (this.source as FuncStmtNode).ident.name;\n                }\n                return undefined;\n            }\n\n            getStmtNameSpan(): Span | undefined {\n                if (this.is('Use')) {\n                    return (this.source as UseStmtNode).span;\n                } else if (this.is('Def')) {\n                    return (this.source as DefStmtNode).ident.span;\n                } else if (this.is('Let')) {\n                    return (this.source as LetStmtNode).field.ident.span;\n                } else if (this.is('Func')) {\n                    return (this.source as FuncStmtNode).ident.span;\n                }\n                return undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: StmtKind, span: Span, data: StmtTypes): StmtNode {\n                return new StmtNode(kind, span, data);\n            }\n\n            static asExpr(span: Span, expr: ExprNode): StmtNode {\n                return StmtNode.create('Expression', span, expr);\n            }\n\n            static asBlock(span: Span, stmts: StmtNode[]): StmtNode {\n                return StmtNode.create('Block', span, BlockStmtNode.create(span, stmts));\n            }\n\n            static asUse(span: Span, visibility: VisibilityInfo, targetArr: IdentNode[] | undefined, alias?: IdentNode, path?: string, pathSpan?: Span): StmtNode {\n                return StmtNode.create('Use', span, UseStmtNode.create(span, visibility, targetArr, alias, path, pathSpan));\n            }\n\n            static asDefine(span: Span, visibility: VisibilityInfo, ident: IdentNode, type: TypeNode): StmtNode {\n                return StmtNode.create('Def', span, DefStmtNode.create(span, visibility, ident, type));\n            }\n\n            static asLet(span: Span, visibility: VisibilityInfo, comptime: ComptimeInfo, mutability: MutabilityInfo, ident: IdentNode, type?: TypeNode, initializer?: ExprNode): StmtNode {\n                return StmtNode.create('Let', span, LetStmtNode.create(span, visibility, comptime, mutability, ident, type, initializer));\n            }\n\n            static asFunc(span: Span, visibility: VisibilityInfo, comptime: ComptimeInfo, isInline: boolean, ident: IdentNode, parameters: FieldNode[], errorType: TypeNode | undefined, returnType: TypeNode | undefined, body: StmtNode): StmtNode {\n                return StmtNode.create('Func', span, FuncStmtNode.create(span, visibility, comptime, isInline, ident, parameters, body, errorType, returnType));\n            }\n\n            static asFor(span: Span, expr: ExprNode, stmt: StmtNode): StmtNode {\n                return StmtNode.create('For', span, LoopStmtNode.createFor(span, expr, stmt));\n            }\n\n            static asWhile(span: Span, expr: ExprNode, stmt: StmtNode): StmtNode {\n                return StmtNode.create('While', span, LoopStmtNode.createWhile(span, expr, stmt));\n            }\n\n            static asDo(span: Span, expr: ExprNode, stmt: StmtNode): StmtNode {\n                return StmtNode.create('Do', span, LoopStmtNode.createDo(span, expr, stmt));\n            }\n\n            static asReturn(span: Span, value?: ExprNode): StmtNode {\n                return StmtNode.create('Return', span, ControlFlowStmtNode.asReturn(span, value));\n            }\n\n            static asDefer(span: Span, value?: ExprNode): StmtNode {\n                return StmtNode.create('Defer', span, ControlFlowStmtNode.asDefer(span, value));\n            }\n\n            static asThrow(span: Span, value?: ExprNode): StmtNode {\n                return StmtNode.create('Throw', span, ControlFlowStmtNode.asThrow(span, value));\n            }\n\n            static asBreak(span: Span): StmtNode {\n                return StmtNode.create('Break', span, ControlFlowStmtNode.asBreak(span));\n            }\n\n            static asContinue(span: Span): StmtNode {\n                return StmtNode.create('Continue', span, ControlFlowStmtNode.asContinue(span));\n            }\n\n            static asTest(span: Span, nameInfo: NameInfo | undefined, block: BlockStmtNode): StmtNode {\n                return StmtNode.create('Test', span, TestStmtNode.create(span, nameInfo, block));\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── IS_X ──────────────────────────────┐\n\n            is(kind: StmtKind): boolean {\n                return this.kind === kind;\n            }\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type LiteralKind =\n    | 'Unset'         | 'Array'           | 'String'        | 'Character'\n    | 'Integer'       | 'Float'           | 'Bool'          | 'Null'\n    | 'Undefined';\n\n    export type LiteralValue =\n    | number          | string            | boolean       | null\n    | undefined       | ExprNode[];\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class LiteralNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 4;\n\n            constructor(\n                public kind         : LiteralKind,\n                public span         : Span,\n                public value        : LiteralValue,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n                if (this.kind === 'Array' && Array.isArray(this.value)) {\n                    children.push(...(this.value as ExprNode[]));\n                }\n                return children;\n            }\n\n            clone(newSpan?: Span): LiteralNode {\n                const cloned = new LiteralNode(this.kind, newSpan ?? this.span, this.value);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HHLP ──────────────────────────────┐\n\n            is(kind: LiteralKind): boolean {\n                return this.kind === kind;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: LiteralKind, span: Span, value: LiteralValue): LiteralNode {\n                return new LiteralNode(kind, span, value);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { PropNode } from '../../level-5/ExprNodes/PropNode';\nimport { IdentNode } from '../CommonNodes/IdentNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ObjectNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Object' as const;\n            public level = 4;\n\n            constructor(\n                public span         : Span,\n                public props        : PropNode[],\n                public ident        : IdentNode | undefined\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.props);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ObjectNode {\n                const cloned = new ObjectNode(newSpan || this.span, this.props, this.ident);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, props: PropNode[], ident: IdentNode | undefined): ObjectNode {\n                return new ObjectNode(span, props, ident);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ParenNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Paren' as const;\n            public level = 4;\n\n            constructor(\n                public span         : Span,\n                public source       : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.source);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ParenNode {\n                const cloned = new ParenNode(newSpan || this.span, this.source);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, source: ExprNode): ParenNode {\n                return new ParenNode(span, source);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, DEF_SPAN }     from '../../node';\n    import { IdentNode }                from '../../level-4/CommonNodes/IdentNode';\n    import { LiteralNode }              from '../../level-4/ExprNodes/LiteralNode';\n    import { ObjectNode }               from '../../level-4/ExprNodes/ObjectNode';\n    import { ParenNode }                from '../../level-4/ExprNodes/ParenNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export type PrimitiveKind =\n        | 'type'        | 'void'            | 'bool'        | 'signed'\n        | 'unsigned'    | 'float'           | 'und'         | 'null'\n        | 'cint'        | 'cflt'            | 'any'         | 'err';\n\n    export type PrimitiveTypes = IdentNode | LiteralNode | ParenNode | ObjectNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PrimitiveTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public kind         : PrimitiveKind,\n                public span         : Span,\n                public text         ?: string,\n                public width        ?: number,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [];\n            }\n\n            clone(newSpan?: Span): PrimitiveTypeNode {\n                const cloned = new PrimitiveTypeNode(this.kind, newSpan || this.span, this.text, this.width);\n                return cloned;\n            }\n\n            toString(): string {\n                switch(this.kind) {\n                    case 'void':            return 'void';\n                    case 'type':            return 'type';\n                    case 'bool':            return 'bool';\n                    case 'signed':          return 'i'+this.width;\n                    case 'unsigned':        return 'u'+this.width;\n                    case 'float':           return 'f'+this.width;\n                    case 'und':             return 'undefined';\n                    case 'null':            return 'null';\n                    case 'cint':            return 'cint';\n                    case 'cflt':            return 'cflt';\n                    case 'any':             return 'any';\n                    case 'err':             return 'err';\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: PrimitiveKind): boolean {\n                return this.kind === kind;\n            }\n\n            isVoid()          { return this.is('void'); }\n            isType()          { return this.is('type'); }\n            isNull()          { return this.is('null'); }\n            isUndefined()     { return this.is('und'); }\n            isBool()          { return this.is('bool'); }\n            isSigned()        { return this.is('signed'); }\n            isUnsigned()      { return this.is('unsigned'); }\n            isFloat()         { return this.is('float'); }\n            isInteger()       { return this.is('signed') || this.is('unsigned') || this.is('cint'); }\n            isComptimeInt()   { return this.is('cint'); }\n            isComptimeFloat() { return this.is('cflt'); }\n            isNumeric()       { return this.is('signed') || this.is('unsigned') || this.is('float') || this.is('cint') || this.is('cflt'); }\n            isAny()           { return this.is('any'); }\n            isErr()           { return this.is('err'); }\n\n            static calcWidth(prefix: string, text: string): number {\n                // Check if text starts with the prefix\n                if (!text.startsWith(prefix)) {return 0;}\n\n                // Extract the numeric part after the prefix\n                const numericPart = text.slice(prefix.length);\n\n                // Convert to number\n                const width = parseInt(numericPart, 10);\n\n                // Check if the conversion was successful\n                if (isNaN(width)) {return 0;}\n\n                return width;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: PrimitiveKind, span: Span, text?: string, width?: number): PrimitiveTypeNode {\n                return new PrimitiveTypeNode(kind, span, text, width);\n            }\n\n            static asVoid(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('void', span || DEF_SPAN);\n            }\n\n            static asType(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('type', span || DEF_SPAN);\n            }\n\n            static asNull(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('null', span || DEF_SPAN);\n            }\n\n            static asUndefined(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('und', span || DEF_SPAN);\n            }\n\n            static asAny(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('any', span || DEF_SPAN);\n            }\n\n            static asErr(span?: Span, text?: string): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('err', span || DEF_SPAN, text);\n            }\n\n            static asBool(span?: Span): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('bool', span || DEF_SPAN);\n            }\n\n            static asSigned(span?: Span, text?: string, width?: number): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('signed', span || DEF_SPAN, text, width);\n            }\n\n            static asUnsigned(span?: Span, text?: string, width?: number): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('unsigned', span || DEF_SPAN, text, width);\n            }\n\n            static asFloat(span?: Span, text?: string, width?: number): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('float', span || DEF_SPAN, text, width);\n            }\n\n            static asComptimeInt(span?: Span, text?: string): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('cint', span || DEF_SPAN, text, 64);\n            }\n\n            static asComptimeFloat(span?: Span, text?: string): PrimitiveTypeNode {\n                return PrimitiveTypeNode.create('cflt', span || DEF_SPAN, text, 64);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class OptionalTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Optional' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public target       : TypeNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.target];\n            }\n\n            clone(newSpan?: Span): OptionalTypeNode {\n                const cloned = new OptionalTypeNode(newSpan || this.span, this.target);\n                return cloned;\n            }\n\n            toString(): string {\n                return `?${this.target.toString()}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, target: TypeNode): OptionalTypeNode {\n                return new OptionalTypeNode(span, target);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PointerTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Pointer' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public target       : TypeNode,\n                public mutable      : boolean\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.target];\n            }\n\n            clone(newSpan?: Span): PointerTypeNode {\n                const cloned = new PointerTypeNode(newSpan || this.span, this.target, this.mutable);\n                return cloned;\n            }\n\n            toString(): string {\n                return `*${this.mutable ? 'mut ' : ''}${this.target.toString()}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, target: TypeNode, mutable = false): PointerTypeNode {\n                return new PointerTypeNode(span, target, mutable);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n    import { ExprNode }     from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ArrayTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Array' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public target       : TypeNode,\n                public size         : ExprNode | undefined,\n                public mutable      : boolean\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.target);\n                if (this.size) {children.push(this.size);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ArrayTypeNode {\n                const cloned = new ArrayTypeNode(newSpan || this.span, this.target, this.size, this.mutable);\n                return cloned;\n            }\n\n            toString(): string {\n                return `[]${this.target.toString()}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            isU8Array(): boolean {\n                return (this.target.getPrimitive() && this.target.getPrimitive()!.kind === 'unsigned' && this.target.getPrimitive()!.width === 8) ?? false;\n            }\n\n            isU16Array(): boolean {\n                return (this.target.getPrimitive() && this.target.getPrimitive()!.kind === 'unsigned' && this.target.getPrimitive()!.width === 16) ?? false;\n            }\n\n            isU32Array(): boolean {\n                return (this.target.getPrimitive() && this.target.getPrimitive()!.kind === 'unsigned' && this.target.getPrimitive()!.width === 32) ?? false;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, target: TypeNode, size?: ExprNode, mutable = false): ArrayTypeNode {\n                return new ArrayTypeNode(span, target, size, mutable);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class TupleTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Tuple' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public fields       : TypeNode[],\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [...this.fields];\n            }\n\n            clone(newSpan?: Span): TupleTypeNode {\n                const cloned = new TupleTypeNode(newSpan || this.span, this.fields);\n                return cloned;\n            }\n\n            toString(): string {\n                return `(${this.fields.join(', ')})`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, fields: TypeNode[]): TupleTypeNode {\n                return new TupleTypeNode(span, fields);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class FunctionTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Function' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public params       : TypeNode[],\n                public returnType   : TypeNode | undefined,\n                public errorType    : TypeNode | undefined,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.params);\n                if (this.returnType) {children.push(this.returnType);}\n                if (this.errorType) {children.push(this.errorType);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): FunctionTypeNode {\n                const cloned = new FunctionTypeNode(newSpan || this.span, this.params, this.returnType, this.errorType);\n                return cloned;\n            }\n\n            toString(): string {\n                return `function`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, params: TypeNode[], returnType?: TypeNode, errorType?: TypeNode): FunctionTypeNode {\n                return new FunctionTypeNode(span, params, returnType, errorType);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }       from '../../node';\n    import { StructMemberNode } from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class StructTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Struct' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public members      : StructMemberNode[],\n                public name         : string = 'Anonymous',\n                public metadata     : Record<string, unknown>,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.members);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): StructTypeNode {\n                const cloned = new StructTypeNode(newSpan || this.span, this.members, this.name, this.metadata);\n                return cloned;\n            }\n\n            toString(): string {\n                return `struct`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, members: StructMemberNode[], name: string = 'Anonymous', metadata: Record<string, unknown> = {}): StructTypeNode {\n                return new StructTypeNode(span, members, name, metadata);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }       from '../../node';\n    import { EnumVariantNode } from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class EnumTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Enum' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public variants     : EnumVariantNode[],\n                public name         : string = 'Anonymous',\n                public metadata     : Record<string, unknown>,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.variants);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): EnumTypeNode {\n                const cloned = new EnumTypeNode(newSpan || this.span, this.variants, this.name, this.metadata);\n                return cloned;\n            }\n\n            toString(): string {\n                return `enum`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, variants: EnumVariantNode[], name: string = 'Anonymous', metadata: Record<string, unknown> = {}): EnumTypeNode {\n                return new EnumTypeNode(span, variants, name, metadata);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class UnionTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Union' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public types        : TypeNode[],\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.types);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): UnionTypeNode {\n                const cloned = new UnionTypeNode(newSpan || this.span, this.types);\n                return cloned;\n            }\n\n            toString(): string {\n                return `union`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, types: TypeNode[]): UnionTypeNode {\n                return new UnionTypeNode(span, types);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { IdentNode }        from '../../../ast';\n    import { Span, Node }       from '../../node';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ErrsetTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'errset' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public members      : IdentNode[],\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.members);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ErrsetTypeNode {\n                const cloned = new ErrsetTypeNode(newSpan || this.span, this.members);\n                return cloned;\n            }\n\n            toString(): string {\n                return `error`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, members: IdentNode[]): ErrsetTypeNode {\n                return new ErrsetTypeNode(span, members);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ParenTypeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Paren' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public type         : TypeNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.type];\n            }\n\n            clone(newSpan?: Span): ParenTypeNode {\n                const cloned = new ParenTypeNode(newSpan || this.span, this.type);\n                return cloned;\n            }\n\n            toString(): string {\n                return `paren`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, type: TypeNode): ParenTypeNode {\n                return new ParenTypeNode(span, type);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { DEF_SPAN, Node, Span }                     from '../node';\n    import { ExprNode }                                 from './ExprNode';\n\n    import { PrimitiveKind, PrimitiveTypeNode }         from '../level-3/TypeNodes/PrimitiveTypeNode';\n    import { OptionalTypeNode }                         from '../level-3/TypeNodes/OptionalTypeNode';\n    import { PointerTypeNode }                          from '../level-3/TypeNodes/PointerTypeNode';\n    import { ArrayTypeNode }                            from '../level-3/TypeNodes/ArrayTypeNode';\n    import { TupleTypeNode }                            from '../level-3/TypeNodes/TupleTypeNode';\n    import { FunctionTypeNode }                         from '../level-3/TypeNodes/FunctionTypeNode';\n    import { StructTypeNode }                           from '../level-3/TypeNodes/StructTypeNode';\n    import { EnumTypeNode }                             from '../level-3/TypeNodes/EnumTypeNode';\n    import { UnionTypeNode }                            from '../level-3/TypeNodes/UnionTypeNode';\n\n    import { IdentNode }                                from '../level-4/CommonNodes/IdentNode';\n\n    import { StructMemberNode }                         from '../level-5/ExprNodes/StructMemberNode';\n    import { EnumVariantNode }                          from '../level-5/ExprNodes/EnumVariantNode';\n    import { ErrsetTypeNode }                           from '../level-3/TypeNodes/ErrsetTypeNode';\nimport { ParenTypeNode } from '../level-3/TypeNodes/ParenTypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type TypeKind =\n        | 'unset'       | 'primitive'   | 'ident'       | 'pointer'\n        | 'array'       | 'tuple'       | 'function'    | 'optional'\n        | 'struct'      | 'enum'        | 'union'       | 'errset'\n        | 'paren';\n\n    export type UnsetSource = null;\n\n    export type TypeTypes =\n    | UnsetSource           | PrimitiveTypeNode | IdentNode         | OptionalTypeNode\n    | PointerTypeNode       | ArrayTypeNode     | TupleTypeNode     | FunctionTypeNode\n    | StructTypeNode        | EnumTypeNode      | UnionTypeNode     | ErrsetTypeNode\n    | ParenTypeNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class TypeNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 2;\n\n            constructor(\n                public span         : Span,\n                public kind         : TypeKind,\n                public source       : TypeTypes,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            getChildrenNodes(): Node[] {\n                return this.source ? this.source.getChildrenNodes() : []; }\n\n            clone(newSpan?: Span): TypeNode {\n                return new TypeNode(newSpan ?? this.span, this.kind, this.source); }\n\n            toString(): string {\n                return this.source?.toString() || `Type(${this.kind})`; }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: TypeKind)  { return this.kind === kind; }\n            isPrimitive()       { return this.is('primitive'); }\n            isVoid()            { return this.isPrimitive() && this.getPrimitive()!.isVoid(); }\n            isType()            { return this.isPrimitive() && this.getPrimitive()!.isType(); }\n            isNull()            { return this.isPrimitive() && this.getPrimitive()!.isNull(); }\n            isUndefined()       { return this.isPrimitive() && this.getPrimitive()!.isUndefined(); }\n            isAny()             { return this.isPrimitive() && this.getPrimitive()!.isAny(); }\n            isErr()             { return this.isPrimitive() && this.getPrimitive()!.isErr(); }\n            isSigned()          { return this.isPrimitive() && this.getPrimitive()!.isSigned(); }\n            isUnsigned()        { return this.isPrimitive() && this.getPrimitive()!.isUnsigned(); }\n            isComptimeInt()     { return this.isPrimitive() && this.getPrimitive()!.isComptimeInt(); }\n            isInteger()         { return this.isPrimitive() && this.getPrimitive()!.isInteger(); }\n            isComptimeFloat()   { return this.isPrimitive() && this.getPrimitive()!.isComptimeFloat(); }\n            isFloat()           { return this.isPrimitive() && this.getPrimitive()!.isFloat(); }\n            isNumeric()         { return this.isPrimitive() && this.getPrimitive()!.isNumeric(); }\n            isBool()            { return this.isPrimitive() && this.getPrimitive()!.isBool(); }\n            isIdent()           { return this.is('ident'); }\n\n            isPointer()         { return this.kind === 'pointer'; }\n            isOptional()        { return this.kind === 'optional'; }\n            isArray()           { return this.kind === 'array'; }\n            isU8Array()         { return this.isArray() && this.getArray()!.isU8Array(); }\n            isU16Array()        { return this.isArray() && this.getArray()!.isU16Array(); }\n            isU32Array()        { return this.isArray() && this.getArray()!.isU32Array(); }\n            isTuple()           { return this.kind === 'tuple'; }\n            isFunction()        { return this.kind === 'function'; }\n            isStruct()          { return this.kind === 'struct'; }\n            isErrset()          { return this.kind === 'errset'; }\n            isEnum()            { return this.kind === 'enum'; }\n            isUnion()           { return this.kind === 'union'; }\n            isParen()           { return this.kind === 'paren'; }\n\n            getPrimitive()      : PrimitiveTypeNode | undefined { return this.is('primitive')   ? this.source as PrimitiveTypeNode  : undefined; }\n            getOptional()       : OptionalTypeNode  | undefined { return this.is('optional')    ? this.source as OptionalTypeNode   : undefined; }\n            getPointer()        : PointerTypeNode   | undefined { return this.is('pointer')     ? this.source as PointerTypeNode    : undefined; }\n            getArray()          : ArrayTypeNode     | undefined { return this.is('array')       ? this.source as ArrayTypeNode      : undefined; }\n            getTuple()          : TupleTypeNode     | undefined { return this.is('tuple')       ? this.source as TupleTypeNode      : undefined; }\n            getFunction()       : FunctionTypeNode  | undefined { return this.is('function')    ? this.source as FunctionTypeNode   : undefined; }\n            getStruct()         : StructTypeNode    | undefined { return this.is('struct')      ? this.source as StructTypeNode     : undefined; }\n            getError()          : ErrsetTypeNode    | undefined { return this.is('errset')      ? this.source as ErrsetTypeNode      : undefined; }\n            getEnum()           : EnumTypeNode      | undefined { return this.is('enum')        ? this.source as EnumTypeNode       : undefined; }\n            getUnion()          : UnionTypeNode     | undefined { return this.is('union')       ? this.source as UnionTypeNode      : undefined; }\n            getParen()          : ParenTypeNode     | undefined { return this.is('paren')       ? this.source as ParenTypeNode      : undefined; }\n            getIdent ()         : IdentNode         | undefined { return this.is('ident')       ? this.source as IdentNode          : undefined; }\n            getWidth()          : number            | undefined { return this.is('primitive')   ? this.getPrimitive()!.width        : undefined; }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static asUnset(span?: Span): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'unset', null);\n            }\n\n            static asPrimitive(span: Span | undefined, kind: PrimitiveKind, text?: string, width?: number): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'primitive', PrimitiveTypeNode.create(kind, span || DEF_SPAN, text, width));\n            }\n\n            static asVoid(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'void');\n            }\n\n            static asBool(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'bool');\n            }\n\n            static asSigned(span: Span | undefined, text: string, width?: number): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'signed', text, width ?? PrimitiveTypeNode.calcWidth('i', text));\n            }\n\n            static asUnsigned(span: Span | undefined, text: string, width?: number): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'unsigned', text, width ?? PrimitiveTypeNode.calcWidth('u', text));\n            }\n\n            static asFloat(span: Span | undefined, text: string, width?: number): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'float', text, width ?? PrimitiveTypeNode.calcWidth('f', text));\n            }\n\n            static asNull(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'null');\n            }\n\n            static asUndefined(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'und');\n            }\n\n            static asAny(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'any');\n            }\n\n            static asErr(span?: Span, text?: string): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'err', text);\n            }\n\n            static asType(span?: Span): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'type');\n            }\n\n            static asComptimeInt(span: Span | undefined, text: string): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'cint', text, 64);\n            }\n\n            static asComptimeFloat(span: Span | undefined, text: string): TypeNode {\n                return TypeNode.asPrimitive(span || DEF_SPAN, 'cflt', text, 64);\n            }\n\n            static asIdentifier(span: Span | undefined, name: string): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'ident', IdentNode.create(span || DEF_SPAN, name));\n            }\n\n            static asPointer(span: Span | undefined, target: TypeNode, mutable= false): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'pointer', PointerTypeNode.create(span || DEF_SPAN, target, mutable));\n            }\n\n            static asOptional(span: Span | undefined, target: TypeNode): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'optional', OptionalTypeNode.create(span || DEF_SPAN, target));\n            }\n\n            static asArray(span: Span | undefined, target: TypeNode, size?: ExprNode, mutable= false): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'array', ArrayTypeNode.create(span || DEF_SPAN, target, size, mutable));\n            }\n\n            static asU8Array(span: Span | undefined, mutable= false): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'array', ArrayTypeNode.create(span || DEF_SPAN, TypeNode.asUnsigned(span, 'u8', 8), undefined, mutable));\n            }\n\n            static asU16Array(span: Span | undefined, mutable= false): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'array', ArrayTypeNode.create(span || DEF_SPAN, TypeNode.asUnsigned(span, 'u16', 16), undefined, mutable));\n            }\n\n            static asU32Array(span: Span | undefined, mutable= false): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'array', ArrayTypeNode.create(span || DEF_SPAN, TypeNode.asUnsigned(span, 'u32', 32), undefined, mutable));\n            }\n\n            static asTuple(span: Span | undefined, fields: TypeNode[]): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'tuple', TupleTypeNode.create(span || DEF_SPAN, fields));\n            }\n\n            static asFunction(span: Span | undefined, params: TypeNode[], returnType?: TypeNode, errorType?: TypeNode): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'function', FunctionTypeNode.create(span || DEF_SPAN, params, returnType, errorType));\n            }\n\n            static asErrset(span: Span | undefined, members: IdentNode[]): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'errset', ErrsetTypeNode.create(span || DEF_SPAN, members));\n            }\n\n            static asStruct(span: Span | undefined, members: StructMemberNode[], name: string = 'Anonymous'): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'struct', StructTypeNode.create(span || DEF_SPAN, members, name));\n            }\n\n            static asEnum(span: Span | undefined, variants: EnumVariantNode[], name: string = 'Anonymous'): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'enum', EnumTypeNode.create(span || DEF_SPAN, variants, name));\n            }\n\n            static asUnion(span: Span | undefined, types: TypeNode[]): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'union', UnionTypeNode.create(span || DEF_SPAN, types));\n            }\n\n            static asParen(span: Span | undefined, type: TypeNode): TypeNode {\n                return new TypeNode(span || DEF_SPAN, 'paren', ParenTypeNode.create(span || DEF_SPAN, type));\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }           from '../../node';\n    import { IdentNode }            from '../../level-4/CommonNodes/IdentNode';\n    import { LiteralNode, LiteralKind, LiteralValue }\n                                    from '../../level-4/ExprNodes/LiteralNode';\n    import { ObjectNode }           from '../../level-4/ExprNodes/ObjectNode';\n    import { PropNode }             from '../../level-5/ExprNodes/PropNode';\n    import { ParenNode }            from '../../level-4/ExprNodes/ParenNode';\n    import { ExprNode }             from '../../level-2/ExprNode';\n    import { ExprTupleNode }        from '../../../ast';\n    import { TypeNode }             from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export type PrimaryKind = 'Literal' | 'Ident' | 'Paren' | 'Object' | 'Tuple' | 'Type';\n    export type PrimaryTypes = IdentNode | LiteralNode | ParenNode | ObjectNode | ExprTupleNode | TypeNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PrimaryNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public kind         : PrimaryKind,\n                public span         : Span,\n                public source       ?: PrimaryTypes,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.source!);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): PrimaryNode {\n                const cloned = new PrimaryNode(this.kind, newSpan || this.span, this.source);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: PrimaryKind): boolean {\n                return this.kind === kind;\n            }\n\n            getLiteral(): LiteralNode {\n                return this.source as LiteralNode;\n            }\n\n            getIdent(): IdentNode {\n                return this.source as IdentNode;\n            }\n\n            getObject(): ObjectNode {\n                return this.source as ObjectNode;\n            }\n\n            getParen(): ParenNode {\n                return this.source as ParenNode;\n            }\n\n            getTuple(): ExprTupleNode {\n                return this.source as ExprTupleNode;\n            }\n\n            getType(): TypeNode {\n                return this.source as TypeNode;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: PrimaryKind, span: Span, source?: PrimaryTypes): PrimaryNode {\n                // Validate\n                if(kind === 'Ident' && !(source instanceof IdentNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n                if(kind === 'Literal' && !(source instanceof LiteralNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n                if(kind === 'Object' && !(source instanceof ObjectNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n                if(kind === 'Paren' && !(source instanceof ParenNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n                if(kind === 'Tuple' && !(source instanceof ExprTupleNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n                if(kind === 'Type' && !(source instanceof TypeNode)) {\n                    throw new Error(`Invalid kind for primary: ${kind}`);\n                }\n\n                // Create\n                return new PrimaryNode(kind, span, source);\n            }\n\n            static asIdent(span:Span, name: string, builtin= false) : PrimaryNode {\n                return this.create('Ident', span, IdentNode.create(span, name, builtin));\n            }\n\n            static asLiteral(kind: LiteralKind, span:Span, value: LiteralValue) : PrimaryNode {\n                return this.create('Literal', span, LiteralNode.create(kind, span, value));\n            }\n\n            static asParen(span:Span, source: ExprNode) : PrimaryNode {\n                return this.create('Paren', span, ParenNode.create(span, source));\n            }\n\n            static asObject(span:Span, props: PropNode[], ident: IdentNode | undefined) : PrimaryNode {\n                return this.create('Object', span, ObjectNode.create(span, props, ident));\n            }\n\n            static asTuple(span:Span, exprs: ExprNode[]) : PrimaryNode {\n                return this.create('Tuple', span, ExprTupleNode.create(span, exprs));\n            }\n\n            static asType(span:Span, type: TypeNode) : PrimaryNode {\n                return this.create('Type', span, type);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class MemberAccessNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'MemberAccess' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public base         : ExprNode,\n                public target       : ExprNode,\n                public optional     : boolean\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.base);\n                children.push(this.target);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): MemberAccessNode {\n                const cloned = new MemberAccessNode(newSpan || this.span, this.base, this.target, this.optional);\n                return cloned;\n            }\n\n            toString(): string {\n                return `${this.base.toString()}${this.optional ? '?.' : '.'}${this.target.toString()}`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, base: ExprNode, target: ExprNode, optional= false): MemberAccessNode {\n                return new MemberAccessNode(span, base, target, optional);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ArrayAccessNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'ArrayAccess' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public base         : ExprNode,\n                public index        : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.base);\n                children.push(this.index);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ArrayAccessNode {\n                const cloned = new ArrayAccessNode(newSpan || this.span, this.base, this.index);\n                return cloned;\n            }\n\n            toString(): string {\n                return `${this.base.toString()}[${this.index.toString()}]`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, base: ExprNode, index: ExprNode): ArrayAccessNode {\n                return new ArrayAccessNode(span, base, index);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class CallNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Call' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public base         : ExprNode,\n                public args         : ExprNode[],\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.base);\n                children.push(...this.args);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): CallNode {\n                const cloned = new CallNode(newSpan || this.span, this.base, this.args);\n                return cloned;\n            }\n\n            toString(): string {\n                const argsStr = this.args.map(arg => arg.toString()).join(', ');\n                return `${this.base.toString()}(${argsStr})`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, base: ExprNode, args: ExprNode[]): CallNode {\n                return new CallNode(span, base, args);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }           from '../../node';\n    import { ExprNode }             from '../../level-2/ExprNode';\n    import { MemberAccessNode }     from '../../level-5/ExprNodes/MemberAccessNode';\n    import { ArrayAccessNode }      from '../../level-5/ExprNodes/ArrayAccessNode';\n    import { CallNode }             from '../../level-5/ExprNodes/CallNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export type PostfixKind =\n    | 'Increment'    | 'Decrement'       | 'Dereference' | 'MemberAccess'\n    | 'Call'         | 'ArrayAccess';\n\n    export type PostfixTypes = ExprNode | MemberAccessNode | ArrayAccessNode | CallNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PostfixNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public kind         : PostfixKind,\n                public span         : Span,\n                public expr         : PostfixTypes,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.expr);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): PostfixNode {\n                const cloned = new PostfixNode(this.kind, newSpan || this.span, this.expr);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: PostfixKind): boolean {\n                return this.kind === kind;\n            }\n\n            getCall(): CallNode {\n                return this.expr as CallNode;\n            }\n\n            getMemberAccess(): MemberAccessNode {\n                return this.expr as MemberAccessNode;\n            }\n\n            getArrayAccess(): ArrayAccessNode {\n                return this.expr as ArrayAccessNode;\n            }\n\n            getAsExprNode(): ExprNode | undefined {\n                if(this.is('Increment') || this.is('Decrement') || this.is('Dereference')) {\n                    return this.expr as ExprNode;\n                }\n\n                return undefined;\n            }\n\n            toString(): string {\n                switch (this.kind) {\n                    case 'Increment':    return `${this.expr.toString()}++`;\n                    case 'Decrement':    return `${this.expr.toString()}--`;\n                    case 'Dereference':  return `*${this.expr.toString()}`;\n                    case 'MemberAccess': return this.getMemberAccess().toString();\n                    case 'ArrayAccess':  return this.getArrayAccess().toString();\n                    case 'Call':         return this.getCall().toString();\n                    default:             return `${this.expr.toString()}/* unknown postfix */`;\n                }\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: PostfixKind, span: Span, expr: PostfixTypes): PostfixNode {\n                return new PostfixNode(kind, span, expr);\n            }\n\n            static asIncrement(span: Span, base: ExprNode): PostfixNode {\n                return PostfixNode.create('Increment', span, base);\n            }\n\n            static asDecrement(span: Span, base: ExprNode): PostfixNode {\n                return PostfixNode.create('Decrement', span, base);\n            }\n\n            static asDereference(span: Span, base: ExprNode): PostfixNode {\n                return PostfixNode.create('Dereference', span, base);\n            }\n\n            static asMember(span:Span, base: ExprNode, target: ExprNode, optional= false) : PostfixNode {\n                const memberExpr = MemberAccessNode.create(span, base, target, optional);\n                return PostfixNode.create('MemberAccess', span, memberExpr);\n            }\n\n            static asArrayAccess(span: Span, base: ExprNode, index: ExprNode): PostfixNode {\n                const arrayExpr = ArrayAccessNode.create(span, base, index);\n                const node = PostfixNode.create('ArrayAccess', span, arrayExpr);\n                return node;\n            }\n\n            static asCall(span: Span, base: ExprNode, args: ExprNode[]): PostfixNode {\n                const callExpr = CallNode.create(span, base, args);\n                return PostfixNode.create('Call', span, callExpr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export type PrefixKind =\n    | 'Increment'    | 'Decrement'       | 'Reference'   | 'UnaryMinus'\n    | 'UnaryPlus'    | 'LogicalNot'      | 'BitwiseNot';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PrefixNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public kind         : PrefixKind,\n                public span         : Span,\n                public expr         : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.expr);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): PrefixNode {\n                const cloned = new PrefixNode(this.kind, newSpan || this.span, this.expr);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: PrefixKind): boolean {\n                return this.kind === kind;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(kind: PrefixKind, span: Span, expr: ExprNode): PrefixNode {\n                return new PrefixNode(kind, span, expr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export type BinaryKind =\n    | 'Unset'         | 'Power'           | 'Additive'    | 'Multiplicative'\n    | 'Shift'         | 'Relational'      | 'Equality'    | 'Bitwise'\n    | 'Logical'       | 'BitwiseAnd'      | 'BitwiseOr'   | 'BitwiseXor'\n    | 'LogicalAnd'    | 'LogicalOr'       | 'Conditional' | 'Assignment';\n\n    const op_table: Record<string, BinaryKind> = {\n        '**': 'Power',\n\n        '*' : 'Multiplicative',\n        '/' : 'Multiplicative',\n        '%' : 'Multiplicative',\n\n        '+' : 'Additive',\n        '-' : 'Additive',\n\n        '<<': 'Shift',\n        '>>': 'Shift',\n\n        '<' : 'Relational',\n        '<=': 'Relational',\n        '>' : 'Relational',\n        '>=': 'Relational',\n\n        '==': 'Equality',\n        '!=': 'Equality',\n\n        '&' : 'BitwiseAnd',\n        '^' : 'BitwiseXor',\n        '|' : 'BitwiseOr',\n\n        'and': 'LogicalAnd',\n        'or' : 'LogicalOr',\n\n        '=' : 'Assignment',\n        '+=': 'Assignment',\n        '-=': 'Assignment',\n        '*=': 'Assignment',\n        '/=': 'Assignment',\n        '%=': 'Assignment'\n    };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class BinaryNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n\n            constructor(\n                public kind         : BinaryKind,\n                public span         : Span,\n                public left         : ExprNode,\n                public operator     : string,\n                public right        : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.left);\n                children.push(this.right);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): BinaryNode {\n                const cloned = new BinaryNode(this.kind, newSpan || this.span, this.left, this.operator, this.right);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            is(kind: BinaryKind): boolean {\n                return this.kind === kind;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, left: ExprNode, operator: string, right: ExprNode): BinaryNode {\n                const kind : BinaryNode[\"kind\"] = op_table[operator as keyof typeof op_table];\n                if (!kind) {\n                    throw new Error(`Unknown operator: ${operator}`);\n                }\n                return new BinaryNode(kind, span, left, operator, right);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ConditionalNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Conditional' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public condExpr     : ExprNode,\n                public trueExpr     : ExprNode,\n                public falseExpr    : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.condExpr);\n                children.push(this.trueExpr);\n                children.push(this.falseExpr);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ConditionalNode {\n                const cloned = new ConditionalNode(newSpan || this.span, this.condExpr, this.trueExpr, this.falseExpr);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, condExpr: ExprNode, trueExpr: ExprNode, falseExpr: ExprNode): ConditionalNode {\n                return new ConditionalNode(span, condExpr, trueExpr, falseExpr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n    import { StmtNode }         from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class IfNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'If' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public condExpr     : ExprNode,\n                public thenStmt     : StmtNode,\n                public elseStmt     : StmtNode | null\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.condExpr);\n                children.push(this.thenStmt);\n                if(this.elseStmt) { children.push(this.elseStmt);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): IfNode {\n                const cloned = new IfNode(newSpan || this.span, this.condExpr, this.thenStmt, this.elseStmt);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, condExpr: ExprNode, thenStmt: StmtNode, elseStmt: StmtNode | null): IfNode {\n                return new IfNode(span, condExpr, thenStmt, elseStmt);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { CaseNode }     from '../../level-5/ExprNodes/CaseNode';\n    import { DefaultNode }  from '../../level-5/ExprNodes/DefaultNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class SwitchNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Switch' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public condExpr     : ExprNode,\n                public cases        : CaseNode[],\n                public defCase      : DefaultNode | null\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.condExpr);\n\n                for (const caseItem of this.cases) {\n                    children.push(...caseItem.getChildrenNodes());\n                }\n\n                if (this.defCase) {\n                    children.push(...this.defCase.getChildrenNodes());\n                }\n\n                return children;\n            }\n\n            clone(newSpan?: Span): SwitchNode {\n                const cloned = new SwitchNode(newSpan || this.span, this.condExpr, this.cases, this.defCase);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, condExpr: ExprNode, cases: CaseNode[], defCase: DefaultNode | null): SwitchNode {\n                return new SwitchNode(span, condExpr, cases, defCase);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { StmtNode }         from '../../level-1/StmtNode';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class CatchNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Catch' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public leftExpr     : ExprNode,\n                public tag          : ExprNode | null,\n                public rightStmt    : StmtNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.leftExpr);\n                if(this.tag) { children.push(this.tag);}\n                children.push(this.rightStmt);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): CatchNode {\n                const cloned = new CatchNode(newSpan || this.span, this.leftExpr, this.tag, this.rightStmt);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, leftExpr: ExprNode, tag: ExprNode | null, rightStmt: StmtNode): CatchNode {\n                return new CatchNode(span, leftExpr, tag, rightStmt);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class TryNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Try' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public expr         : ExprNode,\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.expr);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): TryNode {\n                const cloned = new TryNode(newSpan || this.span, this.expr);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, leftExpr: ExprNode): TryNode {\n                return new TryNode(span, leftExpr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }         from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class RangeNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Range' as const;\n            public level = 3;\n\n            constructor(\n                public span         : Span,\n                public leftExpr     : ExprNode | null,\n                public rangeType    : string,\n                public rightExpr    : ExprNode | null\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                if(this.leftExpr) { children.push(this.leftExpr);}\n                if(this.rightExpr) { children.push(this.rightExpr);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): RangeNode {\n                const cloned = new RangeNode(newSpan || this.span, this.leftExpr, this.rangeType, this.rightExpr);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, leftExpr: ExprNode | null, rangeType: string, elseStmt: ExprNode | null): RangeNode {\n                return new RangeNode(span, leftExpr, rangeType, elseStmt);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// OrelseNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class OrelseNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n            public kind = 'Orelse';\n\n            constructor(\n                public span         : Span,\n                public left         : ExprNode,\n                public right        : ExprNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.left, this.right];\n            }\n\n            clone(newSpan?: Span): OrelseNode {\n                return new OrelseNode(\n                    newSpan ?? this.span,\n                    this.left,\n                    this.right\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, left: ExprNode, right: ExprNode): OrelseNode {\n                return new OrelseNode(span, left, right);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// AsNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class AsNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n            public kind = 'As';\n\n            constructor(\n                public span         : Span,\n                public base         : ExprNode,\n                public type         : TypeNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.base, this.type];\n            }\n\n            clone(newSpan?: Span): AsNode {\n                return new AsNode(\n                    newSpan ?? this.span,\n                    this.base,\n                    this.type\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, left: ExprNode, type: TypeNode): AsNode {\n                return new AsNode(span, left, type);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { IdentNode }    from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class PropNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Prop' as const;\n            public level = 5;\n\n            constructor(\n                public span        : Span,\n                public key         : IdentNode,\n                public val         : ExprNode | undefined,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                if (this.key) {children.push(this.key);}\n                if (this.val) {children.push(this.val);}\n\n                return children;\n            }\n\n            clone(newSpan?: Span): PropNode {\n                const cloned = new PropNode(newSpan ?? this.span, this.key, this.val);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, key: IdentNode, val: ExprNode): PropNode {\n                return new PropNode(span, key, val);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { StmtNode }         from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class CaseNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Case' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public expr         : ExprNode,\n                public stmt         : StmtNode | null,\n                public hasBreak     : boolean | undefined\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.expr);\n\n                if(this.stmt) { children.push(this.stmt); }\n\n                return children;\n            }\n\n            clone(newSpan?: Span): CaseNode {\n                const cloned = new CaseNode(newSpan || this.span, this.expr, this.stmt, this.hasBreak);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, expr: ExprNode, stmt: StmtNode | null, hasBreak: boolean | undefined = undefined): CaseNode {\n                return new CaseNode(span, expr, stmt, hasBreak);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { StmtNode }         from '../../level-1/StmtNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class DefaultNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Default' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public stmt         : StmtNode,\n                public hasBreak     : boolean | undefined\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(this.stmt);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): DefaultNode {\n                const cloned = new DefaultNode(newSpan || this.span, this.stmt, this.hasBreak);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, stmt: StmtNode, hasBreak: boolean | undefined = undefined): DefaultNode {\n                return new DefaultNode(span, stmt, hasBreak);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// TypeofNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class TypeofNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n            public kind = 'Typeof';\n\n            constructor(\n                public span         : Span,\n                public expr         : ExprNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.expr];\n            }\n\n            clone(newSpan?: Span): TypeofNode {\n                return new TypeofNode(\n                    newSpan ?? this.span,\n                    this.expr\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, expr: ExprNode): TypeofNode {\n                return new TypeofNode(span, expr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// SizeofNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node }   from '../../node';\n    import { ExprNode }     from '../../level-2/ExprNode';\n    import { TypeNode }     from '../../level-2/TypeNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class SizeofNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 3;\n            public kind = 'Sizeof';\n\n            constructor(\n                public span         : Span,\n                public expr         : ExprNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return [this.expr];\n            }\n\n            clone(newSpan?: Span): SizeofNode {\n                return new SizeofNode(\n                    newSpan ?? this.span,\n                    this.expr\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, expr: ExprNode): SizeofNode {\n                return new SizeofNode(span, expr);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, DEF_SPAN }                         from '../node';\n    import { StmtNode }                                     from '../level-1/StmtNode';\n    import { TypeNode }                                     from './TypeNode';\n\n    import { PrimaryNode }                                  from '../level-3/ExprNodes/PrimaryNode';\n    import { PostfixNode }                                  from '../level-3/ExprNodes/PostfixNode';\n    import { PrefixNode }                                   from '../level-3/ExprNodes/PrefixNode';\n    import { BinaryNode }                                   from '../level-3/ExprNodes/BinaryNode';\n    import { ConditionalNode as CondNode }                  from '../level-3/ExprNodes/ConditionalNode';\n    import { IfNode }                                       from '../level-3/ExprNodes/IfNode';\n    import { SwitchNode }                                   from '../level-3/ExprNodes/SwitchNode';\n    import { CatchNode }                                    from '../level-3/ExprNodes/CatchNode';\n    import { TryNode }                                      from '../level-3/ExprNodes/TryNode';\n    import { RangeNode }                                    from '../level-3/ExprNodes/RangeNode';\n    import { OrelseNode }                                   from '../level-3/ExprNodes/OrelseNode';\n    import { AsNode }                                       from '../level-3/ExprNodes/AsNode';\n\n    import { LiteralNode }                                  from '../level-4/ExprNodes/LiteralNode';\n    import { IdentNode }                                    from '../level-4/CommonNodes/IdentNode';\n    import { ParenNode }                                    from '../level-4/ExprNodes/ParenNode';\n    import { ObjectNode }                                   from '../level-4/ExprNodes/ObjectNode';\n    import { ExprTupleNode }                                from '../level-4/ExprNodes/ExprTupleNode';\n\n    import { PropNode }                                     from '../level-5/ExprNodes/PropNode';\n    import { CaseNode }                                     from '../level-5/ExprNodes/CaseNode';\n    import { DefaultNode }                                  from '../level-5/ExprNodes/DefaultNode';\n    import { TypeofNode }                                   from '../level-3/ExprNodes/TypeofNode';\n    import { SizeofNode }                                   from '../level-3/ExprNodes/SizeofNode';\n\n    export { PropNode, CaseNode, DefaultNode };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type ExprKind =\n    | 'Unset'       | 'Primary'     | 'Postfix'     | 'Prefix'\n    | 'Binary'      | 'Cond'        | 'If'          | 'Switch'\n    | 'Catch'       | 'Try'         | 'Range'       | 'Orelse'\n    | 'As'          | 'Typeof'      | 'Sizeof';\n\n    export type ExprTypes =\n    | PrimaryNode   | PostfixNode   | PrefixNode    | BinaryNode\n    | CondNode      | IfNode        | SwitchNode    | CatchNode\n    | TryNode       | RangeNode     | OrelseNode    | AsNode\n    | TypeofNode    | SizeofNode;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ExprNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 2;\n\n            constructor(\n                public kind : ExprKind,\n                public span : Span,\n                public data : ExprTypes,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return this.data.getChildrenNodes();\n            }\n\n            clone(newSpan?: Span): ExprNode {\n                const cloned = new ExprNode(this.kind, newSpan ?? this.span, this.data);\n                return cloned;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            getPrimary()        : PrimaryNode   | undefined     { return this.is('Primary')     ? this.data as PrimaryNode      : undefined; }\n            getPostfix()        : PostfixNode   | undefined     { return this.is('Postfix')     ? this.data as PostfixNode      : undefined; }\n            getPrefix()         : PrefixNode    | undefined     { return this.is('Prefix')      ? this.data as PrefixNode       : undefined; }\n            getBinary()         : BinaryNode    | undefined     { return this.is('Binary')      ? this.data as BinaryNode       : undefined; }\n            getConditional()    : CondNode      | undefined     { return this.is('Cond')        ? this.data as CondNode         : undefined; }\n            getIf()             : IfNode        | undefined     { return this.is('If')          ? this.data as IfNode           : undefined; }\n            getSwitch()         : SwitchNode    | undefined     { return this.is('Switch')      ? this.data as SwitchNode       : undefined; }\n            getCatch()          : CatchNode     | undefined     { return this.is('Catch')       ? this.data as CatchNode        : undefined; }\n            getTry()            : TryNode       | undefined     { return this.is('Try')         ? this.data as TryNode          : undefined; }\n            getRange()          : RangeNode     | undefined     { return this.is('Range')       ? this.data as RangeNode        : undefined; }\n            getOrelse()         : OrelseNode    | undefined     { return this.is('Orelse')      ? this.data as OrelseNode       : undefined; }\n            getAs()             : AsNode        | undefined     { return this.is('As')          ? this.data as AsNode           : undefined; }\n\n            getTypeof()         : TypeofNode    | undefined     { return this.is('Typeof')      ? this.data as TypeofNode      : undefined; }\n            getSizeof()         : SizeofNode    | undefined     { return this.is('Sizeof')      ? this.data as SizeofNode      : undefined; }\n\n            getLiteral()        : LiteralNode   | undefined     { return this.is('Primary') && this.getPrimary()!.is('Literal') ? this.getPrimary()!.getLiteral() : undefined; }\n            getIdent()          : IdentNode     | undefined     { return this.is('Primary') && this.getPrimary()!.is('Ident')   ? this.getPrimary()!.getIdent()   : undefined; }\n            getParen()          : ParenNode     | undefined     { return this.is('Primary') && this.getPrimary()!.is('Paren')   ? this.getPrimary()!.getParen()   : undefined; }\n            getObject()         : ObjectNode    | undefined     { return this.is('Primary') && this.getPrimary()!.is('Object')  ? this.getPrimary()!.getObject()  : undefined; }\n            getTuple()          : ExprTupleNode | undefined     { return this.is('Primary') && this.getPrimary()!.is('Tuple')   ? this.getPrimary()!.getTuple()   : undefined; }\n            getType()           : TypeNode      | undefined     { return this.is('Primary') && this.getPrimary()!.is('Type')    ? this.getPrimary()!.getType()    : undefined; }\n\n            is(kind: ExprKind)  { return this.kind === kind; }\n            isOrEndWith(kind: ExprKind) : boolean { return (this.is(kind) || this.isParen() && this.getParen()!.source.isOrEndWith(kind)) || false; }\n\n            isIdent()           { return this.is('Primary') && this.getPrimary()!.is('Ident'); }\n            isLiteral()         { return this.is('Primary') && this.getPrimary()!.is('Literal'); }\n            isObject()          { return this.is('Primary') && this.getPrimary()!.is('Object'); }\n            isParen()           { return this.is('Primary') && this.getPrimary()!.is('Paren'); }\n            isTuple()           { return this.is('Primary') && this.getPrimary()!.is('Tuple'); }\n            isType()            { return this.is('Primary') && this.getPrimary()!.is('Type'); }\n\n            isMemberAccess()    { return this.is('Postfix') && this.getPostfix()!.is('MemberAccess'); }\n            isArrayAccess()     { return this.is('Postfix') && this.getPostfix()!.is('ArrayAccess'); }\n            isCall()            { return this.is('Postfix') && this.getPostfix()!.is('Call'); }\n            isOrelse()          { return this.is('Orelse'); }\n            isAs()              { return this.is('As'); }\n\n            isTypeof()          { return this.is('Typeof'); }\n            isSizeof()          { return this.is('Sizeof'); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            // ────────────────────────── Primary ──────────────────────────\n\n                static asPrimary(span: Span, source: PrimaryNode) : ExprNode {\n                    return new ExprNode('Primary', span, source); }\n\n                static asLiteral(span: Span, kind: LiteralNode[\"kind\"], value: LiteralNode[\"value\"]) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asLiteral(kind, span, value)); }\n\n                static asIdent(span: Span, name: string, builtin = false) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asIdent(span || DEF_SPAN, name, builtin)); }\n\n                static asType(span: Span, type: TypeNode) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asType(span || DEF_SPAN, type)); }\n\n                static asInteger(span: Span, value: number) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Integer', value); }\n\n                static asFloat(span: Span, value: number) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Float', value); }\n\n                static asBool(span: Span, value: boolean) : ExprNode  { return this.asLiteral(span || DEF_SPAN, 'Bool', value); }\n\n                static asNull(span: Span) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Null', null); }\n\n                static asUndefined(span: Span) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Undefined', undefined); }\n\n                static asString(span: Span, value: string) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'String', value); }\n\n                static asChar(span: Span, value: string) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Character', value); }\n\n                static asArray(span: Span, elements: ExprNode[]) : ExprNode {\n                    return this.asLiteral(span || DEF_SPAN, 'Array', [...elements]); }\n\n                static asObject(span: Span, props: PropNode[], ident?: IdentNode | undefined) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asObject(span || DEF_SPAN, props, ident)); }\n\n                static asParen(span:Span, expression: ExprNode) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asParen(span || DEF_SPAN, expression)); }\n\n                static asTuple(span:Span, fields: ExprNode[]) : ExprNode {\n                    return ExprNode.asPrimary(span || DEF_SPAN, PrimaryNode.asTuple(span || DEF_SPAN, fields)); }\n\n            // ────────────────────────── Postfix ──────────────────────────\n\n                static asPostfix(span: Span, source: PostfixNode) : ExprNode {\n                    return new ExprNode('Postfix', span, source); }\n\n                static asPostIncrement(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asIncrement(span || DEF_SPAN, base)); }\n\n                static asPostDecrement(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asDecrement(span || DEF_SPAN, base)); }\n\n                static asDereference(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asDereference(span || DEF_SPAN, base)); }\n\n                static asMemberAccess(span: Span, base: ExprNode, target: ExprNode, optional = false) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asMember(span || DEF_SPAN, base, target, optional)); }\n\n                static asCall(span: Span, base: ExprNode, args: ExprNode[]) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asCall(span || DEF_SPAN, base, args)); }\n\n                static asArrayAccess(span: Span, base: ExprNode, index: ExprNode) : ExprNode {\n                    return ExprNode.asPostfix(span || DEF_SPAN, PostfixNode.asArrayAccess(span || DEF_SPAN, base, index)); }\n\n            // ────────────────────────── Prefix ──────────────────────────\n\n                static asPrefix(span: Span, source: PrefixNode) : ExprNode {\n                    return new ExprNode('Prefix', span, source); }\n\n                static asPreIncrement(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('Increment', span, base)); }\n\n                static asPreDecrement(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('Decrement', span, base)); }\n\n                static asReference(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('Reference', span, base)); }\n\n                static asUnaryMinus(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('UnaryMinus', span, base)); }\n\n                static asUnaryPlus(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('UnaryPlus', span, base)); }\n\n                static asLogicalNot(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('LogicalNot', span, base)); }\n\n                static asxBitwiseNot(span: Span, base: ExprNode) : ExprNode {\n                    return ExprNode.asPrefix(span || DEF_SPAN, PrefixNode.create('BitwiseNot', span, base)); }\n\n            // ────────────────────────── Rest ──────────────────────────\n\n                static asBinary(span:Span, left: ExprNode, operator: string, right: ExprNode) : ExprNode {\n                    return new ExprNode('Binary', span, BinaryNode.create(span || DEF_SPAN, left, operator, right)); }\n\n                static asConditional(span: Span, condExpr: ExprNode, trueExpr: ExprNode, falseExpr: ExprNode) : ExprNode {\n                    return new ExprNode('Cond', span, CondNode.create(span || DEF_SPAN, condExpr, trueExpr, falseExpr)); }\n\n                static asIf(span: Span, condExpr: ExprNode, thenStmt: StmtNode, elseStmt: StmtNode | null) : ExprNode {\n                    return new ExprNode('If', span, IfNode.create(span || DEF_SPAN, condExpr, thenStmt, elseStmt)); }\n\n                static asSwitch(span: Span, condExpr: ExprNode, cases: CaseNode[], defCase: DefaultNode | null) : ExprNode {\n                    return new ExprNode('Switch', span, SwitchNode.create(span || DEF_SPAN, condExpr, cases, defCase)); }\n\n                static asCatch(span: Span, leftExpr: ExprNode, tag: ExprNode | null, rightStmt: StmtNode) : ExprNode {\n                    return new ExprNode('Catch', span, CatchNode.create(span || DEF_SPAN, leftExpr, tag, rightStmt)); }\n\n                static asTry(span: Span, expr: ExprNode) : ExprNode {\n                    return new ExprNode('Try', span, TryNode.create(span || DEF_SPAN, expr)); }\n\n                static asRange(span: Span, leftExpr: ExprNode | null, rangeType: string, rightExpr: ExprNode | null) : ExprNode {\n                    return new ExprNode('Range', span, RangeNode.create(span || DEF_SPAN, leftExpr, rangeType, rightExpr)); }\n\n                static asOrelse(span: Span, left: ExprNode, right: ExprNode) : ExprNode {\n                    return new ExprNode('Orelse', span, OrelseNode.create(span || DEF_SPAN, left, right)); }\n\n                static asAs(span: Span, base: ExprNode, type: TypeNode) : ExprNode {\n                    return new ExprNode('As', span, AsNode.create(span || DEF_SPAN, base, type)); }\n\n                static asTypeof(span: Span, type: ExprNode) : ExprNode {\n                    return new ExprNode('Typeof', span, TypeofNode.create(span || DEF_SPAN, type)); }\n\n                static asSizeof(span: Span, type: ExprNode) : ExprNode {\n                    return new ExprNode('Sizeof', span, SizeofNode.create(span || DEF_SPAN, type)); }\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// ..?\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { ExprNode } from '../../level-2/ExprNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class ExprTupleNode extends Node  {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'Tuple' as const;\n            public level = 4;\n\n            constructor(\n                public span         : Span,\n                public fields       : ExprNode[],\n            ) {\n                super();\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                children.push(...this.fields);\n\n                return children;\n            }\n\n            clone(newSpan?: Span): ExprTupleNode {\n                const cloned = new ExprTupleNode(newSpan || this.span, this.fields);\n                return cloned;\n            }\n\n            toString(): string {\n                return `{ ${this.fields.map(f => `f${f.getIdent()!.name}`).join(', ') } }`;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, fields: ExprNode[]): ExprTupleNode {\n                return new ExprTupleNode(span, fields);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// EnumVariantNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { TypeNode } from '../../level-2/TypeNode';\nimport { IdentNode } from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class EnumVariantNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public kind = 'EnumVariant' as const;\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public ident        : IdentNode,\n                public type?        : TypeNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                return this.type ? [this.type] : [];\n            }\n\n            clone(newSpan?: Span): EnumVariantNode {\n                return new EnumVariantNode(\n                    newSpan ?? this.span,\n                    this.ident,\n                    this.type\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            hasType(): boolean {\n                return this.type !== undefined;\n            }\n\n            isUnit(): boolean {\n                return this.type === undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, ident: IdentNode, type?: TypeNode): EnumVariantNode {\n                return new EnumVariantNode(span, ident, type);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// FieldNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node, VisibilityKind, VisibilityInfo, MutabilityInfo, ComptimeInfo }\n                                        from '../../node';\n    import { ExprNode }                 from '../../level-2/ExprNode';\n    import { TypeNode }                 from '../../level-2/TypeNode';\n    import { IdentNode }                from '../../level-4/CommonNodes/IdentNode';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class FieldNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 5;\n            public kind = 'Field' as const;\n\n            constructor(\n                public span             : Span,\n                public visibility       : VisibilityInfo,\n                public comptime         : ComptimeInfo,\n                public mutability       : MutabilityInfo,\n                public ident            : IdentNode,\n                public type?            : TypeNode,\n                public initializer      ?: ExprNode,\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n\n                if (this.type)          { children.push(this.type); }\n                if (this.initializer)   { children.push(this.initializer); }\n\n                return children;\n            }\n\n            clone(newSpan?: Span): FieldNode {\n                return new FieldNode(\n                    newSpan ?? this.span,\n                    this.visibility,\n                    this.comptime,\n                    this.mutability,\n                    this.ident,\n                    this.type,\n                    this.initializer\n                );\n            }\n\n            // for factory\n            getField(): FieldNode {\n                return this;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, visibility: VisibilityInfo, comptime: ComptimeInfo, mutability: MutabilityInfo, ident: IdentNode, type?: TypeNode, initializer?: ExprNode): FieldNode {\n                return new FieldNode(span, visibility, comptime, mutability, ident, type, initializer);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// StructMemberNode.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import { Span, Node } from '../../node';\n    import { FieldNode, FuncStmtNode } from '../../../ast';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\n\n    export type StructMemberKind = 'Field' | 'Method';\n\n    export type StructMemberVisibility = 'Private' | 'Public' | 'Static';\n\n    export type StructMemeberSourceType = FuncStmtNode | FieldNode\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    export class StructMemberNode extends Node {\n\n        // ┌──────────────────────────────── INIT ──────────────────────────────┐\n\n            public level = 5;\n\n            constructor(\n                public span         : Span,\n                public kind         : StructMemberKind,\n                public source       : StructMemeberSourceType\n            ) { super(); }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── NODE ──────────────────────────────┐\n\n            public getChildrenNodes(): Node[] {\n                const children: Node[] = [];\n                if (this.source) children.push(this.source);\n                return children;\n            }\n\n            clone(newSpan?: Span): StructMemberNode {\n                return new StructMemberNode(\n                    newSpan ?? this.span,\n                    this.kind,\n                    this.source,\n                );\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── HELP ──────────────────────────────┐\n\n            isField(): boolean {\n                return this.kind === 'Field';\n            }\n\n            isMethod(): boolean {\n                return this.kind === 'Method';\n            }\n\n            getField(): FieldNode | undefined {\n                if(this.isField()) return this.source as FieldNode;\n                return undefined;\n            }\n\n            getMethod(): FuncStmtNode | undefined {\n                if(this.isMethod()) return this.source as FuncStmtNode;\n                return undefined;\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n\n        // ┌──────────────────────────────── MAIN ──────────────────────────────┐\n\n            static create(span: Span, source: StructMemeberSourceType): StructMemberNode {\n                return new StructMemberNode(span, source.kind === 'Function' ? 'Method' : 'Field', source);\n            }\n\n            static createField(span: Span, structFieldNode: FieldNode): StructMemberNode {\n                return new StructMemberNode(span, 'Field', structFieldNode);\n            }\n\n            static createMethod(span: Span, funcNode: FuncStmtNode): StructMemberNode {\n                return new StructMemberNode(span, 'Method', funcNode);\n            }\n\n        // └────────────────────────────────────────────────────────────────────┘\n\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// project.ts — ..?\r\n//\r\n// Developed with ❤️ by Maysara.\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\r\n\r\n    import * as ParseLib        from '@je-es/parser';\r\n    import * as SyntaxLib       from '@je-es/syntax';\r\n    import { Analyzer, AnalysisPhase, DiagnosticManager, DiagKind, DiagCode, ContextTracker, DebugManager }\r\n                                from '@je-es/ast-analyzer';\r\n    import * as AST             from '@je-es/ast';\r\n    import * as fs              from 'fs';\r\n    import * as Path            from 'path';\r\n    import * as EventEmitter    from 'events';\r\n    import * as crypto          from 'crypto';\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ TYPE ════════════════════════════════════════╗\r\n\r\n    export interface LintResult {\r\n        has_error           : boolean;\r\n        has_warning         : boolean;\r\n        diagnosticManager   : DiagnosticManager;\r\n    }\r\n\r\n    export interface ProjectConfig {\r\n        name?               : string;\r\n        version?            : string;\r\n        author?             : string;\r\n        license?            : string;\r\n        main?               : string;\r\n        repo?               : string;\r\n        dependencies?       : { [key: string]: string };\r\n        devDependencies?    : { [key: string]: string };\r\n        scripts?            : { [key: string]: string };\r\n    }\r\n\r\n    export interface ProjectSettings {\r\n        config              : ProjectConfig;\r\n        syntax              : unknown;\r\n        isAnonymous         : boolean;\r\n    }\r\n\r\n    export interface LintMetrics {\r\n        totalLints      : number;\r\n        totalTime       : number;\r\n        cacheHits       : number;\r\n        averageTime     : number;\r\n        peakMemory      : number;\r\n    }\r\n\r\n    export interface CachedResult {\r\n        hash: string;\r\n        result: LintResult;\r\n        timestamp: number;\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\r\n\r\n    const DEBUG_LEVEL           = process.env.KEMET_DEBUG === 'true' ? 'verbose' : process.env.KEMET_DEBUG === 'false' ? 'off' : 'verbose';\r\n    const DEBOUNCE_MS           = parseInt(process.env.KEMET_DEBOUNCE_MS || '50');\r\n    const CACHE_MAX_SIZE        = parseInt(process.env.KEMET_CACHE_SIZE || '100');\r\n    const CACHE_MAX_AGE_MS      = parseInt(process.env.KEMET_CACHE_AGE_MS || '300000');\r\n    const MAX_FILE_SIZE_KB      = parseInt(process.env.KEMET_MAX_FILE_SIZE_KB || '10240');\r\n    const FILE_SCAN_DEPTH_LIMIT = 50;\r\n\r\n    const debugMgr = new DebugManager(undefined, DEBUG_LEVEL as any);\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\r\n\r\n    export class Project extends EventEmitter.EventEmitter {\r\n\r\n        // ┌──────────────────────────────── INIT ────────────────────────────────┐\r\n\r\n            rootPath    : string;\r\n            program     : AST.Program | null = null;\r\n            settings    : ProjectSettings;\r\n\r\n            syntax      : SyntaxLib.Syntax;\r\n            analyzer    : Analyzer;\r\n\r\n            private diagnosticCache     = new Map<string, CachedResult>();\r\n            private pendingLintRequests = new Map<string, NodeJS.Timeout>();\r\n            private lastLintResults     = new Map<string, LintResult>();\r\n            private metrics             = this.createDefaultLintMetrics();\r\n\r\n            private fileWatcher             : fs.FSWatcher   | null = null;\r\n            private watcherDelay            : NodeJS.Timeout | null = null;\r\n            private watcherRestartAttempts  = 0;\r\n            private MAX_WATCHER_RESTARTS    = 3;\r\n            private cleanupInterval         : NodeJS.Timeout | null = null;\r\n            private isFirstLint             : boolean = true;\r\n\r\n            // Store parse errors for modules so we can report them\r\n            private moduleParseErrors = new Map<string, Array<{msg: string, span: ParseLib.Span}>>();\r\n\r\n            private constructor(rootPath: string, settings: ProjectSettings) {\r\n                super();\r\n\r\n                try {\r\n                    this.rootPath = rootPath;\r\n                    this.settings = settings;\r\n                    this.syntax = settings.syntax as SyntaxLib.Syntax;\r\n\r\n                    if (!this.syntax) {\r\n                        throw new Error('Syntax is not available');\r\n                    }\r\n\r\n                    debugMgr.log('verbose', `[Project] Initialized project at ${rootPath}`);\r\n\r\n                    this.analyzer = Analyzer.create({\r\n                        debug: 'off',\r\n                        stopAtPhase: AnalysisPhase.SemanticValidation,\r\n                        strictMode: false\r\n                    });\r\n\r\n                    if (!this.analyzer) {\r\n                        throw new Error('Failed to create Analyzer instance');\r\n                    }\r\n\r\n                    this.startPeriodicCleanup();\r\n                } catch (e) {\r\n                    console.error(`[Project] Constructor error:`, e);\r\n                    throw e;\r\n                }\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌─────────────────────────────── CREATE ───────────────────────────────┐\r\n\r\n            static create(rootPath: string, settings: ProjectSettings): Project {\r\n                try {\r\n                    return new Project(rootPath, settings);\r\n                } catch (e) {\r\n                    console.error(`[Project] Error creating project:`, e);\r\n                    throw e;\r\n                }\r\n            }\r\n\r\n            static createAnonymous(syntax: unknown): Project {\r\n                try {\r\n                    return new Project('', {\r\n                        config: {},\r\n                        syntax: syntax,\r\n                        isAnonymous: true,\r\n                    });\r\n                } catch (e) {\r\n                    console.error(`[Project] Error creating anonymous project:`, e);\r\n                    throw e;\r\n                }\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            async lintAsync(sourceCode: string, modulePath?: string): Promise<LintResult> {\r\n                const key = modulePath || 'anonymous';\r\n\r\n                return new Promise((resolve) => {\r\n                    const existingTimeout = this.pendingLintRequests.get(key);\r\n                    if (existingTimeout) {\r\n                        clearTimeout(existingTimeout);\r\n                    }\r\n\r\n                    const timeout = setTimeout(() => {\r\n                        this.pendingLintRequests.delete(key);\r\n                        const result = this.lintInternal(sourceCode, modulePath);\r\n                        this.lastLintResults.set(key, result);\r\n                        resolve(result);\r\n                    }, DEBOUNCE_MS);\r\n\r\n                    this.pendingLintRequests.set(key, timeout);\r\n                });\r\n            }\r\n\r\n            lint(sourceCode: string, modulePath?: string): LintResult {\r\n                const key = modulePath || 'anonymous';\r\n\r\n                const cached = this.lastLintResults.get(key);\r\n                if (cached) {\r\n                    return cached;\r\n                }\r\n\r\n                return this.lintInternal(sourceCode, modulePath);\r\n            }\r\n\r\n            private lintInternal(sourceCode: string, modulePath?: string): LintResult {\r\n                const startTime = Date.now();\r\n                const key = modulePath || 'anonymous';\r\n\r\n                debugMgr.log('verbose', `\\n${'='.repeat(80)}`);\r\n                debugMgr.log('verbose', `[LINT] Starting lint operation for: ${key}`);\r\n\r\n                const contextTracker = new ContextTracker();\r\n                let result: LintResult = {\r\n                    has_error: false,\r\n                    has_warning: false,\r\n                    diagnosticManager: new DiagnosticManager(contextTracker, true),\r\n                };\r\n\r\n                try {\r\n                    const hash = this.computeModuleHash(sourceCode);\r\n\r\n                    if (this.isFirstLint) {\r\n                        debugMgr.log('verbose', `[LINT] First lint - forcing full analysis`);\r\n                        this.isFirstLint = false;\r\n                    }\r\n\r\n                    debugMgr.log('verbose', `[LINT] Parsing source code...`);\r\n                    const parseResult = this.syntax.parse(sourceCode);\r\n\r\n                    // CRITICAL FIX: Always report parse errors\r\n                    if (parseResult.errors.length > 0) {\r\n                        debugMgr.log('verbose', `[LINT] Parse errors: ${parseResult.errors.length}`);\r\n                        result.has_error = true;\r\n\r\n                        for (const err of parseResult.errors) {\r\n                            const diagnostic = {\r\n                                code: DiagCode.SYNTAX_ERROR,\r\n                                kind: DiagKind.ERROR,\r\n                                contextSpan: err.span,\r\n                                targetSpan: err.span, // CRITICAL: Add targetSpan for proper positioning\r\n                                msg: err.msg,\r\n                            };\r\n                            // CRITICAL FIX: Add directly to diagnostics array, not to getAllErrors() result\r\n                            result.diagnosticManager.diagnostics.push(diagnostic);\r\n                        }\r\n\r\n                        // Store parse errors for this module\r\n                        if (modulePath) {\r\n                            this.moduleParseErrors.set(modulePath, parseResult.errors);\r\n                        }\r\n\r\n                        debugMgr.log('verbose', `[LINT] Added ${parseResult.errors.length} parse errors to diagnostics`);\r\n                        debugMgr.log('verbose', `[LINT] Total diagnostics now: ${result.diagnosticManager.diagnostics.length}`);\r\n                    } else {\r\n                        debugMgr.log('verbose', `[LINT] Parse successful`);\r\n\r\n                        // Clear any stored parse errors\r\n                        if (modulePath) {\r\n                            this.moduleParseErrors.delete(modulePath);\r\n                        }\r\n\r\n                        const statements: AST.StmtNode[] = parseResult.ast.length > 0\r\n                            ? parseResult.ast[0].getCustomData()! as AST.StmtNode[]\r\n                            : [];\r\n\r\n                        const moduleName = modulePath\r\n                            ? Path.basename(modulePath, '.k')\r\n                            : 'main';\r\n\r\n                        debugMgr.log('verbose', `[LINT] Creating module '${moduleName}' with ${statements.length} statements`);\r\n\r\n                        const freshModule = AST.Module.create(moduleName, statements, { path: modulePath });\r\n\r\n                        if (!this.program) {\r\n                            const existingModules = this.loadExistingModules();\r\n                            this.program = AST.Program.create(existingModules, { path: this.rootPath });\r\n                        }\r\n\r\n                        this.program.modules.set(moduleName, freshModule);\r\n\r\n                        if (modulePath && !this.settings.isAnonymous) {\r\n                            const sourceDir = this.getSourceDirectory();\r\n                            const allKemetFiles = this.scanKemetFiles(sourceDir);\r\n\r\n                            for (const filePath of allKemetFiles) {\r\n                                const otherModuleName = Path.basename(filePath, '.k');\r\n\r\n                                if (otherModuleName === moduleName) continue;\r\n\r\n                                if (!this.program.modules.has(otherModuleName)) {\r\n                                    const module = this.parseModuleFromFile(filePath);\r\n                                    if (module) {\r\n                                        this.program.modules.set(otherModuleName, module);\r\n                                        debugMgr.log('verbose', `[LINT] Loaded dependency module '${otherModuleName}'`);\r\n\r\n                                        // CRITICAL FIX: Report parse errors from dependency modules too\r\n                                        const depParseErrors = this.moduleParseErrors.get(filePath);\r\n                                        if (depParseErrors && depParseErrors.length > 0) {\r\n                                            debugMgr.log('verbose', `[LINT] Found ${depParseErrors.length} cached parse errors for '${otherModuleName}'`);\r\n                                            for (const err of depParseErrors) {\r\n                                                // Add directly to diagnostics array\r\n                                                result.diagnosticManager.diagnostics.push({\r\n                                                    code: DiagCode.SYNTAX_ERROR,\r\n                                                    kind: DiagKind.ERROR,\r\n                                                    contextSpan: err.span,\r\n                                                    targetSpan: err.span,\r\n                                                    msg: err.msg,\r\n                                                    sourceModuleName: otherModuleName,\r\n                                                    sourceModulePath: filePath,\r\n                                                });\r\n                                            }\r\n                                            result.has_error = true;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        debugMgr.log('verbose', `[LINT] Analyzing program...`);\r\n                        this.analyzer.reset();\r\n\r\n                        const analyzerResult = this.analyzer.analyze(this.program);\r\n\r\n                        const allDiagnostics = analyzerResult.diagnostics;\r\n                        const filteredDiagnostics = modulePath\r\n                            ? allDiagnostics.filter(diag => {\r\n                                if (diag.sourceModuleName) {\r\n                                    return diag.sourceModuleName === moduleName;\r\n                                }\r\n                                if (diag.sourceModulePath) {\r\n                                    return diag.sourceModulePath === modulePath ||\r\n                                        diag.sourceModulePath === `./${moduleName}`;\r\n                                }\r\n                                return true;\r\n                            })\r\n                            : allDiagnostics;\r\n\r\n                        debugMgr.log('verbose', `[LINT] Filtered ${allDiagnostics.length} -> ${filteredDiagnostics.length} diagnostics`);\r\n\r\n                        result.diagnosticManager.diagnostics = filteredDiagnostics;\r\n\r\n                        for (const diag of filteredDiagnostics) {\r\n                            if (diag.kind === DiagKind.ERROR) {\r\n                                result.has_error = true;\r\n                            } else if (diag.kind === DiagKind.WARNING) {\r\n                                result.has_warning = true;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    this.diagnosticCache.set(key, {\r\n                        hash,\r\n                        result,\r\n                        timestamp: Date.now()\r\n                    });\r\n\r\n                } catch (e) {\r\n                    console.error(`[LINT] Exception during lint:`, e);\r\n                    if (e instanceof Error) {\r\n                        console.error(`[LINT] Stack:`, e.stack);\r\n                    }\r\n                    result.has_error = true;\r\n                    result.diagnosticManager.getAllErrors().push({\r\n                        code: DiagCode.INTERNAL_ERROR,\r\n                        kind: DiagKind.ERROR,\r\n                        msg: `Internal linting error: ${e instanceof Error ? e.message : 'Unknown error'}`,\r\n                    });\r\n                } finally {\r\n                    const duration = Date.now() - startTime;\r\n                    this.updateMetrics(duration, false);\r\n\r\n                    debugMgr.log('verbose', `[LINT] Complete in ${duration}ms`);\r\n                    debugMgr.log('verbose', `${'='.repeat(80)}\\n`);\r\n                }\r\n\r\n                return result;\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private scanKemetFiles(directory: string): string[] {\r\n                const files: string[] = [];\r\n\r\n                const scan = (dir: string, depth: number = 0) => {\r\n                    try {\r\n                        if (depth > FILE_SCAN_DEPTH_LIMIT) {\r\n                            console.warn(`[Project] Directory scanning depth exceeded at: ${dir}`);\r\n                            return;\r\n                        }\r\n\r\n                        const entries = fs.readdirSync(dir, { withFileTypes: true });\r\n\r\n                        for (const entry of entries) {\r\n                            try {\r\n                                const fullPath = Path.join(dir, entry.name);\r\n\r\n                                if (entry.isDirectory()) {\r\n                                    if (!['node_modules', '.git', 'dist', 'out', 'build'].includes(entry.name)) {\r\n                                        scan(fullPath, depth + 1);\r\n                                    }\r\n                                } else if (entry.isFile() && entry.name.endsWith('.k')) {\r\n                                    const stats = fs.statSync(fullPath);\r\n                                    const sizeKB = stats.size / 1024;\r\n\r\n                                    if (sizeKB > MAX_FILE_SIZE_KB) {\r\n                                        console.warn(`[Project] Skipping large file (${sizeKB.toFixed(0)}KB): ${fullPath}`);\r\n                                        continue;\r\n                                    }\r\n\r\n                                    files.push(fullPath);\r\n                                }\r\n                            } catch (entryError) {\r\n                                console.warn(`[Project] Error processing entry: ${entryError}`);\r\n                                continue;\r\n                            }\r\n                        }\r\n                    } catch (e) {\r\n                        console.error(`[Project] Failed to scan directory ${dir}:`, e);\r\n                    }\r\n                };\r\n\r\n                try {\r\n                    scan(directory);\r\n                } catch (e) {\r\n                    console.error(`[Project] Critical error during file scan:`, e);\r\n                }\r\n\r\n                return files;\r\n            }\r\n\r\n            private parseModuleFromFile(filePath: string): AST.Module | null {\r\n                try {\r\n                    const stats = fs.statSync(filePath);\r\n                    if (stats.size > MAX_FILE_SIZE_KB * 1024) {\r\n                        console.warn(`[Project] File too large to parse: ${filePath}`);\r\n                        return null;\r\n                    }\r\n\r\n                    const content = fs.readFileSync(filePath, { encoding: 'utf-8' });\r\n                    const parseResult = this.syntax.parse(content);\r\n\r\n                    const moduleName = Path.basename(filePath, '.k');\r\n\r\n                    if (parseResult.errors.length > 0) {\r\n                        console.warn(`[Project] Parse errors in ${filePath}: (${parseResult.errors.length})`, parseResult.errors);\r\n\r\n                        // CRITICAL FIX: Store the parse errors so lintInternal can report them\r\n                        this.moduleParseErrors.set(filePath, parseResult.errors);\r\n\r\n                        // Still create a module (empty) so the program structure is maintained\r\n                        const module = AST.Module.create(moduleName, []);\r\n                        module.metadata.path = filePath;\r\n                        module.metadata.hasParseErrors = true;\r\n\r\n                        return module;\r\n                    }\r\n\r\n                    // Clear any previous parse errors for this file\r\n                    this.moduleParseErrors.delete(filePath);\r\n\r\n                    const statements = parseResult.ast.length > 0\r\n                        ? parseResult.ast[0].getCustomData()! as AST.StmtNode[]\r\n                        : [];\r\n\r\n                    const module = AST.Module.create(moduleName, statements);\r\n                    module.metadata.path = filePath;\r\n\r\n                    return module;\r\n                } catch (e) {\r\n                    console.error(`[Project] Failed to parse file ${filePath}:`, e);\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            private computeModuleHash(content: string): string {\r\n                try {\r\n                    return crypto.createHash('sha256').update(content).digest('hex');\r\n                } catch (e) {\r\n                    console.error(`[Project] Error computing hash:`, e);\r\n                    return content.split('').reduce((h, c) => ((h << 5) - h) + c.charCodeAt(0), 0).toString();\r\n                }\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            getMetrics(): LintMetrics {\r\n                return { ...this.metrics };\r\n            }\r\n\r\n            private updateMetrics(duration: number, cacheHit: boolean): void {\r\n                this.metrics.totalLints++;\r\n                this.metrics.totalTime += duration;\r\n                if (cacheHit) this.metrics.cacheHits++;\r\n                this.metrics.averageTime = this.metrics.totalTime / this.metrics.totalLints;\r\n\r\n                if (typeof process !== 'undefined' && process.memoryUsage) {\r\n                    const memUsage = process.memoryUsage().heapUsed / 1024 / 1024;\r\n                    this.metrics.peakMemory = Math.max(this.metrics.peakMemory, memUsage);\r\n                }\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private startPeriodicCleanup(): void {\r\n                this.cleanupInterval = setInterval(() => {\r\n                    this.cleanupCache();\r\n                    this.cleanupOldResults();\r\n                }, 60000);\r\n            }\r\n\r\n            private cleanupCache(): void {\r\n                try {\r\n                    const now = Date.now();\r\n                    let deleted = 0;\r\n\r\n                    for (const [key, cached] of this.diagnosticCache.entries()) {\r\n                        if (now - cached.timestamp > CACHE_MAX_AGE_MS) {\r\n                            this.diagnosticCache.delete(key);\r\n                            deleted++;\r\n                        }\r\n                    }\r\n\r\n                    if (this.diagnosticCache.size > CACHE_MAX_SIZE) {\r\n                        const entries = Array.from(this.diagnosticCache.entries())\r\n                            .sort((a, b) => a[1].timestamp - b[1].timestamp);\r\n\r\n                        const toDelete = entries.slice(0, entries.length - CACHE_MAX_SIZE);\r\n                        toDelete.forEach(([key]) => {\r\n                            this.diagnosticCache.delete(key);\r\n                            deleted++;\r\n                        });\r\n                    }\r\n\r\n                    if (deleted > 0) {\r\n                        debugMgr.log('verbose', `[Project] Cleaned up ${deleted} cache entries`);\r\n                    }\r\n                } catch (e) {\r\n                    console.error('[Project] Error during cache cleanup:', e);\r\n                }\r\n            }\r\n\r\n            private cleanupOldResults(): void {\r\n                try {\r\n                    if (this.lastLintResults.size > CACHE_MAX_SIZE) {\r\n                        const keys = Array.from(this.lastLintResults.keys());\r\n                        const toDelete = keys.slice(0, keys.length - CACHE_MAX_SIZE);\r\n                        toDelete.forEach(k => this.lastLintResults.delete(k));\r\n                        debugMgr.log('verbose', `[Project] Cleaned up ${toDelete.length} old results`);\r\n                    }\r\n                } catch (e) {\r\n                    console.error('[Project] Error cleaning old results:', e);\r\n                }\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── HELP ────────────────────────────────┐\r\n\r\n            createDefaultLintMetrics(): LintMetrics {\r\n                return {\r\n                    totalLints: 0,\r\n                    totalTime: 0,\r\n                    cacheHits: 0,\r\n                    averageTime: 0,\r\n                    peakMemory: 0\r\n                } as LintMetrics;\r\n            }\r\n\r\n            initializeProgram(): void {\r\n                try {\r\n                    const modules = this.loadExistingModules();\r\n                    this.program = AST.Program.create(modules, { path: this.rootPath });\r\n\r\n                    debugMgr.log('verbose', `[Project] Initialized program with ${modules.length} module(s)`);\r\n                    debugMgr.log('verbose', `[Project] Program modules map has: [${Array.from(this.program.modules.keys()).join(', ')}]`);\r\n\r\n                    if (this.program.modules.size > 0) {\r\n                        debugMgr.log('verbose', `[Project] Running initial analysis to populate module metadata...`);\r\n                        try {\r\n                            this.analyzer.reset();\r\n                            const initialAnalysis = this.analyzer.analyze(this.program);\r\n                            debugMgr.log('verbose', `[Project] Initial analysis complete: ${initialAnalysis.success ? 'success' : 'with errors'}`);\r\n                            debugMgr.log('verbose', `[Project] Found ${initialAnalysis.diagnostics.length} diagnostics`);\r\n                        } catch (e) {\r\n                            console.error(`[Project] Error during initial analysis:`, e);\r\n                        }\r\n                    }\r\n\r\n                    if (!this.settings.isAnonymous && this.rootPath) {\r\n                        this.startFileWatcher();\r\n                    }\r\n                } catch (e) {\r\n                    console.error(`[Project] Error initializing program:`, e);\r\n                    this.program = AST.Program.create([], { path: this.rootPath });\r\n                }\r\n            }\r\n\r\n            loadExistingModules(): AST.Module[] {\r\n                try {\r\n                    if (this.settings.isAnonymous || !this.rootPath) {\r\n                        return [];\r\n                    }\r\n\r\n                    const sourceDir = this.getSourceDirectory();\r\n\r\n                    if (!fs.existsSync(sourceDir)) {\r\n                        console.warn(`[Project] Source directory does not exist: ${sourceDir}`);\r\n                        return [];\r\n                    }\r\n\r\n                    const kemetFiles = this.scanKemetFiles(sourceDir);\r\n                    const modules: AST.Module[] = [];\r\n\r\n                    debugMgr.log('verbose', `[Project] Found ${kemetFiles.length} Kemet files to load`);\r\n\r\n                    for (const filePath of kemetFiles) {\r\n                        try {\r\n                            const module = this.parseModuleFromFile(filePath);\r\n                            if (module) {\r\n                                modules.push(module);\r\n                                debugMgr.log('verbose', `[Project] Loaded module '${module.name}' from ${filePath}`);\r\n                            }\r\n                        } catch (e) {\r\n                            console.error(`[Project] Error loading module from ${filePath}:`, e);\r\n                            continue;\r\n                        }\r\n                    }\r\n\r\n                    return modules;\r\n                } catch (e) {\r\n                    console.error(`[Project] Error loading existing modules:`, e);\r\n                    return [];\r\n                }\r\n            }\r\n\r\n            getSourceDirectory(): string {\r\n                try {\r\n                    if (!this.settings.config.main) {\r\n                        return this.rootPath;\r\n                    }\r\n\r\n                    const mainPath = Path.join(this.rootPath, this.settings.config.main);\r\n\r\n                    if (!fs.existsSync(mainPath)) {\r\n                        console.warn(`[Project] Main path does not exist: ${mainPath}`);\r\n                        return this.rootPath;\r\n                    }\r\n\r\n                    const stats = fs.statSync(mainPath);\r\n                    return stats.isDirectory() ? mainPath : Path.dirname(mainPath);\r\n                } catch (e) {\r\n                    console.error(`[Project] Error getting source directory:`, e);\r\n                    return this.rootPath;\r\n                }\r\n            }\r\n\r\n            static loadConfigFromPath(rootPath: string): ProjectConfig {\r\n                try {\r\n                    const configPath = Path.join(rootPath, 'config.json');\r\n\r\n                    if (!fs.existsSync(configPath)) {\r\n                        debugMgr.log('verbose', `[Project] No config.json at ${rootPath}`);\r\n                        return {};\r\n                    }\r\n\r\n                    const configContent = fs.readFileSync(configPath, { encoding: 'utf-8' });\r\n                    const config = JSON.parse(configContent);\r\n                    debugMgr.log('verbose', `[Project] Loaded config: ${JSON.stringify(config, null, 2)}`);\r\n                    return config;\r\n                } catch (e) {\r\n                    console.error(`[Project] Error loading config from ${rootPath}:`, e);\r\n                    return {};\r\n                }\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            private startFileWatcher(): void {\r\n                try {\r\n                    const sourceDir = this.getSourceDirectory();\r\n\r\n                    if (!fs.existsSync(sourceDir)) {\r\n                        console.warn(`[Project] Cannot watch non-existent directory: ${sourceDir}`);\r\n                        return;\r\n                    }\r\n\r\n                    this.fileWatcher = fs.watch(sourceDir, { recursive: true }, (eventType, filename) => {\r\n                        try {\r\n                            if (!filename || !filename.endsWith('.k')) {\r\n                                return;\r\n                            }\r\n\r\n                            const filePath = Path.join(sourceDir, filename);\r\n\r\n                            if (this.watcherDelay) {\r\n                                clearTimeout(this.watcherDelay);\r\n                            }\r\n\r\n                            this.watcherDelay = setTimeout(() => {\r\n                                try {\r\n                                    this.handleFileSystemChange(eventType, filePath);\r\n                                } catch (e) {\r\n                                    console.error(`[Project] Error handling file change:`, e);\r\n                                }\r\n                            }, 100);\r\n                        } catch (e) {\r\n                            console.error(`[Project] Error in file watcher callback:`, e);\r\n                        }\r\n                    });\r\n\r\n                    this.fileWatcher.on('error', (error) => {\r\n                        console.error('[Project] File watcher error:', error);\r\n                        this.handleWatcherError();\r\n                    });\r\n\r\n                    this.watcherRestartAttempts = 0;\r\n                    debugMgr.log('verbose', `[Project] File watcher started for ${sourceDir}`);\r\n                } catch (e) {\r\n                    console.error(`[Project] Failed to start file watcher:`, e);\r\n                }\r\n            }\r\n\r\n            private handleWatcherError(): void {\r\n                if (this.watcherRestartAttempts >= this.MAX_WATCHER_RESTARTS) {\r\n                    console.error('[Project] Max watcher restart attempts reached, giving up');\r\n                    return;\r\n                }\r\n\r\n                this.watcherRestartAttempts++;\r\n                console.log(`[Project] Attempting to restart file watcher (attempt ${this.watcherRestartAttempts})`);\r\n\r\n                setTimeout(() => {\r\n                    try {\r\n                        if (this.fileWatcher) {\r\n                            this.fileWatcher.close();\r\n                            this.fileWatcher = null;\r\n                        }\r\n                        this.startFileWatcher();\r\n                    } catch (e) {\r\n                        console.error('[Project] Failed to restart file watcher:', e);\r\n                    }\r\n                }, 1000 * this.watcherRestartAttempts);\r\n            }\r\n\r\n            private handleFileSystemChange(eventType: string, filePath: string): void {\r\n                try {\r\n                    const moduleName = Path.basename(filePath, '.k');\r\n\r\n                    this.diagnosticCache.delete(filePath);\r\n                    this.lastLintResults.delete(filePath);\r\n                    this.moduleParseErrors.delete(filePath); // Clear cached parse errors\r\n\r\n                    if (eventType === 'change') {\r\n                        console.log(`[Project] File modified: ${filePath}`);\r\n                        this.emit('moduleUpdated', moduleName);\r\n                    } else if (eventType === 'rename' || !fs.existsSync(filePath)) {\r\n                        console.log(`[Project] File deleted/removed: ${filePath}`);\r\n                        this.emit('moduleRemoved', moduleName);\r\n                    } else {\r\n                        console.log(`[Project] File added: ${filePath}`);\r\n                        this.emit('moduleAdded', moduleName);\r\n                    }\r\n                } catch (e) {\r\n                    console.error(`[Project] Error handling file system change:`, e);\r\n                }\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n\r\n        // ┌──────────────────────────────── ---- ────────────────────────────────┐\r\n\r\n            destroy(): void {\r\n                try {\r\n                    console.log('[Project] Destroying project resources');\r\n\r\n                    if (this.cleanupInterval) {\r\n                        clearInterval(this.cleanupInterval);\r\n                        this.cleanupInterval = null;\r\n                    }\r\n\r\n                    for (const timeout of this.pendingLintRequests.values()) {\r\n                        clearTimeout(timeout);\r\n                    }\r\n                    this.pendingLintRequests.clear();\r\n\r\n                    this.lastLintResults.clear();\r\n                    this.diagnosticCache.clear();\r\n                    this.moduleParseErrors.clear(); // Clean up parse error cache\r\n\r\n                    if (this.fileWatcher) {\r\n                        this.fileWatcher.close();\r\n                        this.fileWatcher = null;\r\n                    }\r\n\r\n                    if (this.watcherDelay) {\r\n                        clearTimeout(this.watcherDelay);\r\n                        this.watcherDelay = null;\r\n                    }\r\n\r\n                    this.removeAllListeners();\r\n\r\n                    console.log('[Project] Final metrics:', this.getMetrics());\r\n                    console.log('[Project] Project destroyed successfully');\r\n                } catch (e) {\r\n                    console.error('[Project] Error during destruction:', e);\r\n                }\r\n            }\r\n\r\n        // └──────────────────────────────────────────────────────────────────────┘\r\n\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// features/diagnostics.ts — Diagnostics validation and reporting\r\n\r\nimport {\r\n\tConnection,\r\n\tTextDocuments,\r\n\tDiagnostic,\r\n\tDiagnosticSeverity,\r\n\tDocumentDiagnosticReportKind,\r\n\ttype DocumentDiagnosticReport,\r\n} from 'vscode-languageserver';\r\nimport { TextDocument } from 'vscode-languageserver-textdocument';\r\nimport * as ProjectLib from '@je-es/project';\r\nimport { Span } from '@je-es/parser';\r\nimport { Diagnostic as KemetDiagnostic } from '@je-es/ast-analyzer';\r\nimport { SettingsManager } from './settings';\r\nimport { fileURLToPath } from 'url';\r\nimport * as Path from 'path';\r\n\r\ninterface ServerMetrics {\r\n\ttotalValidations: number;\r\n\ttotalErrors: number;\r\n\taverageValidationTime: number;\r\n\tcacheHitRate: number;\r\n}\r\n\r\nexport class DiagnosticsHandler {\r\n\tprivate connection: Connection;\r\n\tprivate documents: TextDocuments<TextDocument>;\r\n\tprivate projects: { main: ProjectLib.Project; anonymous: ProjectLib.Project };\r\n\tprivate settingsManager: SettingsManager;\r\n\tprivate serverMetrics: ServerMetrics;\r\n\tprivate inFlightValidations = new Map<string, Promise<Diagnostic[]>>();\r\n\r\n\tconstructor(\r\n\t\tconnection: Connection,\r\n\t\tdocuments: TextDocuments<TextDocument>,\r\n\t\tprojects: { main: ProjectLib.Project; anonymous: ProjectLib.Project },\r\n\t\tsettingsManager: SettingsManager,\r\n\t\tserverMetrics: ServerMetrics\r\n\t) {\r\n\t\tthis.connection = connection;\r\n\t\tthis.documents = documents;\r\n\t\tthis.projects = projects;\r\n\t\tthis.settingsManager = settingsManager;\r\n\t\tthis.serverMetrics = serverMetrics;\r\n\r\n\t\tthis.setupHandlers();\r\n\t}\r\n\r\n\tprivate setupHandlers(): void {\r\n\t\tthis.connection.languages.diagnostics.on(async (params) => {\r\n\t\t\treturn this.handleDiagnostics(params);\r\n\t\t});\r\n\t}\r\n\r\n\tprivate async handleDiagnostics(params: any): Promise<DocumentDiagnosticReport> {\r\n\t\ttry {\r\n\t\t\tconst document = this.documents.get(params.textDocument.uri);\r\n\t\t\tif (!document) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tkind: DocumentDiagnosticReportKind.Full,\r\n\t\t\t\t\titems: []\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tlet validationPromise = this.inFlightValidations.get(document.uri);\r\n\r\n\t\t\tif (!validationPromise) {\r\n\t\t\t\tvalidationPromise = this.validateDocument(document);\r\n\t\t\t\tthis.inFlightValidations.set(document.uri, validationPromise);\r\n\r\n\t\t\t\tvalidationPromise.finally(() => {\r\n\t\t\t\t\tthis.inFlightValidations.delete(document.uri);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tconst diagnostics = await validationPromise;\r\n\r\n\t\t\tconsole.log(`[DIAGNOSTICS] Returning ${diagnostics.length} diagnostics for ${document.uri}`);\r\n\r\n\t\t\treturn {\r\n\t\t\t\tkind: DocumentDiagnosticReportKind.Full,\r\n\t\t\t\titems: diagnostics\r\n\t\t\t};\r\n\t\t} catch (e) {\r\n\t\t\tconsole.error('[DIAGNOSTICS] Error:', e);\r\n\r\n\t\t\treturn {\r\n\t\t\t\tkind: DocumentDiagnosticReportKind.Full,\r\n\t\t\t\titems: [{\r\n\t\t\t\t\tseverity: DiagnosticSeverity.Error,\r\n\t\t\t\t\trange: {\r\n\t\t\t\t\t\tstart: { line: 0, character: 0 },\r\n\t\t\t\t\t\tend: { line: 0, character: 0 }\r\n\t\t\t\t\t},\r\n\t\t\t\t\tmessage: `LSP internal error: ${e instanceof Error ? e.message : 'Unknown error'}`,\r\n\t\t\t\t\tsource: 'kemet-lsp'\r\n\t\t\t\t}]\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\tprivate async validateDocument(document: TextDocument): Promise<Diagnostic[]> {\r\n\t\tconst startTime = Date.now();\r\n\r\n\t\ttry {\r\n\t\t\tconst diagnostics: Diagnostic[] = [];\r\n\t\t\tconst text = document.getText();\r\n\t\t\tconst uri = document.uri;\r\n\r\n\t\t\tconsole.log(`[DIAGNOSTICS] Starting validation for: ${uri}`);\r\n\r\n\t\t\tconst settings = await this.settingsManager.getDocumentSettings(uri);\r\n\r\n\t\t\t// Determine which project to use\r\n\t\t\tconst { project, modulePath } = this.determineProject(uri);\r\n\r\n\t\t\t// Lint the document\r\n\t\t\tconst result = await project.lintAsync(text, modulePath);\r\n\r\n\t\t\tconsole.log(`[DIAGNOSTICS] Lint result: has_error=${result.has_error}, has_warning=${result.has_warning}`);\r\n\r\n\t\t\t// Collect all diagnostics\r\n\t\t\tconst allErrors = result.diagnosticManager.getAllErrors();\r\n\t\t\tconst allWarnings = result.diagnosticManager.getAllWarnings();\r\n\t\t\tconst allInfos = result.diagnosticManager.getAllInfos();\r\n\r\n\t\t\tconsole.log(`[DIAGNOSTICS] DiagnosticManager stats:`);\r\n\t\t\tconsole.log(`  - Errors: ${allErrors.length}`);\r\n\t\t\tconsole.log(`  - Warnings: ${allWarnings.length}`);\r\n\t\t\tconsole.log(`  - Infos: ${allInfos.length}`);\r\n\r\n\t\t\tconst allKemetDiags = [...allErrors, ...allWarnings, ...allInfos];\r\n\r\n\t\t\t// Convert Kemet diagnostics to LSP diagnostics\r\n\t\t\tfor (const kemetDiag of allKemetDiags) {\r\n\t\t\t\tconst diagnostic = this.convertKemetDiagnostic(kemetDiag, document, settings);\r\n\t\t\t\tif (diagnostic) {\r\n\t\t\t\t\tdiagnostics.push(diagnostic);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Truncate if needed\r\n\t\t\tconst maxDiagnostics = settings.maxDiagnostics || 100;\r\n\t\t\tif (diagnostics.length > maxDiagnostics) {\r\n\t\t\t\tconst truncated = diagnostics.slice(0, maxDiagnostics);\r\n\t\t\t\ttruncated.push({\r\n\t\t\t\t\tseverity: DiagnosticSeverity.Warning,\r\n\t\t\t\t\trange: {\r\n\t\t\t\t\t\tstart: { line: 0, character: 0 },\r\n\t\t\t\t\t\tend: { line: 0, character: 0 }\r\n\t\t\t\t\t},\r\n\t\t\t\t\tmessage: `Too many diagnostics. Showing first ${maxDiagnostics} of ${diagnostics.length}.`,\r\n\t\t\t\t\tsource: 'kemet-lsp'\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthis.updateMetrics(startTime, allErrors.length);\r\n\t\t\t\treturn truncated;\r\n\t\t\t}\r\n\r\n\t\t\tthis.updateMetrics(startTime, allErrors.length);\r\n\r\n\t\t\tconst duration = Date.now() - startTime;\r\n\t\t\tconsole.log(`[DIAGNOSTICS] Returning ${diagnostics.length} diagnostics in ${duration}ms`);\r\n\t\t\treturn diagnostics;\r\n\r\n\t\t} catch (e) {\r\n\t\t\tconsole.error('[DIAGNOSTICS] Unexpected error:', e);\r\n\t\t\tif (e instanceof Error) {\r\n\t\t\t\tconsole.error('[DIAGNOSTICS] Stack:', e.stack);\r\n\t\t\t}\r\n\r\n\t\t\tthis.serverMetrics.totalValidations++;\r\n\r\n\t\t\treturn [{\r\n\t\t\t\tseverity: DiagnosticSeverity.Error,\r\n\t\t\t\trange: {\r\n\t\t\t\t\tstart: { line: 0, character: 0 },\r\n\t\t\t\t\tend: { line: 0, character: 0 }\r\n\t\t\t\t},\r\n\t\t\t\tmessage: `LSP internal error: ${e instanceof Error ? e.message : 'Unknown error'}. Please check the output console.`,\r\n\t\t\t\tsource: 'kemet-lsp'\r\n\t\t\t}];\r\n\t\t}\r\n\t}\r\n\r\n\tprivate determineProject(uri: string): { project: ProjectLib.Project; modulePath?: string } {\r\n\t\tif (uri.startsWith('file://')) {\r\n\t\t\ttry {\r\n\t\t\t\tconst filePath = fileURLToPath(uri);\r\n\t\t\t\tconst relative = Path.relative(this.projects.main.rootPath, filePath);\r\n\t\t\t\tconst isInProject = !relative.startsWith('..') && !Path.isAbsolute(relative);\r\n\r\n\t\t\t\tif (isInProject && filePath.endsWith('.k')) {\r\n\t\t\t\t\tconsole.log(`[DIAGNOSTICS] Using main project for: ${filePath}`);\r\n\t\t\t\t\treturn { project: this.projects.main, modulePath: filePath };\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\tconsole.warn('[DIAGNOSTICS] Error determining project:', e);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconsole.log('[DIAGNOSTICS] Using anonymous project');\r\n\t\treturn { project: this.projects.anonymous };\r\n\t}\r\n\r\n\tprivate convertKemetDiagnostic(\r\n\t\tkemetDiag: KemetDiagnostic,\r\n\t\tdocument: TextDocument,\r\n\t\tsettings: any\r\n\t): Diagnostic | null {\r\n\t\ttry {\r\n\t\t\tconst span: Span = kemetDiag.targetSpan ?? kemetDiag.contextSpan ?? { start: 0, end: 0 };\r\n\r\n\t\t\tlet severity: DiagnosticSeverity;\r\n\t\t\tif (kemetDiag.kind === 'error') {\r\n\t\t\t\tseverity = DiagnosticSeverity.Error;\r\n\t\t\t} else if (kemetDiag.kind === 'warning') {\r\n\t\t\t\tif (settings.showWarnings === false) return null;\r\n\t\t\t\tseverity = DiagnosticSeverity.Warning;\r\n\t\t\t} else {\r\n\t\t\t\tif (settings.showInfos === false) return null;\r\n\t\t\t\tseverity = DiagnosticSeverity.Information;\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\tseverity,\r\n\t\t\t\trange: {\r\n\t\t\t\t\tstart: document.positionAt(span.start),\r\n\t\t\t\t\tend: document.positionAt(span.end),\r\n\t\t\t\t},\r\n\t\t\t\tmessage: kemetDiag.msg,\r\n\t\t\t\tsource: 'kemet-lsp',\r\n\t\t\t\tcode: kemetDiag.code\r\n\t\t\t};\r\n\t\t} catch (e) {\r\n\t\t\tconsole.warn('[DIAGNOSTICS] Error converting diagnostic:', e);\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate updateMetrics(startTime: number, errorCount: number): void {\r\n\t\tthis.serverMetrics.totalValidations++;\r\n\t\tthis.serverMetrics.totalErrors += errorCount;\r\n\t\tconst duration = Date.now() - startTime;\r\n\t\tthis.serverMetrics.averageValidationTime =\r\n\t\t\t(this.serverMetrics.averageValidationTime * (this.serverMetrics.totalValidations - 1) + duration) /\r\n\t\t\tthis.serverMetrics.totalValidations;\r\n\t}\r\n\r\n\tpublic clearInflightValidation(uri: string): void {\r\n\t\tthis.inFlightValidations.delete(uri);\r\n\t}\r\n}","// features/completion.ts — Smart autocomplete with scope-aware suggestions\r\n\r\nimport {\r\n\tConnection,\r\n\tTextDocuments,\r\n\tCompletionItem,\r\n\tCompletionItemKind,\r\n\tTextDocumentPositionParams,\r\n} from 'vscode-languageserver';\r\nimport { TextDocument } from 'vscode-languageserver-textdocument';\r\nimport * as ProjectLib from '@je-es/project';\r\nimport { fileURLToPath } from 'url';\r\nimport * as Path from 'path';\r\n\r\n// ════════════════════════════════════════ TYPES ════════════════════════════════════════\r\n\r\ninterface CompletionContext {\r\n\tisInFunction: boolean;\r\n\tisInStruct: boolean;\r\n\tisInEnum: boolean;\r\n\tisAfterDot: boolean;\r\n\tisAfterUse: boolean;\r\n\tisAfterLet: boolean;\r\n\tisAfterFn: boolean;\r\n\tisAfterDef: boolean;\r\n\tpreviousToken: string;\r\n\tcurrentScope: string;\r\n}\r\n\r\n// ════════════════════════════════════════ CONSTANTS ════════════════════════════════════════\r\n\r\nconst KEYWORDS = {\r\n\tdeclarations: ['let', 'fn', 'def', 'use', 'pub', 'test'],\r\n\ttypes: ['i8', 'i16', 'i32', 'i64', 'isize', 'u8', 'u16', 'u32', 'u64', 'usize',\r\n\t        'f16', 'f32', 'f64', 'bool', 'str', 'char', 'void', 'any', 'type',\r\n\t        'struct', 'enum', 'errset', 'null_t', 'und_t'],\r\n\tcontrolFlow: ['if', 'else', 'switch', 'case', 'default', 'for', 'while',\r\n\t              'break', 'continue', 'return', 'defer', 'throw'],\r\n\tmodifiers: ['mut', 'pub', 'static', 'inline', 'comptime'],\r\n\toperators: ['as', 'typeof', 'sizeof', 'try', 'catch', 'orelse'],\r\n\tliterals: ['true', 'false', 'null', 'und'],\r\n\tbuiltins: ['@print', '@i', 'self']\r\n};\r\n\r\nconst KEYWORD_DOCS: { [key: string]: { detail: string, documentation: string } } = {\r\n\t'fn': { detail: 'fn', documentation: 'Declare a function\\nExample: fn name(param: type) -> type { }' },\r\n\t'let': { detail: 'let', documentation: 'Declare a variable\\nExample: let name: type = value;' },\r\n\t'pub': { detail: 'pub', documentation: 'Make item public (exported from module)' },\r\n\t'use': { detail: 'use', documentation: 'Import from another module\\nExample: use symbol from \"path\"' },\r\n\t'def': { detail: 'def', documentation: 'Define a type alias\\nExample: def MyType = i32' },\r\n\t'struct': { detail: 'struct', documentation: 'Declare a structure\\nExample: struct { field: type }' },\r\n\t'enum': { detail: 'enum', documentation: 'Declare an enumeration\\nExample: enum { Variant }' },\r\n\t'if': { detail: 'if', documentation: 'Conditional statement\\nExample: if condition { }' },\r\n\t'else': { detail: 'else', documentation: 'Alternative branch for if' },\r\n\t'while': { detail: 'while', documentation: 'Loop statement\\nExample: while condition { }' },\r\n\t'for': { detail: 'for', documentation: 'For-range loop\\nExample: for 0..10 { }' },\r\n\t'return': { detail: 'return', documentation: 'Return from function\\nExample: return value;' },\r\n\t'mut': { detail: 'mut', documentation: 'Mutable modifier for variables' },\r\n\t'try': { detail: 'try', documentation: 'Try an expression that may error' },\r\n\t'catch': { detail: 'catch', documentation: 'Catch errors from try expression' },\r\n};\r\n\r\n// ════════════════════════════════════════ COMPLETION HANDLER ════════════════════════════════════════\r\n\r\nexport class CompletionHandler {\r\n\tprivate connection: Connection;\r\n\tprivate documents: TextDocuments<TextDocument>;\r\n\tprivate projects: { main: ProjectLib.Project; anonymous: ProjectLib.Project };\r\n\r\n\tconstructor(\r\n\t\tconnection: Connection,\r\n\t\tdocuments: TextDocuments<TextDocument>,\r\n\t\tprojects: { main: ProjectLib.Project; anonymous: ProjectLib.Project }\r\n\t) {\r\n\t\tthis.connection = connection;\r\n\t\tthis.documents = documents;\r\n\t\tthis.projects = projects;\r\n\r\n\t\tthis.setupHandlers();\r\n\t}\r\n\r\n\tprivate setupHandlers(): void {\r\n\t\tthis.connection.onCompletion((params: TextDocumentPositionParams) => {\r\n\t\t\treturn this.handleCompletion(params);\r\n\t\t});\r\n\r\n\t\tthis.connection.onCompletionResolve((item: CompletionItem) => {\r\n\t\t\treturn this.handleCompletionResolve(item);\r\n\t\t});\r\n\t}\r\n\r\n\tprivate handleCompletion(params: TextDocumentPositionParams): CompletionItem[] {\r\n\t\ttry {\r\n\t\t\tconsole.log('[COMPLETION] Request received at position:', params.position);\r\n\r\n\t\t\tconst document = this.documents.get(params.textDocument.uri);\r\n\t\t\tif (!document) {\r\n\t\t\t\tconsole.warn('[COMPLETION] Document not found');\r\n\t\t\t\treturn [];\r\n\t\t\t}\r\n\r\n\t\t\tconst context = this.analyzeCompletionContext(document, params);\r\n\t\t\tconsole.log('[COMPLETION] Context:', JSON.stringify(context, null, 2));\r\n\r\n\t\t\tconst items: CompletionItem[] = [];\r\n\r\n\t\t\t// Don't suggest anything after dot (member access - needs more context)\r\n\t\t\tif (!context.isAfterDot) {\r\n\t\t\t\t// Add keywords based on context\r\n\t\t\t\titems.push(...this.getKeywordCompletions(context));\r\n\r\n\t\t\t\t// Add builtins\r\n\t\t\t\titems.push(...this.getBuiltinCompletions());\r\n\r\n\t\t\t\t// Add symbols from scope manager\r\n\t\t\t\titems.push(...this.getScopeSymbolCompletions(document, params));\r\n\t\t\t}\r\n\r\n\t\t\tconsole.log(`[COMPLETION] Returning ${items.length} total items`);\r\n\t\t\treturn items;\r\n\t\t} catch (e) {\r\n\t\t\tconsole.error('[COMPLETION] Error:', e);\r\n\t\t\tif (e instanceof Error) {\r\n\t\t\t\tconsole.error('[COMPLETION] Stack:', e.stack);\r\n\t\t\t}\r\n\t\t\treturn [];\r\n\t\t}\r\n\t}\r\n\r\n\tprivate handleCompletionResolve(item: CompletionItem): CompletionItem {\r\n\t\ttry {\r\n\t\t\t// Add detailed documentation for keywords\r\n\t\t\tif (item.data && typeof item.data === 'string' && item.data.startsWith('keyword_')) {\r\n\t\t\t\tconst keyword = item.label;\r\n\t\t\t\tconst doc = KEYWORD_DOCS[keyword];\r\n\t\t\t\tif (doc) {\r\n\t\t\t\t\titem.detail = doc.detail;\r\n\t\t\t\t\titem.documentation = doc.documentation;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn item;\r\n\t\t} catch (e) {\r\n\t\t\tconsole.error('[COMPLETION] CompletionResolve error:', e);\r\n\t\t\treturn item;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate analyzeCompletionContext(\r\n\t\tdocument: TextDocument,\r\n\t\tposition: TextDocumentPositionParams\r\n\t): CompletionContext {\r\n\t\tconst text = document.getText();\r\n\t\tconst offset = document.offsetAt(position.position);\r\n\t\tconst lineText = text.substring(\r\n\t\t\tdocument.offsetAt({ line: position.position.line, character: 0 }),\r\n\t\t\toffset\r\n\t\t);\r\n\r\n\t\t// Extract previous tokens\r\n\t\tconst tokens = lineText.trim().split(/\\s+/);\r\n\t\tconst previousToken = tokens.length > 1 ? tokens[tokens.length - 2] : '';\r\n\t\tconst currentToken = tokens[tokens.length - 1] || '';\r\n\r\n\t\treturn {\r\n\t\t\tisInFunction: /\\bfn\\b/.test(text.substring(0, offset)),\r\n\t\t\tisInStruct: /\\bstruct\\s*\\{/.test(text.substring(0, offset)),\r\n\t\t\tisInEnum: /\\benum\\s*\\{/.test(text.substring(0, offset)),\r\n\t\t\tisAfterDot: currentToken.endsWith('.') || previousToken === '.',\r\n\t\t\tisAfterUse: previousToken === 'use',\r\n\t\t\tisAfterLet: previousToken === 'let',\r\n\t\t\tisAfterFn: previousToken === 'fn',\r\n\t\t\tisAfterDef: previousToken === 'def',\r\n\t\t\tpreviousToken,\r\n\t\t\tcurrentScope: 'global'\r\n\t\t};\r\n\t}\r\n\r\n\tprivate getKeywordCompletions(context: CompletionContext): CompletionItem[] {\r\n\t\tconst items: CompletionItem[] = [];\r\n\t\tlet keywords: string[] = [];\r\n\r\n\t\t// Context-aware keyword suggestions\r\n\t\tif (context.isAfterLet) {\r\n\t\t\tkeywords = ['mut', ...KEYWORDS.types];\r\n\t\t} else if (context.isAfterFn || context.isAfterDef) {\r\n\t\t\treturn [];\r\n\t\t} else if (context.isAfterUse) {\r\n\t\t\treturn [];\r\n\t\t} else if (context.isInFunction) {\r\n\t\t\tkeywords = [\r\n\t\t\t\t...KEYWORDS.controlFlow,\r\n\t\t\t\t...KEYWORDS.declarations.filter(k => k !== 'pub'),\r\n\t\t\t\t...KEYWORDS.operators,\r\n\t\t\t\t...KEYWORDS.literals\r\n\t\t\t];\r\n\t\t} else {\r\n\t\t\tkeywords = [\r\n\t\t\t\t...KEYWORDS.declarations,\r\n\t\t\t\t...KEYWORDS.types,\r\n\t\t\t\t...KEYWORDS.controlFlow,\r\n\t\t\t\t...KEYWORDS.modifiers,\r\n\t\t\t\t...KEYWORDS.operators,\r\n\t\t\t\t...KEYWORDS.literals\r\n\t\t\t];\r\n\t\t}\r\n\r\n\t\tkeywords.forEach((keyword, index) => {\r\n\t\t\tconst item: CompletionItem = {\r\n\t\t\t\tlabel: keyword,\r\n\t\t\t\tkind: KEYWORDS.types.includes(keyword)\r\n\t\t\t\t\t? CompletionItemKind.TypeParameter\r\n\t\t\t\t\t: KEYWORDS.controlFlow.includes(keyword)\r\n\t\t\t\t\t? CompletionItemKind.Keyword\r\n\t\t\t\t\t: CompletionItemKind.Keyword,\r\n\t\t\t\tdata: `keyword_${index}`,\r\n\t\t\t\tsortText: `0_${keyword}`\r\n\t\t\t};\r\n\t\t\titems.push(item);\r\n\t\t});\r\n\r\n\t\treturn items;\r\n\t}\r\n\r\n\tprivate getBuiltinCompletions(): CompletionItem[] {\r\n\t\treturn KEYWORDS.builtins.map((builtin, index) => ({\r\n\t\t\tlabel: builtin,\r\n\t\t\tkind: builtin === 'self' ? CompletionItemKind.Variable : CompletionItemKind.Function,\r\n\t\t\tdata: `builtin_${index}`,\r\n\t\t\tdetail: builtin === '@print' ? 'fn(str) -> void' : undefined,\r\n\t\t\tsortText: `1_${builtin}`\r\n\t\t}));\r\n\t}\r\n\r\n\tprivate getScopeSymbolCompletions(\r\n\t\tdocument: TextDocument,\r\n\t\tposition: TextDocumentPositionParams\r\n\t): CompletionItem[] {\r\n\t\ttry {\r\n\t\t\tconst uri = position.textDocument.uri;\r\n\t\t\tconst text = document.getText();\r\n\r\n\t\t\t// Determine which project to use\r\n\t\t\tconst { project, modulePath, currentModuleName } = this.determineProject(uri);\r\n\r\n\t\t\t// Run fresh lint with current content\r\n\t\t\tconsole.log('[COMPLETION] Running lint for autocomplete...');\r\n\t\t\tconst startLint = Date.now();\r\n\t\t\tconst result = project.lint(text, modulePath);\r\n\t\t\tconsole.log(`[COMPLETION] Lint completed in ${Date.now() - startLint}ms`);\r\n\r\n\t\t\t// Access scope manager\r\n\t\t\tconst scopeManager = this.getScopeManager(project);\r\n\t\t\tif (!scopeManager) {\r\n\t\t\t\tconsole.error('[COMPLETION] Could not access scope manager');\r\n\t\t\t\treturn [];\r\n\t\t\t}\r\n\r\n\t\t\tconst allSymbols = scopeManager.getAllSymbols();\r\n\t\t\tconsole.log(`[COMPLETION] Found ${allSymbols.length} total symbols`);\r\n\r\n\t\t\tconst items: CompletionItem[] = [];\r\n\t\t\tconst seenSymbols = new Set<string>();\r\n\r\n\t\t\tfor (const symbol of allSymbols) {\r\n\t\t\t\t// Skip duplicates and synthetic symbols\r\n\t\t\t\tif (seenSymbols.has(symbol.name) || symbol.metadata?.isSynthetic) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Filter symbols appropriately\r\n\t\t\t\tconst symbolModule = symbol.module || '';\r\n\t\t\t\tconst isFromCurrentModule =\r\n\t\t\t\t\tsymbolModule === modulePath ||\r\n\t\t\t\t\tsymbolModule === currentModuleName ||\r\n\t\t\t\t\tsymbolModule === '';\r\n\r\n\t\t\t\tconst isImport = symbol.kind === 'Use';\r\n\t\t\t\tconst isBuiltin = symbol.metadata?.isBuiltin === true;\r\n\t\t\t\tconst isPublicExported = symbol.isExported && symbol.visibility.kind === 'Public';\r\n\r\n\t\t\t\tif (!isFromCurrentModule && !isImport && !isBuiltin && !isPublicExported) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tseenSymbols.add(symbol.name);\r\n\r\n\t\t\t\tconst item: CompletionItem = {\r\n\t\t\t\t\tlabel: symbol.name,\r\n\t\t\t\t\tkind: this.getCompletionItemKind(symbol.kind),\r\n\t\t\t\t\tdata: `symbol_${symbol.id}`,\r\n\t\t\t\t\tdetail: this.getSymbolDetail(symbol),\r\n\t\t\t\t\tdocumentation: this.getSymbolDocumentation(symbol),\r\n\t\t\t\t\tsortText: `2_${symbol.name}`\r\n\t\t\t\t};\r\n\r\n\t\t\t\titems.push(item);\r\n\t\t\t}\r\n\r\n\t\t\tconsole.log(`[COMPLETION] Returning ${items.length} symbols`);\r\n\t\t\treturn items;\r\n\r\n\t\t} catch (error) {\r\n\t\t\tconsole.error('[COMPLETION] Error getting scope symbols:', error);\r\n\t\t\treturn [];\r\n\t\t}\r\n\t}\r\n\r\n\tprivate determineProject(uri: string): {\r\n\t\tproject: ProjectLib.Project;\r\n\t\tmodulePath?: string;\r\n\t\tcurrentModuleName: string\r\n\t} {\r\n\t\tif (uri.startsWith('file://')) {\r\n\t\t\ttry {\r\n\t\t\t\tconst filePath = fileURLToPath(uri);\r\n\t\t\t\tconst relative = Path.relative(this.projects.main.rootPath, filePath);\r\n\t\t\t\tconst isInProject = !relative.startsWith('..') && !Path.isAbsolute(relative);\r\n\r\n\t\t\t\tif (isInProject && filePath.endsWith('.k')) {\r\n\t\t\t\t\tconst moduleName = Path.basename(filePath, '.k');\r\n\t\t\t\t\tconsole.log(`[COMPLETION] Using main project, module: ${moduleName}`);\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tproject: this.projects.main,\r\n\t\t\t\t\t\tmodulePath: filePath,\r\n\t\t\t\t\t\tcurrentModuleName: moduleName\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\tconsole.warn('[COMPLETION] Error determining project:', e);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconsole.log('[COMPLETION] Using anonymous project');\r\n\t\treturn {\r\n\t\t\tproject: this.projects.anonymous,\r\n\t\t\tcurrentModuleName: 'main'\r\n\t\t};\r\n\t}\r\n\r\n\tprivate getScopeManager(project: ProjectLib.Project): any {\r\n\t\t// Try multiple ways to access the analyzer\r\n\t\tif (project.analyzer) {\r\n\t\t\treturn project.analyzer.config?.services?.scopeManager;\r\n\t\t}\r\n\r\n\t\tconst analyzer = (project as any)._analyzer || (project as any).analyzer;\r\n\t\tif (analyzer) {\r\n\t\t\treturn analyzer.config?.services?.scopeManager;\r\n\t\t}\r\n\r\n\t\tif (typeof (project as any).getScopeManager === 'function') {\r\n\t\t\treturn (project as any).getScopeManager();\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n\r\n\tprivate getCompletionItemKind(symbolKind: string): CompletionItemKind {\r\n\t\tswitch (symbolKind) {\r\n\t\t\tcase 'Function': return CompletionItemKind.Function;\r\n\t\t\tcase 'Variable': return CompletionItemKind.Variable;\r\n\t\t\tcase 'Parameter': return CompletionItemKind.Variable;\r\n\t\t\tcase 'Definition': return CompletionItemKind.Class;\r\n\t\t\tcase 'StructField': return CompletionItemKind.Field;\r\n\t\t\tcase 'EnumVariant': return CompletionItemKind.EnumMember;\r\n\t\t\tcase 'Use': return CompletionItemKind.Module;\r\n\t\t\tdefault: return CompletionItemKind.Text;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate getSymbolDetail(symbol: any): string {\r\n\t\tif (symbol.type) {\r\n\t\t\treturn `${symbol.kind}: ${this.formatType(symbol.type)}`;\r\n\t\t}\r\n\t\treturn symbol.kind;\r\n\t}\r\n\r\n\tprivate getSymbolDocumentation(symbol: any): string {\r\n\t\tconst parts: string[] = [];\r\n\r\n\t\tif (symbol.visibility.kind === 'Public') parts.push('public');\r\n\t\tif (symbol.mutability.kind === 'Mutable') parts.push('mut');\r\n\t\tif (symbol.metadata?.callable) parts.push('callable');\r\n\t\tif (symbol.isExported) parts.push('exported');\r\n\r\n\t\treturn parts.join(', ');\r\n\t}\r\n\r\n\tprivate formatType(type: any): string {\r\n\t\tif (!type || !type.kind) return 'unknown';\r\n\r\n\t\tswitch (type.kind) {\r\n\t\t\tcase 'i8': case 'i16': case 'i32': case 'i64':\r\n\t\t\tcase 'u8': case 'u16': case 'u32': case 'u64':\r\n\t\t\tcase 'f32': case 'f64':\r\n\t\t\tcase 'bool': case 'void': case 'str':\r\n\t\t\t\treturn type.kind;\r\n\t\t\tcase 'pointer':\r\n\t\t\t\treturn `*${this.formatType(type.getPointer()?.target)}`;\r\n\t\t\tcase 'array':\r\n\t\t\t\treturn `[]${this.formatType(type.getArray()?.target)}`;\r\n\t\t\tcase 'optional':\r\n\t\t\t\treturn `?${this.formatType(type.getOptional()?.target)}`;\r\n\t\t\tcase 'function':\r\n\t\t\t\treturn 'fn';\r\n\t\t\tcase 'struct':\r\n\t\t\t\treturn 'struct';\r\n\t\t\tcase 'enum':\r\n\t\t\t\treturn 'enum';\r\n\t\t\tdefault:\r\n\t\t\t\treturn type.kind;\r\n\t\t}\r\n\t}\r\n}","// features/hover.ts — Hover information provider\r\n\r\nimport {\r\n\tConnection,\r\n\tTextDocuments,\r\n\tHover,\r\n\tMarkupKind,\r\n\tTextDocumentPositionParams,\r\n} from 'vscode-languageserver';\r\nimport { TextDocument } from 'vscode-languageserver-textdocument';\r\nimport * as ProjectLib from '@je-es/project';\r\nimport { Span } from '@je-es/parser';\r\nimport { fileURLToPath } from 'url';\r\nimport * as Path from 'path';\r\n\r\n// ════════════════════════════════════════ CONSTANTS ════════════════════════════════════════\r\n\r\nconst KEYWORDS = {\r\n\tdeclarations: ['let', 'fn', 'def', 'use', 'pub', 'test'],\r\n\ttypes: ['i8', 'i16', 'i32', 'i64', 'isize', 'u8', 'u16', 'u32', 'u64', 'usize',\r\n\t        'f16', 'f32', 'f64', 'f80', 'f128', 'bool', 'str', 'char', 'void', 'any', \r\n\t        'type', 'struct', 'enum', 'errset', 'null_t', 'und_t', 'err', 'cint', 'cflt'],\r\n\tcontrolFlow: ['if', 'else', 'switch', 'case', 'default', 'for', 'while',\r\n\t              'break', 'continue', 'return', 'defer', 'throw'],\r\n\tmodifiers: ['mut', 'pub', 'static', 'inline', 'comptime'],\r\n\toperators: ['as', 'typeof', 'sizeof', 'try', 'catch', 'orelse'],\r\n\tliterals: ['true', 'false', 'null', 'und'],\r\n};\r\n\r\ninterface KeywordDoc {\r\n\tsignature: string;\r\n\tdescription: string;\r\n\texample?: string;\r\n}\r\n\r\nconst KEYWORD_DOCS: { [key: string]: KeywordDoc } = {\r\n\t// Declarations\r\n\t'let': { signature: 'let [pub] [mut] name: type = value', description: 'Declare a variable', example: 'let mut counter: i32 = 0;' },\r\n\t'fn': { signature: 'fn [pub] name(params) -> type { }', description: 'Declare a function', example: 'pub fn add(a: i32, b: i32) -> i32 { return a + b; }' },\r\n\t'def': { signature: 'def [pub] Name = type', description: 'Define a type alias', example: 'def MyInt = i32;' },\r\n\t'use': { signature: 'use symbol [as alias] from \"path\"', description: 'Import a symbol from another module', example: 'use MyType as T from \"./types.k\";' },\r\n\t\r\n\t// Type keywords\r\n\t'struct': { signature: 'struct { fields... }', description: 'Define a structure type', example: 'struct { x: i32, y: i32 }' },\r\n\t'enum': { signature: 'enum { Variant1, Variant2, ... }', description: 'Define an enumeration type', example: 'enum { Some: i32, None }' },\r\n\t'errset': { signature: 'errset { Error1, Error2, ... }', description: 'Define an error set type', example: 'errset { FileNotFound, AccessDenied }' },\r\n\t\r\n\t// Primitive types\r\n\t'i8': { signature: 'i8', description: 'Signed 8-bit integer (-128 to 127)' },\r\n\t'i16': { signature: 'i16', description: 'Signed 16-bit integer (-32,768 to 32,767)' },\r\n\t'i32': { signature: 'i32', description: 'Signed 32-bit integer (-2,147,483,648 to 2,147,483,647)' },\r\n\t'i64': { signature: 'i64', description: 'Signed 64-bit integer' },\r\n\t'u8': { signature: 'u8', description: 'Unsigned 8-bit integer (0 to 255)' },\r\n\t'u16': { signature: 'u16', description: 'Unsigned 16-bit integer (0 to 65,535)' },\r\n\t'u32': { signature: 'u32', description: 'Unsigned 32-bit integer (0 to 4,294,967,295)' },\r\n\t'u64': { signature: 'u64', description: 'Unsigned 64-bit integer' },\r\n\t'f32': { signature: 'f32', description: 'Single-precision 32-bit floating point' },\r\n\t'f64': { signature: 'f64', description: 'Double-precision 64-bit floating point' },\r\n\t'bool': { signature: 'bool', description: 'Boolean type (true or false)' },\r\n\t'str': { signature: 'str', description: 'String type (alias for []u8)' },\r\n\t'void': { signature: 'void', description: 'Void type (represents no value)' },\r\n\t\r\n\t// Control flow\r\n\t'if': { signature: 'if condition stmt [else stmt]', description: 'Conditional expression', example: 'if x > 0 { @print(\"positive\"); }' },\r\n\t'while': { signature: 'while condition stmt', description: 'Loop while condition is true', example: 'while i < 10 { i = i + 1; }' },\r\n\t'for': { signature: 'for range stmt', description: 'Iterate over a range', example: 'for 0..10 { @print(@i); }' },\r\n\t'return': { signature: 'return [expr]', description: 'Return from a function', example: 'return x + y;' },\r\n\t\r\n\t// Modifiers\r\n\t'mut': { signature: 'mut', description: 'Make a variable mutable', example: 'let mut counter = 0;' },\r\n\t'pub': { signature: 'pub', description: 'Make a symbol public (exported)', example: 'pub let API_KEY = \"...\";' },\r\n\t\r\n\t// Operators\r\n\t'try': { signature: 'try expr', description: 'Try an expression that may error', example: 'let result = try riskyOperation();' },\r\n\t'catch': { signature: 'expr catch stmt', description: 'Handle errors from try expression', example: 'try riskyOp() catch { @print(\"error\"); }' },\r\n\t\r\n\t// Literals\r\n\t'true': { signature: 'true', description: 'Boolean true value' },\r\n\t'false': { signature: 'false', description: 'Boolean false value' },\r\n\t'null': { signature: 'null', description: 'Null value' },\r\n\t'und': { signature: 'und', description: 'Undefined value' },\r\n};\r\n\r\nconst BUILTIN_DOCS: { [key: string]: string } = {\r\n\t'@print': '```kemet\\nfn @print(text: str) -> void\\n```\\n\\nBuilt-in function to print text to output.',\r\n\t'@i': '```kemet\\n@i: usize\\n```\\n\\nLoop iteration index (available in `for` loops).',\r\n\t'self': '```kemet\\nself\\n```\\n\\nReference to the current instance (available in struct methods).'\r\n};\r\n\r\n// ════════════════════════════════════════ HOVER HANDLER ════════════════════════════════════════\r\n\r\nexport class HoverHandler {\r\n\tprivate connection: Connection;\r\n\tprivate documents: TextDocuments<TextDocument>;\r\n\tprivate projects: { main: ProjectLib.Project; anonymous: ProjectLib.Project };\r\n\r\n\tconstructor(\r\n\t\tconnection: Connection,\r\n\t\tdocuments: TextDocuments<TextDocument>,\r\n\t\tprojects: { main: ProjectLib.Project; anonymous: ProjectLib.Project }\r\n\t) {\r\n\t\tthis.connection = connection;\r\n\t\tthis.documents = documents;\r\n\t\tthis.projects = projects;\r\n\r\n\t\tthis.setupHandlers();\r\n\t}\r\n\r\n\tprivate setupHandlers(): void {\r\n\t\tthis.connection.onHover((params: TextDocumentPositionParams) => {\r\n\t\t\treturn this.handleHover(params);\r\n\t\t});\r\n\t}\r\n\r\n\tprivate handleHover(params: TextDocumentPositionParams): Hover | null {\r\n\t\ttry {\r\n\t\t\tconsole.log('[HOVER] Request received at position:', params.position);\r\n\r\n\t\t\tconst document = this.documents.get(params.textDocument.uri);\r\n\t\t\tif (!document) {\r\n\t\t\t\tconsole.warn('[HOVER] Document not found');\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tconst wordInfo = this.getWordAndSpanAtPosition(document, params.position);\r\n\t\t\tif (!wordInfo) {\r\n\t\t\t\tconsole.log('[HOVER] No word at position');\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tconst { word, span } = wordInfo;\r\n\t\t\tconsole.log(`[HOVER] Word: \"${word}\"`);\r\n\r\n\t\t\t// Check if it's a keyword\r\n\t\t\tconst allKeywords = [\r\n\t\t\t\t...KEYWORDS.declarations,\r\n\t\t\t\t...KEYWORDS.types,\r\n\t\t\t\t...KEYWORDS.controlFlow,\r\n\t\t\t\t...KEYWORDS.modifiers,\r\n\t\t\t\t...KEYWORDS.operators,\r\n\t\t\t\t...KEYWORDS.literals\r\n\t\t\t];\r\n\r\n\t\t\tif (allKeywords.includes(word)) {\r\n\t\t\t\tconsole.log(`[HOVER] Found keyword: ${word}`);\r\n\t\t\t\treturn this.getKeywordHover(word);\r\n\t\t\t}\r\n\r\n\t\t\t// Check if it's a builtin\r\n\t\t\tif (word.startsWith('@') || word === 'self') {\r\n\t\t\t\tconst doc = BUILTIN_DOCS[word];\r\n\t\t\t\tif (doc) {\r\n\t\t\t\t\tconsole.log(`[HOVER] Found builtin: ${word}`);\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tcontents: {\r\n\t\t\t\t\t\t\tkind: MarkupKind.Markdown,\r\n\t\t\t\t\t\t\tvalue: doc\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Look up symbol in scope manager\r\n\t\t\treturn this.getSymbolHover(document, params, word, span);\r\n\r\n\t\t} catch (error) {\r\n\t\t\tconsole.error('[HOVER] Error:', error);\r\n\t\t\tif (error instanceof Error) {\r\n\t\t\t\tconsole.error('[HOVER] Stack:', error.stack);\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate getSymbolHover(\r\n\t\tdocument: TextDocument,\r\n\t\tparams: TextDocumentPositionParams,\r\n\t\tword: string,\r\n\t\tspan: Span\r\n\t): Hover | null {\r\n\t\ttry {\r\n\t\t\tconst uri = params.textDocument.uri;\r\n\t\t\tconst text = document.getText();\r\n\r\n\t\t\t// Determine which project to use\r\n\t\t\tconst { project, modulePath, currentModuleName } = this.determineProject(uri);\r\n\r\n\t\t\t// Run lint to get fresh scope manager state\r\n\t\t\tconsole.log('[HOVER] Running lint...');\r\n\t\t\tconst result = project.lint(text, modulePath);\r\n\r\n\t\t\t// Access scope manager\r\n\t\t\tconst scopeManager = this.getScopeManager(project);\r\n\t\t\tif (!scopeManager) {\r\n\t\t\t\tconsole.warn('[HOVER] Could not access scope manager');\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tconsole.log(`[HOVER] Looking up \"${word}\" at span:`, span);\r\n\t\t\tconsole.log(`[HOVER] Current module: ${currentModuleName}`);\r\n\r\n\t\t\t// Use LSP-aware symbol lookup\r\n\t\t\tconst symbol = scopeManager.lookupSymbolFromLSP(word, span, currentModuleName);\r\n\r\n\t\t\tif (!symbol) {\r\n\t\t\t\tconsole.log(`[HOVER] Symbol \"${word}\" not found`);\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tconsole.log(`[HOVER] Found symbol: ${word} (${symbol.kind})`);\r\n\t\t\treturn this.formatSymbolHover(symbol);\r\n\r\n\t\t} catch (error) {\r\n\t\t\tconsole.error('[HOVER] Error getting symbol hover:', error);\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate getWordAndSpanAtPosition(\r\n\t\tdocument: TextDocument,\r\n\t\tposition: { line: number; character: number }\r\n\t): { word: string; span: Span } | null {\r\n\t\tconst text = document.getText();\r\n\t\tconst offset = document.offsetAt(position);\r\n\r\n\t\t// Find word boundaries\r\n\t\tlet start = offset;\r\n\t\tlet end = offset;\r\n\r\n\t\t// Go backwards to find start\r\n\t\twhile (start > 0 && /[a-zA-Z0-9_@]/.test(text[start - 1])) {\r\n\t\t\tstart--;\r\n\t\t}\r\n\r\n\t\t// Go forwards to find end\r\n\t\twhile (end < text.length && /[a-zA-Z0-9_@]/.test(text[end])) {\r\n\t\t\tend++;\r\n\t\t}\r\n\r\n\t\tif (start === end) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tconst word = text.substring(start, end);\r\n\t\tconst span = { start, end };\r\n\r\n\t\treturn { word, span };\r\n\t}\r\n\r\n\tprivate determineProject(uri: string): { \r\n\t\tproject: ProjectLib.Project; \r\n\t\tmodulePath?: string; \r\n\t\tcurrentModuleName: string \r\n\t} {\r\n\t\tif (uri.startsWith('file://')) {\r\n\t\t\ttry {\r\n\t\t\t\tconst filePath = fileURLToPath(uri);\r\n\t\t\t\tconst relative = Path.relative(this.projects.main.rootPath, filePath);\r\n\t\t\t\tconst isInProject = !relative.startsWith('..') && !Path.isAbsolute(relative);\r\n\r\n\t\t\t\tif (isInProject && filePath.endsWith('.k')) {\r\n\t\t\t\t\tconst moduleName = Path.basename(filePath, '.k');\r\n\t\t\t\t\treturn { \r\n\t\t\t\t\t\tproject: this.projects.main, \r\n\t\t\t\t\t\tmodulePath: filePath, \r\n\t\t\t\t\t\tcurrentModuleName: moduleName \r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\tconsole.warn('[HOVER] Error determining project:', e);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn { \r\n\t\t\tproject: this.projects.anonymous, \r\n\t\t\tcurrentModuleName: 'main' \r\n\t\t};\r\n\t}\r\n\r\n\tprivate getScopeManager(project: ProjectLib.Project): any {\r\n\t\tif (project.analyzer) {\r\n\t\t\treturn project.analyzer.config?.services?.scopeManager;\r\n\t\t}\r\n\r\n\t\tconst analyzer = (project as any)._analyzer || (project as any).analyzer;\r\n\t\tif (analyzer) {\r\n\t\t\treturn analyzer.config?.services?.scopeManager;\r\n\t\t}\r\n\r\n\t\tif (typeof (project as any).getScopeManager === 'function') {\r\n\t\t\treturn (project as any).getScopeManager();\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n\r\n\tprivate getKeywordHover(keyword: string): Hover | null {\r\n\t\tconst doc = KEYWORD_DOCS[keyword];\r\n\t\tif (!doc) return null;\r\n\r\n\t\tconst parts: string[] = [];\r\n\t\tconst keywordType = KEYWORDS.types.includes(keyword) ? 'type' : 'keyword';\r\n\t\tparts.push(`**${keyword}** (${keywordType})`);\r\n\t\tparts.push('');\r\n\t\tparts.push('```kemet');\r\n\t\tparts.push(doc.signature);\r\n\t\tparts.push('```');\r\n\t\tparts.push('');\r\n\t\tparts.push(doc.description);\r\n\r\n\t\tif (doc.example) {\r\n\t\t\tparts.push('');\r\n\t\t\tparts.push('**Example:**');\r\n\t\t\tparts.push('```kemet');\r\n\t\t\tparts.push(doc.example);\r\n\t\t\tparts.push('```');\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tcontents: {\r\n\t\t\t\tkind: MarkupKind.Markdown,\r\n\t\t\t\tvalue: parts.join('\\n')\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tprivate formatSymbolHover(symbol: any): Hover {\r\n\t\tconst parts: string[] = [];\r\n\r\n\t\t// Header\r\n\t\tconst kindName = symbol.kind.toLowerCase();\r\n\t\tparts.push(`**${symbol.name}** (${kindName})`);\r\n\t\tparts.push('');\r\n\r\n\t\t// Signature/Type\r\n\t\tif (symbol.kind === 'Function') {\r\n\t\t\tparts.push('```kemet');\r\n\t\t\tconst visibility = symbol.visibility.kind === 'Public' ? 'pub ' : '';\r\n\t\t\tconst metadata = symbol.metadata || {};\r\n\t\t\tconst params = metadata.params || [];\r\n\t\t\tconst returnType = metadata.returnType ? this.formatType(metadata.returnType) : 'void';\r\n\t\t\tconst errorType = metadata.errorType ? this.formatType(metadata.errorType) : null;\r\n\r\n\t\t\tconst paramStrs = params.map((p: any) => {\r\n\t\t\t\tconst mut = p.mutability?.kind === 'Mutable' ? 'mut ' : '';\r\n\t\t\t\treturn `${mut}${p.name}: ${p.type ? this.formatType(p.type) : 'unknown'}`;\r\n\t\t\t});\r\n\r\n\t\t\tconst errorPart = errorType ? `${errorType}!` : '';\r\n\t\t\tparts.push(`${visibility}fn ${symbol.name}(${paramStrs.join(', ')}) -> ${errorPart}${returnType}`);\r\n\t\t\tparts.push('```');\r\n\t\t} else if (symbol.kind === 'Variable' || symbol.kind === 'Parameter') {\r\n\t\t\tparts.push('```kemet');\r\n\t\t\tconst visibility = symbol.visibility?.kind === 'Public' ? 'pub ' : '';\r\n\t\t\tconst mutability = symbol.mutability?.kind === 'Mutable' ? 'mut ' : '';\r\n\t\t\tconst typeStr = symbol.type ? this.formatType(symbol.type) : 'unknown';\r\n\t\t\tparts.push(`${visibility}let ${mutability}${symbol.name}: ${typeStr}`);\r\n\t\t\tparts.push('```');\r\n\t\t}\r\n\r\n\t\t// Additional info\r\n\t\tconst info: string[] = [];\r\n\t\tif (symbol.visibility?.kind === 'Public') info.push('**public**');\r\n\t\tif (symbol.mutability?.kind === 'Mutable') info.push('**mutable**');\r\n\t\tif (symbol.isExported) info.push('**exported**');\r\n\t\tif (symbol.metadata?.isBuiltin) info.push('**built-in**');\r\n\r\n\t\tif (info.length > 0) {\r\n\t\t\tparts.push('');\r\n\t\t\tparts.push(info.join(' • '));\r\n\t\t}\r\n\r\n\t\t// Module info\r\n\t\tif (symbol.module) {\r\n\t\t\tparts.push('');\r\n\t\t\tparts.push(`Module: \\`${symbol.module}\\``);\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tcontents: {\r\n\t\t\t\tkind: MarkupKind.Markdown,\r\n\t\t\t\tvalue: parts.join('\\n')\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tprivate formatType(type: any): string {\r\n\t\tif (!type || !type.kind) return 'unknown';\r\n\r\n\t\tswitch (type.kind) {\r\n\t\t\tcase 'i8': case 'i16': case 'i32': case 'i64':\r\n\t\t\tcase 'u8': case 'u16': case 'u32': case 'u64':\r\n\t\t\tcase 'f32': case 'f64':\r\n\t\t\tcase 'bool': case 'void': case 'str':\r\n\t\t\t\treturn type.kind;\r\n\t\t\tcase 'pointer':\r\n\t\t\t\treturn `*${this.formatType(type.getPointer()?.target)}`;\r\n\t\t\tcase 'array':\r\n\t\t\t\treturn `[]${this.formatType(type.getArray()?.target)}`;\r\n\t\t\tcase 'optional':\r\n\t\t\t\treturn `?${this.formatType(type.getOptional()?.target)}`;\r\n\t\t\tcase 'function':\r\n\t\t\t\treturn 'fn';\r\n\t\t\tcase 'struct':\r\n\t\t\t\treturn 'struct';\r\n\t\t\tcase 'enum':\r\n\t\t\t\treturn 'enum';\r\n\t\t\tdefault:\r\n\t\t\t\treturn type.kind;\r\n\t\t}\r\n\t}\r\n}","// features/settings.ts — Settings and configuration management\r\n\r\nimport { Connection } from 'vscode-languageserver';\r\n\r\nexport interface ExtSettings {\r\n\tpath: string;\r\n\tshowWarnings?: boolean;\r\n\tshowInfos?: boolean;\r\n\tmaxDiagnostics?: number;\r\n\tenableMetrics?: boolean;\r\n}\r\n\r\nexport class SettingsManager {\r\n\tprivate connection: Connection;\r\n\tprivate hasConfigurationCapability = true;\r\n\tprivate documentSettings = new Map<string, Thenable<ExtSettings>>();\r\n\r\n\tprivate defaultSettings: ExtSettings = {\r\n\t\tpath: '',\r\n\t\tshowWarnings: true,\r\n\t\tshowInfos: true,\r\n\t\tmaxDiagnostics: 100,\r\n\t\tenableMetrics: false\r\n\t};\r\n\r\n\tprivate globalSettings: ExtSettings;\r\n\r\n\tconstructor(connection: Connection) {\r\n\t\tthis.connection = connection;\r\n\t\tthis.globalSettings = this.defaultSettings;\r\n\t}\r\n\r\n\tsetConfigurationCapability(hasCapability: boolean): void {\r\n\t\tthis.hasConfigurationCapability = hasCapability;\r\n\t}\r\n\r\n\tgetDocumentSettings(resource: string): Thenable<ExtSettings> {\r\n\t\tif (!this.hasConfigurationCapability) {\r\n\t\t\treturn Promise.resolve(this.globalSettings);\r\n\t\t}\r\n\r\n\t\tlet result = this.documentSettings.get(resource);\r\n\t\tif (!result) {\r\n\t\t\tresult = this.connection.workspace.getConfiguration({\r\n\t\t\t\tscopeUri: resource,\r\n\t\t\t\tsection: 'kemet'\r\n\t\t\t});\r\n\t\t\tthis.documentSettings.set(resource, result);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\tclearDocumentSettings(resource: string): void {\r\n\t\tthis.documentSettings.delete(resource);\r\n\t}\r\n\r\n\thandleConfigurationChange(change: any): void {\r\n\t\tif (this.hasConfigurationCapability) {\r\n\t\t\tthis.documentSettings.clear();\r\n\t\t} else {\r\n\t\t\tthis.globalSettings = <ExtSettings>(\r\n\t\t\t\t(change.settings.kemet || this.defaultSettings)\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\tclearAllSettings(): void {\r\n\t\tthis.documentSettings.clear();\r\n\t}\r\n}","// features/metrics.ts — Metrics and custom commands handler\r\n\r\nimport { Connection } from 'vscode-languageserver';\r\nimport * as ProjectLib from '@je-es/project';\r\n\r\ninterface ServerMetrics {\r\n\ttotalValidations: number;\r\n\ttotalErrors: number;\r\n\taverageValidationTime: number;\r\n\tcacheHitRate: number;\r\n}\r\n\r\nexport class MetricsHandler {\r\n\tprivate connection: Connection;\r\n\tprivate projects: { main: ProjectLib.Project; anonymous: ProjectLib.Project };\r\n\tprivate serverMetrics: ServerMetrics;\r\n\r\n\tconstructor(\r\n\t\tconnection: Connection,\r\n\t\tprojects: { main: ProjectLib.Project; anonymous: ProjectLib.Project },\r\n\t\tserverMetrics: ServerMetrics\r\n\t) {\r\n\t\tthis.connection = connection;\r\n\t\tthis.projects = projects;\r\n\t\tthis.serverMetrics = serverMetrics;\r\n\r\n\t\tthis.setupHandlers();\r\n\t}\r\n\r\n\tprivate setupHandlers(): void {}\r\n}"],"mappings":"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","names":["DiagCode","DiagKind","AnalysisPhase","targetSpan","__spreadValues","existingSymbol","symbolName","resolvedPath","targetModuleName","targetModuleScope","_a","l","r","currentScope","initType","_b","sizeExpr","memberType","width1","width2","maxWidth","__async","resolve","module","Path","relative","fileURLToPath","Path","relative","fileURLToPath","Path","KEYWORDS","KEYWORD_DOCS","relative","_a"]}